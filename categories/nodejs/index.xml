<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nodejs on OP blog</title>
    <link>https://qetr1ck-op.github.io/blog/categories/nodejs/index.xml</link>
    <description>Recent content in Nodejs on OP blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <atom:link href="https://qetr1ck-op.github.io/blog/categories/nodejs/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>react app with express in production</title>
      <link>https://qetr1ck-op.github.io/blog/post/react-app-with-express-in-production/</link>
      <pubDate>Sat, 24 Jun 2017 20:46:01 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/react-app-with-express-in-production/</guid>
      <description>&lt;p&gt;Password randomizer app which was done with: REST API on &lt;code&gt;Express.js&lt;/code&gt;, Client app on &lt;code&gt;React.js&lt;/code&gt;, Build with &lt;code&gt;npm&lt;/code&gt;, Deploy on &lt;code&gt;Heroku&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;demo&#34;&gt;Demo&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://morning-ocean-99678.herokuapp.com/&#34;&gt;client app&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://morning-ocean-99678.herokuapp.com/api/password&#34;&gt;api/password&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/qetr1ck-op/rando&#34;&gt;repo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;documentation&#34;&gt;Documentation&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://daveceddia.com/create-react-app-express-production/&#34;&gt;Create React App with Express in Production by Dave Ceddia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Interview question: NodeJS, part 2</title>
      <link>https://qetr1ck-op.github.io/blog/post/interview-question-nodejs-part-2/</link>
      <pubDate>Sun, 28 May 2017 17:43:40 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/interview-question-nodejs-part-2/</guid>
      <description>&lt;p&gt;Part two of original post &lt;a href=&#34;https://edgecoders.com/how-well-do-you-know-node-js-36b1473c01c8&#34;&gt;How well do you know Node.js?&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;what-s-the-problem-with-the-process-uncaughtexception-event-how-is-it-different-than-the-exit-event&#34;&gt;What’s the problem with the process &lt;code&gt;uncaughtException&lt;/code&gt; event? How is it different than the exit event?&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;uncaughtException&lt;/code&gt; event is emitted when an uncaught Javascript exception bubbles all the way back to the event loop. Once this event emmits, it means that your application is in an undefined state and it is not safe to continue. Hence this event should only be used to perform synchronous cleanup of resources, logging and shutting down the process.&lt;/p&gt;

&lt;p&gt;The exit event is emitted when the Node.js process is about the exit as a result of either:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;process.exit()&lt;/code&gt; method being called explicitly&lt;/li&gt;
&lt;li&gt;The event loop has no additional work to perform&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;what-does-the-mean-inside-of-node-s-repl&#34;&gt;What does the &lt;code&gt;_&lt;/code&gt;mean inside of Node’s REPL?&lt;/h1&gt;

&lt;p&gt;Node’s REPL always sets &lt;code&gt;_&lt;/code&gt; to the result of the last expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; 2
2
&amp;gt; _
2
&amp;gt; 2+2
4
&amp;gt; _
4
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;do-node-buffers-use-v8-memory-can-they-be-resized&#34;&gt;Do Node buffers use V8 memory? Can they be resized?&lt;/h1&gt;

&lt;p&gt;No to both questions - Node.js buffers correspond to fixed-sized, raw memory allocations outside the V8 heap.&lt;/p&gt;

&lt;h1 id=&#34;hat-s-the-difference-between-buffer-alloc-and-buffer-allocunsafe&#34;&gt;hat’s the difference between &lt;code&gt;Buffer.alloc&lt;/code&gt; and &lt;code&gt;Buffer.allocUnsafe&lt;/code&gt;?&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Buffer.alloc&lt;/code&gt; allocates a memory chunk, initializes it (sets every cell to either zero or some predefined value) and returns a Node.js Buffer wrapping this memory chunk. &lt;code&gt;Buffer.allocUnsafe&lt;/code&gt; skips the initialization stage. Instead it returns a Buffer pointing to uninitialized memory. This reduces the allocation time duration, but creates a possibility for (sensitive) data leakage, if this uninitialized memory is exposed to the user. Thus, you should only &lt;code&gt;Buffer.allocUnsafe&lt;/code&gt; only if you plan to initialize the memory chunk yourself.&lt;/p&gt;

&lt;h1 id=&#34;how-is-the-slice-method-on-buffers-different-from-that-on-arrays&#34;&gt;How is the slice method on buffers different from that on arrays?&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;buf.slice()&lt;/code&gt; method on buffers is a mutating operation which modifies the memory in the original buffer. The &lt;code&gt;Array.prototype.slice()&lt;/code&gt; method returns a shallow copy of a portion of an array and does not modify it.&lt;/p&gt;

&lt;h1 id=&#34;what-is-the-string-decoder-module-useful-for-how-is-it-different-than-casting-buffers-to-strings&#34;&gt;What is the &lt;code&gt;string_decoder&lt;/code&gt; module useful for? How is it different than casting buffers to strings?&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;string_decoder&lt;/code&gt; is useful for decoding a Buffer instance into strings while preserving endoded multi-byte UTF-8 / UTF-16 characters. In oppose to simple buffer cast to string, the string_decodure can detect incomplete multibyte characters and handle them. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const StringDecoder = require(&#39;string_decoder&#39;).StringDecoder;
const decoder = new StringDecoder(&#39;utf8&#39;);

const euro = Buffer.from([0xE2, 0x82, 0xAC]);
const incompleteEuro = Buffer.from([0xE2, 0x82]);

console.log(decoder.write(euro)); // prints &#39;€&#39;
console.log(incompleteEuro.toString(&#39;utf8&#39;)); // prints &#39;��&#39;
console.log(decoder.write(incompleteEuro)); // prints &#39;&#39; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;what-are-the-5-major-steps-that-the-require-function-does&#34;&gt;What are the 5 major steps that the require function does?&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Check Module._cache for the cached module&lt;/li&gt;
&lt;li&gt;If cache is empty, create a new Module instance and save it to the cache&lt;/li&gt;
&lt;li&gt;Call module.load() with the given filename. This will call module.compile() after reading the file contents&lt;/li&gt;
&lt;li&gt;If there was an error loading/parsing the file, delete the bad module from the cache&lt;/li&gt;
&lt;li&gt;return module.exports&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;what-is-the-require-resolve-function-and-what-is-it-useful-for&#34;&gt;What is the &lt;code&gt;require.resolve&lt;/code&gt; function and what is it useful for?&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;require.resolve&lt;/code&gt; methods resolves a module to its absolute path.&lt;/p&gt;

&lt;h1 id=&#34;what-is-the-main-property-in-package-json-useful-for&#34;&gt;What is the main property in &lt;code&gt;package.json&lt;/code&gt; useful for?&lt;/h1&gt;

&lt;p&gt;The main field is a module ID that is the primary entry point to your program. For example, if your package is named foo, and a user does &lt;code&gt;require(&amp;quot;foo&amp;quot;)&lt;/code&gt;, then your main module’s exports object will be returned.&lt;/p&gt;

&lt;h1 id=&#34;what-are-circular-modular-dependencies-in-node-and-how-can-they-be-avoided&#34;&gt;What are circular modular dependencies in Node and how can they be avoided?&lt;/h1&gt;

&lt;p&gt;We say that module &lt;code&gt;A&lt;/code&gt; dependends on module &lt;code&gt;B&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; has &lt;code&gt;require(&#39;B&#39;)&lt;/code&gt; in it. Assume a dependency graph where an edge &lt;code&gt;(A,B)&lt;/code&gt; means that &lt;code&gt;A&lt;/code&gt; dependens on &lt;code&gt;B&lt;/code&gt;. Then Circular modular dependencies are cycles in this dependency graph. Two ways to avoid circular modular are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;move the require statements from the top of the file to the point in code they’re actually used. this will delay their execution, allowing for the exports to have been created properly&lt;/li&gt;
&lt;li&gt;restructure the code. For example move the code that both modules depend on into a new module &lt;code&gt;C&lt;/code&gt; and let both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; depend on &lt;code&gt;C&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;what-are-the-3-file-extensions-that-will-be-automatically-tried-by-the-require-function&#34;&gt;What are the 3 file extensions that will be automatically tried by the require function?&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.json&lt;/code&gt; and &lt;code&gt;.node&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;when-creating-an-http-server-and-writing-a-response-for-a-request-why-is-the-end-function-required&#34;&gt;When creating an http server and writing a response for a request, why is the &lt;code&gt;end()&lt;/code&gt; function required?&lt;/h1&gt;

&lt;p&gt;Since the res object is a stream, we can write into it in several stages. the &lt;code&gt;end()&lt;/code&gt; method indicates that we’ve finished writing into it and that the response is ready to be sent to the client.&lt;/p&gt;

&lt;h1 id=&#34;when-is-it-ok-to-use-the-file-system-sync-methods&#34;&gt;When is it ok to use the file system *Sync methods?&lt;/h1&gt;

&lt;p&gt;When it is OK to block the process while the synchronous operation takes place. For example, this may be valid when writing a CLI tool. It’s most likely not OK when writing a server that should handle multiple clients concurrently.&lt;/p&gt;

&lt;h1 id=&#34;how-can-you-print-only-one-level-of-a-deeply-nested-object&#34;&gt;How can you print only one level of a deeply nested object?&lt;/h1&gt;

&lt;p&gt;You can use the util.inspect method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const obj = {
  a: &amp;quot;a&amp;quot;,
  b: {
    c: &amp;quot;c&amp;quot;,
    d: {
      e: &amp;quot;e&amp;quot;,
      f: {
        g: &amp;quot;g&amp;quot;,
      }
    }
  }
};    

const util = require(&#39;util&#39;);
console.log(util.inspect(obj, {depth: 0})); // prints: &#39;{ a: \&#39;a\&#39;, b: [Object]}&#39;
console.log(util.inspect(obj, {depth: null})); // prints: &#39;{ a: \&#39;a\&#39;, b: { c: \&#39;c\&#39;, d: { e: \&#39;e\&#39;, f: { g: \&#39;g\&#39; } } } }&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;the-objects-exports-require-and-module-are-all-globally-available-in-every-module-but-they-are-different-in-every-module-how&#34;&gt;The objects exports, require, and module are all globally available in every module but they are different in every module. How?&lt;/h1&gt;

&lt;p&gt;Before a module’s code is executed, Node.js wraps it in the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;(function (exports, require, module, __filename, __dirname) {
// Your module code actually lives in here
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This means that while &lt;code&gt;exports&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;module&lt;/code&gt; appear to be global variables, they’re actually specific to the module.&lt;/p&gt;

&lt;h1 id=&#34;if-you-execute-a-node-script-file-that-has-the-single-line-console-log-arguments-what-exactly-will-node-print&#34;&gt;If you execute a node script file that has the single line: &lt;code&gt;console.log(arguments);&lt;/code&gt;, what exactly will node print?&lt;/h1&gt;

&lt;p&gt;As seen in the answer above, the module code is an invocation of a function taking exports, &lt;code&gt;require&lt;/code&gt;, &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;__filename&lt;/code&gt; and &lt;code&gt;__dirname&lt;/code&gt; as arguments, so these arguments will be printed.&lt;/p&gt;

&lt;h1 id=&#34;how-can-a-module-be-both-requirable-by-other-modules-and-executable-directly-using-the-node-command&#34;&gt;How can a module be both requirable by other modules and executable directly using the node command?&lt;/h1&gt;

&lt;p&gt;A module can detect if its being requirable or executed directly by inspecting the &lt;code&gt;require.main&lt;/code&gt; value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if (require.main === module) {
    console.log(&#39;called directly&#39;);
} else {
    console.log(&#39;required as a module&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;what-s-an-example-of-a-built-in-stream-in-node-that-is-both-readable-and-writable&#34;&gt;What’s an example of a built-in stream in Node that is both readable and writable?&lt;/h1&gt;

&lt;p&gt;Duplex streams are streams that implement both the Readable and Writable interfaces. Examples of Duplex streams include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TCP sockets&lt;/li&gt;
&lt;li&gt;zlib streams&lt;/li&gt;
&lt;li&gt;crypto streams&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;the-require-function-always-caches-the-module-it-requires-what-can-you-do-if-you-need-to-execute-the-code-in-a-required-module-many-times&#34;&gt;The &lt;code&gt;require&lt;/code&gt; function always caches the module it requires. What can you do if you need to execute the code in a required module many times?&lt;/h1&gt;

&lt;p&gt;The cache in which modules are cached in is accessible using &lt;code&gt;require.cache&lt;/code&gt;. Thus, if you delete a module key from require.cache, the next time you require it will reload it (and will execute the code in it again).&lt;/p&gt;

&lt;h1 id=&#34;what-is-the-console-time-function-useful-for&#34;&gt;What is the &lt;code&gt;console.time&lt;/code&gt; function useful for?&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;console.time&lt;/code&gt; is useful to measure the time difference between two points in the code; calling &lt;code&gt;console.time&lt;/code&gt;(&amp;lsquo;label&amp;rsquo;) will record the current time, and later calling &lt;code&gt;console.timeEnd(&#39;label&#39;&lt;/code&gt;) will display the time difference up to this point (in milliseconds), alongside the label.&lt;/p&gt;

&lt;h1 id=&#34;what-s-the-difference-between-the-paused-and-the-flowing-modes-of-readable-streams&#34;&gt;What’s the difference between the paused and the flowing modes of readable streams?&lt;/h1&gt;

&lt;p&gt;Readable streams operate in either paused or flowing modes. When in flowing mode, data is read from the underlying system automatically and provided to an application as quickly as possible using events via the EventEmitter interface. In paused mode, the &lt;code&gt;stream.read()&lt;/code&gt; method must be called explicitly to read chunks of data from the stream.&lt;/p&gt;

&lt;h1 id=&#34;what-does-the-inspect-argument-do-for-the-node-command&#34;&gt;What does the &lt;code&gt;--inspect&lt;/code&gt; argument do for the node command?&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;--inspect&lt;/code&gt; argument allows to attache Chrome DevTools to Node.js instances for debugging and profiling.&lt;/p&gt;

&lt;h1 id=&#34;when-working-with-streams-when-do-you-use-the-pipe-function-and-when-do-you-use-events-can-those-two-methods-be-combined&#34;&gt;When working with streams, when do you use the pipe function and when do you use events? Can those two methods be combined?&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;.pipe()&lt;/code&gt; is a function that takes a readable source stream src and hooks the output to a destination writable stream dst&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;src.pipe(dst)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;essentially it means that &lt;code&gt;.pipe()&lt;/code&gt; takes care of listening for data and end events from src. So, to answer the questions, using &lt;code&gt;.pipe()&lt;/code&gt; can make the code more straight forward when this is the functionally you’re interested in. Events can be used to tailor more specific functionally for your use case.&lt;/p&gt;

&lt;h1 id=&#34;save-my-day&#34;&gt;Save my day&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://edgecoders.com/how-well-do-you-know-node-js-36b1473c01c8&#34;&gt;original questions by Samer Buna&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://asafdav2.github.io/2017/how-well-do-you-know-node-js-answers-part-2/&#34;&gt;original post by asafdav2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Interview question: NodeJS, part 1</title>
      <link>https://qetr1ck-op.github.io/blog/post/interview-question-nodejs-part-1/</link>
      <pubDate>Sun, 14 May 2017 17:43:40 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/interview-question-nodejs-part-1/</guid>
      <description>&lt;p&gt;Based on original post &lt;a href=&#34;https://edgecoders.com/how-well-do-you-know-node-js-36b1473c01c8&#34;&gt;How well do you know Node.js?&lt;/a&gt;. In it, Samer Buna lists 48 questions which be expects a Node.js developer to be able to answer.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;what-is-the-relationship-between-node-js-and-v8-can-node-work-without-v8&#34;&gt;What is the relationship between Node.js and V8? Can Node work without V8?&lt;/h1&gt;

&lt;p&gt;V8 is a JavaScript engine developed by The Chromium Project, first for the Google Chrome web browser and later for other projects, including NodeJS. It allows to compile, optimize and run JavaScript code and is the base for code execution inside Node.js. However, V8 is not essential for Node.js; There are attempts to use other javascript engines, such as &lt;a href=&#34;https://github.com/nodejs/node-chakracore&#34;&gt;node-chakracore&lt;/a&gt; (Node.js on ChakraCore) or &lt;a href=&#34;https://github.com/mozilla/spidernode&#34;&gt;spidernode&lt;/a&gt; (Node.js on top of SpiderMonkey).&lt;/p&gt;

&lt;h1 id=&#34;how-come-when-you-declare-a-global-variable-in-any-node-js-file-it-s-not-really-global-to-all-modules&#34;&gt;How come when you declare a global variable in any Node.js file it’s not really global to all modules?&lt;/h1&gt;

&lt;p&gt;A module’s code is wrapped by a function wrapper. To see it just execute node.js file with syntax error on first line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;gt; node 1/bugToSeeWrapperFn.js
&amp;gt; /home/oop/Documents/bugToSeeWrapperFn.js:1

(function (exports, require, module, __filename, __dirname) { foo
  // module code
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This wrapping allows to keeps top-level variables (defined with var, const or let) scoped to the module, rather than to the global object.&lt;/p&gt;

&lt;p&gt;Read more on the &lt;a href=&#34;https://nodejs.org/api/modules.html#modules_the_module_wrapper&#34;&gt;module wrapper&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;when-exporting-the-api-of-a-node-module-why-can-we-sometimes-use-exports-and-other-times-we-have-to-use-module-exports&#34;&gt;When exporting the API of a Node module, why can we sometimes use &lt;code&gt;exports&lt;/code&gt; and other times we have to use &lt;code&gt;module.exports?&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;To understand the difference, we can look at this simplified view of a JavaScript file in Node.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var module = { exports: {} };
var exports = module.exports;

// your code

return module.exports;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, &lt;code&gt;exports&lt;/code&gt; is initially a reference to &lt;code&gt;module.exports&lt;/code&gt;. if you want to simply export an object with named fields, you can use the exports shortcut. For example, had we written &lt;code&gt;exports.a = 9&lt;/code&gt;, we’d actually export this object: &lt;code&gt;{ a: 9 }&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;However, if you want to export a function or another object, you have to use the &lt;code&gt;module.exports&lt;/code&gt; but you cannot use &lt;code&gt;exports&lt;/code&gt;. For example: &lt;code&gt;module.exports = function bar() {}&lt;/code&gt;. Once you do that, &lt;code&gt;exports&lt;/code&gt; and &lt;code&gt;module.exports&lt;/code&gt; no longer reference the same object.&lt;/p&gt;

&lt;h1 id=&#34;can-we-require-local-files-without-using-relative-paths&#34;&gt;Can we require local files without using relative paths?&lt;/h1&gt;

&lt;p&gt;There are several options, as described &lt;a href=&#34;https://gist.github.com/qetr1ck-op/ba2c8ad84ae8cd3ce6c928872eaa6933&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;can-different-versions-of-the-same-package-be-used-in-the-same-application&#34;&gt;Can different versions of the same package be used in the same application?&lt;/h1&gt;

&lt;p&gt;No, this is currently prevented by NPM. see this issue for &lt;a href=&#34;https://github.com/npm/npm/issues/2943#issuecomment-10388316&#34;&gt;more details&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;what-is-the-event-loop-is-it-part-of-v8&#34;&gt;What is the Event Loop? Is it part of V8?&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;../../images/posts/nodejs-interview-question/nodejs-arhitecture.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In event-driven programming, an application expresses interest in certain events and respond to them when they occur. This is the way Node.js can handle asynchronous execution while running the code in a single thread.&lt;/p&gt;

&lt;p&gt;When an asynchronous operation starts (for example, when we call &lt;code&gt;setTimeout&lt;/code&gt;, &lt;code&gt;http.get&lt;/code&gt; or &lt;code&gt;fs.readFile&lt;/code&gt;), Node.js sends these operations to a different thread allowing &lt;code&gt;V8&lt;/code&gt; to keep executing our code. Node also calls the callback when the counter has run down or the &lt;code&gt;IO / http&lt;/code&gt; operation has finished.&lt;/p&gt;

&lt;p&gt;In Node.js, the responsibility of gathering events from the operating system or monitoring other sources of events is handled by &lt;code&gt;libuv&lt;/code&gt;, and the user can register callbacks to be invoked when an event occurs. When async operation is done &lt;code&gt;libuv&lt;/code&gt; passes control to &lt;code&gt;V8&lt;/code&gt; to execute the callbacks.&lt;/p&gt;

&lt;h1 id=&#34;what-is-libuv-and-how-does-node-js-use-it-is-it-part-of-v8&#34;&gt;What is libuv and how does Node.js use it? Is it part of V8?&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/libuv/libuv&#34;&gt;libuv&lt;/a&gt; is a multi-platform support library with a focus on asynchronous I/O. Its core job is to provide an event loop and callback based notifications of I/O and other activities. In addition, libuv offers core utilities such as timers, non-blocking networking support, asynchronous file system access, child processes and more.&lt;/p&gt;

&lt;h1 id=&#34;what-is-the-call-stack-is-it-part-of-v8&#34;&gt;What is the Call Stack? Is it part of V8?&lt;/h1&gt;

&lt;p&gt;The call stack is the basic mechanism for javascript code execution. When we call a function, we push the function parameters and the return address to the stack. This allows to runtime to know where to continue code execution once the function ends. In Node.js, the Call Stack is handled by &lt;code&gt;V8&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;what-is-the-difference-between-setimmediate-and-process-nexttick&#34;&gt;What is the difference between setImmediate and process.nextTick?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;setImmediate&lt;/code&gt; queues a function behind whatever I/O event callbacks that are already in the event queue.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;process.nextTick&lt;/code&gt; queues a function at the head of the event queue so that it executes immediately after the currently running function completes.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setTimeout&lt;/code&gt; vs &lt;code&gt;setImmediate&lt;/code&gt; vs &lt;code&gt;process.nextTick&lt;/code&gt;, &lt;a href=&#34;http://stackoverflow.com/questions/17502948/nexttick-vs-setimmediate-visual-explanation#38742776&#34;&gt;visual explanation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setImmediate&lt;/code&gt; executes after &lt;code&gt;setTimeout&lt;/code&gt;, &lt;a href=&#34;https://github.com/nodejs/node-v0.x-archive/issues/25788&#34;&gt;explanation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;how-do-you-make-an-asynchronous-function-return-a-value&#34;&gt;How do you make an asynchronous function return a value?&lt;/h1&gt;

&lt;p&gt;You could return a promise resolving to that value, for example return &lt;code&gt;Promise.resolve(value)&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;can-callbacks-be-used-with-promises-or-is-it-one-way-or-the-other&#34;&gt;Can callbacks be used with promises or is it one way or the other?&lt;/h1&gt;

&lt;p&gt;Callbacks and promises can be used together. For example, the following method calls a callback and returns a promise:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function processToGetValue(cb) {
  // do some processing to value
  if (cb) {
    cb(value);
  }
  return Promise.resolve(value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;what-are-the-major-differences-between-spawn-exec-and-fork&#34;&gt;What are the major differences between spawn, exec, and fork?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;exec&lt;/code&gt; methods spawns a shell and then executes a command within that shell, buffering any generated output&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spawn&lt;/code&gt; works similarly to &lt;code&gt;exec&lt;/code&gt;. The main difference is that spawn returns the process output as a stream while exec returns it as a buffer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fork&lt;/code&gt; is a special case of spawn that also creates a new &lt;code&gt;V8&lt;/code&gt; engine instance. This is useful to create additional workers of the same Node.js code base. (for example, in the &lt;a href=&#34;https://nodejs.org/api/cluster.html&#34;&gt;cluster module&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Great article &lt;a href=&#34;https://dzone.com/articles/understanding-execfile-spawn-exec-and-fork-in-node&#34;&gt;Understanding execFile, spawn, exec, and fork in Node.js&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;how-does-the-cluster-module-work-how-is-it-different-than-using-a-load-balancer&#34;&gt;How does the cluster module work? How is it different than using a load balancer?&lt;/h1&gt;

&lt;p&gt;The cluster module works by forking the server into several worker processes (all run inside the &lt;strong&gt;same host&lt;/strong&gt;). The master process listens and accepts new connections and distributes them across the worker processes in a &lt;code&gt;round-robin&lt;/code&gt; fashionhug (with some built-in smarts to avoid overloading a worker process).&lt;/p&gt;

&lt;p&gt;A load balancer, in contrast, is used to distribute incoming connections across &lt;strong&gt;multiple hosts&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;what-is-load-balancing&#34;&gt;What is load balancing?&lt;/h1&gt;

&lt;p&gt;Detailed answer &lt;a href=&#34;../../post/what-is-load-balancing/&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;what-are-the-harmony-flags&#34;&gt;What are the &lt;code&gt;--harmony-*&lt;/code&gt; flags?&lt;/h1&gt;

&lt;p&gt;These are flags that one can pass to the Node.js runtime to enable Staged features. Staged features are almost-completed features that are not considered stable by the V8 team.&lt;/p&gt;

&lt;h1 id=&#34;how-can-you-read-and-inspect-the-memory-usage-of-a-node-js-process&#34;&gt;How can you read and inspect the memory usage of a Node.js process?&lt;/h1&gt;

&lt;p&gt;You can invoke the &lt;code&gt;process.memoryUsage()&lt;/code&gt; method which returns an object describing the memory usage of the Node.js process, measured in bytes.&lt;/p&gt;

&lt;h1 id=&#34;what-is-process-argv-what-type-of-data-does-it-hold&#34;&gt;What is &lt;code&gt;process.argv&lt;/code&gt;? What type of data does it hold?&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;process.argv&lt;/code&gt; property returns an array containing the command line arguments passed when the Node.js process was launched. The first element will be &lt;code&gt;process.execPath&lt;/code&gt;. The second element will be the path to the JavaScript file being executed. The remaining elements will be any additional command line arguments.&lt;/p&gt;

&lt;h1 id=&#34;how-can-we-do-one-final-operation-before-a-node-process-exits-can-that-operation-be-done-asynchronously&#34;&gt;How can we do one final operation before a Node process exits? Can that operation be done asynchronously?&lt;/h1&gt;

&lt;p&gt;By registering a handler for &lt;code&gt;process.on(&#39;exit&#39;)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function exitHandler(options, err) {
    console.log(&#39;clean&#39;);
}

process.on(&#39;exit&#39;, exitHandler.bind(null));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Listener functions to the exit event must only perform synchronous operations. To perform asynchronous operations, one can register a handler for &lt;code&gt;process.on(&#39;beforeExit&#39;)&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;what-are-some-of-the-built-in-dot-commands-you-can-use-in-node-s-repl&#34;&gt;What are some of the built-in dot commands you can use in Node’s REPL?&lt;/h1&gt;

&lt;p&gt;The following dot commands can be used:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.break&lt;/code&gt; - When in the process of inputting a multi-line expression, entering the .break command (or pressing the &lt;code&gt;&amp;lt;ctrl&amp;gt;-C&lt;/code&gt; key combination) will abort further input or processing of that expression.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.clear&lt;/code&gt; - Resets the REPL ‘context’ to an empty object and clears any multi-line expression currently being input.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.exit&lt;/code&gt; - Close the I/O stream, causing the REPL to exit.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.help&lt;/code&gt; - Show this list of special commands.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.save&lt;/code&gt; - Save the current REPL session to a file: &lt;code&gt;&amp;gt; .save ./file/to/save.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.load&lt;/code&gt; - Load a file into the current REPL session. &lt;code&gt;&amp;gt; .load ./file/to/load.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.editor&lt;/code&gt; - Enter editor mode (&lt;code&gt;&amp;lt;ctrl&amp;gt;-D&lt;/code&gt; to finish, &lt;code&gt;&amp;lt;ctrl&amp;gt;-C&lt;/code&gt; to cancel)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;besides-v8-and-libuv-what-other-external-dependencies-does-node-have&#34;&gt;Besides V8 and libuv, what other external dependencies does Node have?&lt;/h1&gt;

&lt;p&gt;Beside V8 and libuv, node has several other dependencies:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;http-parser: a lightweight C library which handles HTTP parsing&lt;/li&gt;
&lt;li&gt;c-areas: used for some asynchronous DNS requests&lt;/li&gt;
&lt;li&gt;OpenSSL: used extensively in both the tls and crypto modules&lt;/li&gt;
&lt;li&gt;zlib: used for fast compression and decompression&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Read more about &lt;a href=&#34;https://nodejs.org/en/docs/meta/topics/dependencies/&#34;&gt;node dependencies&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;save-my-day&#34;&gt;Save my day&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://edgecoders.com/how-well-do-you-know-node-js-36b1473c01c8&#34;&gt;original questions by Samer Buna&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://asafdav2.github.io/2017/how-well-do-you-know-node-js-answers-part-1/&#34;&gt;original post by asafdav2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Asynchronous Javascript with async/await</title>
      <link>https://qetr1ck-op.github.io/blog/post/asynchronous-javascript-with-async-await/</link>
      <pubDate>Tue, 09 May 2017 21:57:55 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/asynchronous-javascript-with-async-await/</guid>
      <description>&lt;p&gt;ES2017 async and await keywords to write asynchronous code that is more readable and easier to follow than equivalent code based on long promise chains or deeply nested callbacks.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The await operator takes a promise and then pauses the function execution until that promise is settled which allows for an async function to read like sequential synchronous code.&lt;/p&gt;

&lt;h1 id=&#34;write-an-asynchronous-function-with-async-await&#34;&gt;Write an Asynchronous Function with async/await&lt;/h1&gt;

&lt;p&gt;With traditional chain of promises:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fetch = require(&#39;node-fetch&#39;)

function showGitHubUser(userName) {
  fetch(`http://api.github.com/users/${userName}`)
    .then(data =&amp;gt; data.json())
    .then(user =&amp;gt; {
      const { name, location } = user

      console.log(name, location)
    })
}

showGitHubUser(&#39;qetr1ck-op&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rewrite to &lt;code&gt;async/await&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fetch = require(&#39;node-fetch&#39;)

async function showGitHubUser(userName) {
  const data = await fetch(`http://api.github.com/users/${userName}`)
  const user = await data.json()
  const { name, location } = user

  console.log(name, location)
}

showGitHubUser(&#39;qetr1ck-op&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;call-an-asynchronous-function-in-a-promise-chain&#34;&gt;Call an Asynchronous function in a Promise chain&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fetch = require(&#39;node-fetch&#39;)

async function showGitHubUser(userName) {
  const data = await fetch(`http://api.github.com/users/${userName}`)
  return await data.json()
}

showGitHubUser(&#39;qetr1ck-op&#39;).then(user =&amp;gt; {
  const { name, location } = user

  console.log(name, location)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;convert-any-function-into-asynchronous-function&#34;&gt;Convert any function into Asynchronous Function&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fetch = require(&#39;node-fetch&#39;)

class GitHubApiClient {
  // the same syntax with objects
  async fetchUser(handle) {
    const url = `https://api.github.com/users/${handle}`
    const response = await fetch(url)
    return await response.json()
  }
}

// classic iife
;(async () =&amp;gt; {
  const client = new GitHubApiClient()
  const user = await client.fetchUser(&#39;qetr1ck-op&#39;)
  console.log(user.name)
  console.log(user.location)
})()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;handle-errors-in-asynchronous-function&#34;&gt;Handle Errors in Asynchronous Function&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fetch = require(&#39;node-fetch&#39;)

async function fetchGitHubUser(userName) {
  const response = await fetch(`http://api.github.com/users/${userName}`)

  if (!response.ok)
    throw Error(response.statusText)

  return await response.json()
}

(async () =&amp;gt; {
  try {
    const { name, location } = await fetchGitHubUser(&#39;unknownuserstring&#39;)
    console.log(name, location)
  } catch(e) {
    console.error(e)
  }
})()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;await-multiple-promises-sequentially-or-concurrently&#34;&gt;Await multiple promises sequentially or concurrently&lt;/h1&gt;

&lt;p&gt;You can await multiple promises either sequentially or concurrently, depending on where you put the await operators.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fetch = require(&#39;node-fetch&#39;)
const measureTime = require(&#39;measure-time&#39;)

async function fetchGitHubUser(endpoint) {
  const response = await fetch(`http://api.github.com${endpoint}`)

  if (!response.ok) throw Error(response.statusText)

  return await response.json()
}

;(async () =&amp;gt; {
  // concurrent
  const t1 = measureTime()
  const user = await fetchGitHubUser(&#39;/users/qetr1ck-op&#39;)
  const repos = await fetchGitHubUser(&#39;/users/qetr1ck-op/repos&#39;)

  console.log(`concurrent: ${t1().millisecondsTotal}`)
  console.log(user.name, `repos: ${repos.length}`)
})()

;(async () =&amp;gt; {
  // parallel
  const t1 = measureTime()
  const userPromise = fetchGitHubUser(&#39;/users/qetr1ck-op&#39;)
  const reposPromise = fetchGitHubUser(&#39;/users/qetr1ck-op/repos&#39;)

  const user = await userPromise
  const repos = await reposPromise

  console.log(`parallel: ${t1().millisecondsTotal}`)
  console.log(user.name, `repos: ${repos.length}`)
})()


;(async () =&amp;gt; {
  // parallel vol.2
  const t1 = measureTime()
  const [ user, repos ] = await Promise.all([
      fetchGitHubUser(&#39;/users/qetr1ck-op&#39;),
      fetchGitHubUser(&#39;/users/qetr1ck-op/repos&#39;)
  ])

  console.log(user.name, `repos: ${repos.length}`)
})()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;use-the-await-operator-with-any-thenable&#34;&gt;Use the &lt;code&gt;await&lt;/code&gt; Operator with Any Thenable&lt;/h1&gt;

&lt;p&gt;The await operator is not restricted to ES2015 promises. It can be used to await any thenable — that is, any object with a .then() method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Bluebird = require(&amp;quot;bluebird&amp;quot;);

async function main() {
    console.log(&amp;quot;Working ...&amp;quot;);
    await Bluebird.delay(2000);
    console.log(&amp;quot;Done.&amp;quot;);
}

main();
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;iterate-asynchronously-with-the-for-await-of-loop&#34;&gt;Iterate Asynchronously with the &lt;code&gt;for-await-of&lt;/code&gt; Loop&lt;/h1&gt;

&lt;p&gt;An &lt;a href=&#34;https://github.com/mariusschulz/egghead-async-await/tree/master/lesson-8&#34;&gt;example&lt;/a&gt; with &lt;code&gt;ts&lt;/code&gt; configuration&lt;/p&gt;

&lt;h1 id=&#34;save-my-day&#34;&gt;Save my day&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://egghead.io/courses/asynchronous-javascript-with-async-await&#34;&gt;original videos by Marius Schulz on egghead&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Advanced NodeJS</title>
      <link>https://qetr1ck-op.github.io/blog/post/advanced-nodejs/</link>
      <pubDate>Tue, 02 May 2017 20:16:35 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/advanced-nodejs/</guid>
      <description>&lt;p&gt;This course will teach you the core Node.js concepts and API modules from simple utility modules all the way to streams and clusters.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;!--toc--&gt;

&lt;h1 id=&#34;node-javascript&#34;&gt;Node != Javascript&lt;/h1&gt;

&lt;h2 id=&#34;node-s-architecture&#34;&gt;Node&amp;rsquo;s architecture&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Node VMs: &lt;code&gt;V8&lt;/code&gt;, &lt;code&gt;Chakra&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;V8 Feature Groups: &lt;code&gt;shipping&lt;/code&gt;, &lt;code&gt;staged (--harmony)&lt;/code&gt;, &lt;code&gt;inprogress (--harmony_for_in)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;All V8 options &lt;code&gt;node --v8-options | less&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Node&amp;rsquo;s architecture diagram: &lt;code&gt;V8&lt;/code&gt; and &lt;code&gt;libuv&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;node-s-cli-and-repl&#34;&gt;Node&amp;rsquo;s CLI and REPL&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Autocomplete feature&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_&lt;/code&gt; as last evaluated value&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; repl commands&lt;/li&gt;
&lt;li&gt;&lt;code&gt;repl&lt;/code&gt; module&lt;/li&gt;
&lt;li&gt;Node&amp;rsquo;s available list commands &lt;code&gt;node --help | less&lt;/code&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;global-object-process-buffer&#34;&gt;&amp;ldquo;global&amp;rdquo; Object, &amp;ldquo;Process&amp;rdquo;, &amp;ldquo;Buffer&amp;rdquo;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;local vs &lt;code&gt;global&lt;/code&gt; scope&lt;/li&gt;
&lt;li&gt;&lt;code&gt;process&lt;/code&gt; as a bridge between Node app and its running env

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;process.versions&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;process.release.lts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;process.env&lt;/code&gt; as &lt;code&gt;PATH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;using as &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/1.5/index.js&#34;&gt;configuration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;process&lt;/code&gt; is an &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/1.5/process.js&#34;&gt;event emitter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Buffer&lt;/code&gt; is essentially a used to work with binary streams of data.

&lt;ul&gt;
&lt;li&gt;read length &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/1.5/buffer.js&#34;&gt;Buffer.from&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;can use similar method as on array, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/1.5/buff.slice.js&#34;&gt;slice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string_decoder&lt;/code&gt; module provides an API for decoding Buffer objects into strings in a manner that preserves encoded multi-byte UTF-8 and UTF-16 characters, [example]()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;how-require-actually-works&#34;&gt;How &amp;ldquo;require&amp;rdquo; actually works&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Steps: resolving -&amp;gt; loading -&amp;gt; wrapping -&amp;gt; evaluating -&amp;gt; caching&lt;/li&gt;
&lt;li&gt;&lt;code&gt;module&lt;/code&gt; module, &lt;code&gt;module.path&lt;/code&gt;, &lt;code&gt;module.parent&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;require.resolve&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;algorithm of &lt;code&gt;require&lt;/code&gt; search&lt;/li&gt;
&lt;li&gt;&lt;code&gt;module.exports&lt;/code&gt; = &lt;code&gt;exports&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;module.loaded&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/1.6/index.js&#34;&gt;examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;json-and-c-addons&#34;&gt;JSON and C++ addons&lt;/h2&gt;

&lt;h2 id=&#34;wrapping-and-caching-modules&#34;&gt;Wrapping and Caching modules&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;require(&#39;module&#39;).wrapper&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;require.main === module&lt;/code&gt; with CLI and requiring module &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/1.8/printStars.js&#34;&gt;printStars.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;delete &lt;code&gt;require.cache&lt;/code&gt; or &lt;code&gt;module.exports&lt;/code&gt; as a function&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;know-your-npm&#34;&gt;Know your npm&lt;/h2&gt;

&lt;h1 id=&#34;concurrency-model-and-event-loop&#34;&gt;Concurrency model and Event Loop&lt;/h1&gt;

&lt;h2 id=&#34;what-is-i-o-anyway&#34;&gt;What is I/O anyway?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;the definition&lt;/li&gt;
&lt;li&gt;node architecture in I/O&lt;/li&gt;
&lt;li&gt;handling slow I/O operation: synchronous, &lt;code&gt;fork()&lt;/code&gt; for new process, threads (problem with sharing resources), event loop&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-event-loop&#34;&gt;The Event Loop&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;the definition&lt;/li&gt;
&lt;li&gt;the visualization&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-call-stack&#34;&gt;The Call Stack&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;the definition&lt;/li&gt;
&lt;li&gt;the visualization&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;handling-slow-operation&#34;&gt;Handling slow operation&lt;/h2&gt;

&lt;h2 id=&#34;how-callbacks-actually-work&#34;&gt;How callbacks actually work&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;the visualization&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;settimeout-setimmediate-process-nexttick&#34;&gt;&amp;ldquo;setTimeout&amp;rdquo;, &amp;ldquo;setImmediate&amp;rdquo;, &amp;ldquo;process.nextTick&amp;rdquo;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/2.7/nextTick.js&#34;&gt;example&lt;/a&gt; how to handle async error&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setTimeout&lt;/code&gt; vs &lt;code&gt;setImmediate&lt;/code&gt; vs &lt;code&gt;process.nextTick&lt;/code&gt;, visual explanation [&lt;a href=&#34;http://stackoverflow.com/questions/17502948/nexttick-vs-setimmediate-visual-explanation#38742776&#34;&gt;http://stackoverflow.com/questions/17502948/nexttick-vs-setimmediate-visual-explanation#38742776&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setImmediate&lt;/code&gt; executes after &lt;code&gt;setTimeout&lt;/code&gt;, &lt;a href=&#34;https://github.com/nodejs/node-v0.x-archive/issues/25788&#34;&gt;explanation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;node-s-event-driven-architecture&#34;&gt;Node&amp;rsquo;s Event-driven architecture&lt;/h1&gt;

&lt;h2 id=&#34;callback-promises-async-await&#34;&gt;&amp;ldquo;Callback&amp;rdquo;, &amp;ldquo;Promises&amp;rdquo;, &amp;ldquo;async/await&amp;rdquo;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Async != Callback&lt;/li&gt;
&lt;li&gt;async &lt;code&gt;callback&lt;/code&gt; &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/3.1/async-callback.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;async &lt;code&gt;promise&lt;/code&gt; and &lt;code&gt;async/await&lt;/code&gt; &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/3.1/async-promise.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;event-emitter&#34;&gt;Event Emitter&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;sync events &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/3.2/sync-events.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;async events &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/3.2/async-events.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;arguments-errors-order-of-listeners&#34;&gt;Arguments, Errors, Order of Listeners&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; event&lt;/li&gt;
&lt;li&gt;handling error with &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;uncaughtException&lt;/code&gt;, register listener with &lt;code&gt;once&lt;/code&gt; method, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/3.3/errors.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;order of invoke listeners, &lt;code&gt;prependListener&lt;/code&gt;, &lt;code&gt;removeListener&lt;/code&gt;, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/3.3/order.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Task List Management &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/tree/master/3.4&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;node-for-networking&#34;&gt;Node for Networking&lt;/h1&gt;

&lt;h2 id=&#34;tcp-networking-with&#34;&gt;TCP networking with&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;net&lt;/code&gt; module, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/4.1/net.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;working-with-multiple-sockets&#34;&gt;Working with multiple sockets&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/4.2/net.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;improving-the-chat-server&#34;&gt;Improving the chat server&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;remove logging message to ourself, adding names, timestamp, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/4.3/chat.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-dns-module&#34;&gt;The DNS module&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lookup&lt;/code&gt;, &lt;code&gt;resolve&lt;/code&gt;, &lt;code&gt;reverse&lt;/code&gt; methods &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/4.4/dns.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;udp-sockets&#34;&gt;UDP sockets&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dgram&lt;/code&gt; module and creating event emitter by &lt;code&gt;dgram.createSocket(&#39;udp4&#39;)&lt;/code&gt;, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/4.5/udp.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;node-for-web&#34;&gt;Node for Web&lt;/h1&gt;

&lt;h2 id=&#34;the-basic-streaming-http-server&#34;&gt;The basic streaming HTTP server&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http.createServer&lt;/code&gt; as an event emitter, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/5.1/http.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;working-with-https&#34;&gt;Working with HTTPS&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;create key and certificate with &lt;code&gt;openssl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;working with &lt;code&gt;https&lt;/code&gt;, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/5.2/https.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;requesting-http-https-data&#34;&gt;Requesting HTTP/HTTPS data&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;5 major classes of &lt;code&gt;http&lt;/code&gt; module&lt;/li&gt;
&lt;li&gt;client &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/5.3/request.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;server &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/5.3/server.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;working-with-routes&#34;&gt;Working with Routes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;read requested url with &lt;code&gt;http.IncomingMessage&lt;/code&gt; &amp;lt;- &lt;code&gt;req.url&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;response pages with &lt;code&gt;http.ServerResponse&lt;/code&gt; &amp;lt;- &lt;code&gt;res.writeHeader()&lt;/code&gt; and &lt;code&gt;res.end()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;redirect response&lt;/li&gt;
&lt;li&gt;response with JSON&lt;/li&gt;
&lt;li&gt;&lt;code&gt;404&lt;/code&gt; response&lt;/li&gt;
&lt;li&gt;get all response in &lt;code&gt;http.STATUS_CODES&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/5.4/server.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;parsing-url-and-query-string&#34;&gt;Parsing URL and Query String&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;module &lt;code&gt;url&lt;/code&gt; with &lt;code&gt;url.parse(&#39;hrefString&#39;, ?parseQueryString)&lt;/code&gt; and &lt;code&gt;url.format()&lt;/code&gt;, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/5.5/url.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;querystring&lt;/code&gt; module, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/5.5/querystring.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;node-s-common-built-in-modules&#34;&gt;Node&amp;rsquo;s Common built-in modules&lt;/h1&gt;

&lt;h2 id=&#34;working-with-operation-system&#34;&gt;Working with operation system&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;module &lt;code&gt;os&lt;/code&gt;, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/6.1/index.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;working-with-file-system&#34;&gt;Working with File System&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Task 1: script to fix files in directory. Each file has its data duplicated. Truncate each file in half. &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/tree/master/6.2/task1&#34;&gt;solution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Task 2: scripts to generate/clean old files in a directory. Anything older than 7 days should be deleted &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/tree/master/6.2/task2&#34;&gt;solution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Task 3: watch a directory and report events which were occurred: added, removed, changed &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/tree/master/6.2/task3&#34;&gt;solution&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;console-and-utilites&#34;&gt;Console and Utilites&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;console.Console&lt;/code&gt;, &lt;code&gt;util.debuglog&lt;/code&gt;, &lt;code&gt;util.deprecate&lt;/code&gt;, &lt;code&gt;util.inherits&lt;/code&gt; and ES6 &lt;code&gt;extends&lt;/code&gt;, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/6.3/index.js&#34;&gt;examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;debugging&#34;&gt;Debugging&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;node debug script.js&lt;/code&gt;, commands: &lt;code&gt;help&lt;/code&gt;, &lt;code&gt;restart&lt;/code&gt;, &lt;code&gt;sb(line)&lt;/code&gt;, &lt;code&gt;repl&lt;/code&gt;, &lt;code&gt;watch(var)&lt;/code&gt;, &lt;code&gt;list(lines)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node --inspect-brk script.js&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;working-with-streams&#34;&gt;Working with streams&lt;/h1&gt;

&lt;h2 id=&#34;streams-all-the-thing&#34;&gt;Streams all the thing!&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The definition&lt;/li&gt;
&lt;li&gt;Distinguish to serve enormous file with buffer &lt;code&gt;fs.readFile&lt;/code&gt; and stream &lt;code&gt;fs.createReadStream&lt;/code&gt;, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/tree/master/7.1&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;steam-101&#34;&gt;Steam 101&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Types of stream&lt;/li&gt;
&lt;li&gt;All stream are instance of EventEmitter&lt;/li&gt;
&lt;li&gt;Consuming streams &lt;code&gt;readableStream.pipe(writableStream)&lt;/code&gt; / events&lt;/li&gt;
&lt;li&gt;Stream Events Table&lt;/li&gt;
&lt;li&gt;Readable stream mode: &amp;ldquo;paused/pull&amp;rdquo;, &amp;ldquo;flowing/push&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;implementing-readable-and-writable-streams&#34;&gt;Implementing Readable and Writable streams&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;writable &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/7.3/writable.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;readable &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/7.3/readable.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;duplex-and-transform-streams&#34;&gt;Duplex and Transform streams&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;duplex &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/7.4/duplex.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;transform &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/7.4/transform.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;transform with &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/7.4/zip.js&#34;&gt;gzip example&lt;/a&gt; and &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/7.4/unzip.js&#34;&gt;unzip&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;cluster-adn-child-process&#34;&gt;Cluster adn Child Process&lt;/h1&gt;

&lt;h2 id=&#34;scalling-node-js-application&#34;&gt;Scalling Node.js application&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why one process in one CPU is not enough&lt;/li&gt;
&lt;li&gt;Using multiple process is only way to scale&lt;/li&gt;
&lt;li&gt;Scalability strategies:&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Cloning&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Decomposing (associated with term microservices)&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Splitting (sharding)&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;child-processes-events-and-standard-io&#34;&gt;Child processes events and standard IO&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;4 different way to create child process: &lt;code&gt;spawn()&lt;/code&gt;, &lt;code&gt;fork()&lt;/code&gt;, &lt;code&gt;exec()&lt;/code&gt;, &lt;code&gt;execFile()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spawn()&lt;/code&gt; child process &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/8.2/spawn.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;using &lt;code&gt;spawn()&lt;/code&gt; as an stream &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/8.2/spawn-pipe.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-shell-syntax-with-exec-and-execfile&#34;&gt;The Shell syntax with &lt;code&gt;exec()&lt;/code&gt; and &lt;code&gt;execFile()&lt;/code&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;exec()&lt;/code&gt; vs &lt;code&gt;spawn()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exec()&lt;/code&gt; with options &lt;code&gt;shell, cwd, env&lt;/code&gt;, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/8.3/exec.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;detached&lt;/code&gt; option and &lt;code&gt;childProcess.unref()&lt;/code&gt; &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/8.3/detach.js&#34;&gt;example&lt;/a&gt; with &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/8.3/timer.js&#34;&gt;timer.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-fork-function&#34;&gt;The &lt;code&gt;fork()&lt;/code&gt; function&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fork()&lt;/code&gt; vs &lt;code&gt;spawn()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;communication with &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/8.4/parent.js&#34;&gt;parent&lt;/a&gt; and &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/8.4/child.js&#34;&gt;child&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;long running process with http request: &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/8.4/server.js&#34;&gt;server&lt;/a&gt; and &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/8.4/compute.js&#34;&gt;computation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-cluster-module&#34;&gt;The Cluster module&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Using as a Load Balancer&lt;/li&gt;
&lt;li&gt;Diagram with Master Process and Cloning Process&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;load-balancing-an-http-server&#34;&gt;Load-balancing an HTTP server&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;benchmark with request per seconds&lt;/li&gt;
&lt;li&gt;clustering HTTP server &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/tree/master/8.6&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;broadcasting-messages-to-each-worker&#34;&gt;Broadcasting messages to each Worker&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;mocking fetch user from DB only from Master Worker &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/tree/master/8.7&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;availability-and-zero-downtime-restart&#34;&gt;Availability and Zero-downtime restart&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/tree/master/8.7&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;shared-state-and-sticky-load-balancer&#34;&gt;Shared State and Sticky Load Balancer&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why shared states with different workers is a problem?&lt;/li&gt;
&lt;li&gt;Sticky Load Balancer as a solution&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;save-my-day&#34;&gt;Save my day&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pluralsight.com/courses/nodejs-advanced&#34;&gt;original course by Samer Buna on pluralsight&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs&#34;&gt;github repo of examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Kata: Salesman&#39;s Travel</title>
      <link>https://qetr1ck-op.github.io/blog/post/kata-salesmans-travel/</link>
      <pubDate>Sat, 29 Apr 2017 23:56:58 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/kata-salesmans-travel/</guid>
      <description>&lt;p&gt;A traveling salesman has to visit clients. He got each client&amp;rsquo;s address e.g. &amp;ldquo;432 Main Long Road St. Louisville OH 43071&amp;rdquo; as a list.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The basic zipcode format usually consists of two capital letters followed by a white space and five digits. The list of clients to visit was given as a string of all addresses, each separated from the others by a comma, e.g. :&lt;/p&gt;

&lt;p&gt;&amp;ldquo;123 Main Street St. Louisville OH 43071,432 Main Long Road St. Louisville OH 43071,786 High Street Pollocksville NY 56432&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;To ease his travel he wants to group the list by zipcode.&lt;/p&gt;

&lt;h1 id=&#34;task&#34;&gt;Task&lt;/h1&gt;

&lt;p&gt;The function travel will take two parameters r (list of all clients&amp;rsquo; addresses) and zipcode and returns a string in the following format:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;zipcode:street and town,street and town,.../house number,house number,...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The street numbers must be in the same order as the streets where they belong.&lt;/p&gt;

&lt;p&gt;If a given zipcode doesn&amp;rsquo;t exist in the list of clients&amp;rsquo; addresses return &amp;ldquo;zipcode:/&amp;rdquo;&lt;/p&gt;

&lt;h1 id=&#34;examples&#34;&gt;Examples&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;r = &amp;quot;123 Main Street St. Louisville OH 43071,432 Main Long Road St. Louisville OH 43071,786 High Street Pollocksville NY 56432&amp;quot;

travel(r, &amp;quot;OH 43071&amp;quot;) --&amp;gt; &amp;quot;OH 43071:Main Street St. Louisville,Main Long Road St. Louisville/123,432&amp;quot;

travel(r, &amp;quot;NY 56432&amp;quot;) --&amp;gt; &amp;quot;NY 56432:High Street Pollocksville/786&amp;quot;

travel(r, &amp;quot;NY 5643&amp;quot;) --&amp;gt; &amp;quot;NY 5643:/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;spec&#34;&gt;Spec&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Test.describe(&amp;quot;travel&amp;quot;,function() {
    Test.it(&amp;quot;Basic tests&amp;quot;,function() {    
        testing(travel(ad, &amp;quot;AA 45522&amp;quot;), &amp;quot;AA 45522:Paris St. Abbeville,Paris St. Abbeville/67,670&amp;quot;)
        testing(travel(ad, &amp;quot;EX 34342&amp;quot;), &amp;quot;EX 34342:Pussy Cat Rd. Chicago,Pussy Cat Rd. Chicago/10,100&amp;quot;)
        testing(travel(ad, &amp;quot;EX 34345&amp;quot;), &amp;quot;EX 34345:Pussy Cat Rd. Chicago/100&amp;quot;)
        testing(travel(ad, &amp;quot;AA 45521&amp;quot;), &amp;quot;AA 45521:Paris bd. Abbeville,Paris St. Abbeville/674,67&amp;quot;)
        testing(travel(ad, &amp;quot;AE 56215&amp;quot;), &amp;quot;AE 56215:Main Al. Bern/320&amp;quot;)
    })
})

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;code&#34;&gt;Code&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function travel(r, zipcode) {
    const re = /(\d{1,4}) (.*?) (\w{2} \d{4,5}),?/gi
    const res = {
      prefix: zipcode + &#39;:&#39;,
      addr: [],
      nb: [],
    }
    while(arr = re.exec(r)){
      const [_ , nb, addr, zip] = arr
      if(zip != zipcode)
        continue
      res.addr.push(addr)
      res.nb.push(nb)
    }
    return res.prefix + res.addr.join(&#39;,&#39;) + &#39;/&#39; + res.nb.join(&#39;,&#39;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;link&#34;&gt;Link&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.codewars.com/kata/salesmans-travel&#34;&gt;kata: salesmans-travel&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>npm scrips as your build tool</title>
      <link>https://qetr1ck-op.github.io/blog/post/npm-scrips-as-your-build-tool/</link>
      <pubDate>Sat, 29 Apr 2017 12:14:14 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/npm-scrips-as-your-build-tool/</guid>
      <description>&lt;p&gt;The course introduces the topic of using npm scripts as a build tool. It starts simple and then continue to build a small website as we introduce new topics.&lt;/p&gt;

&lt;p&gt;By the end of the course, you&amp;rsquo;ll know how to get started and what tools and techniques are needed for you to create your own set of build scripts.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;topics&#34;&gt;Topics:&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Create a basic &lt;code&gt;package.json&lt;/code&gt; file&lt;/li&gt;
&lt;li&gt;Run the basic npm scripts&lt;/li&gt;
&lt;li&gt;Create a custom npm script&lt;/li&gt;
&lt;li&gt;Run npm scripts in &lt;code&gt;series&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run npm scripts in &lt;code&gt;parallel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use a shorthand syntax for running multiple npm scripts with &lt;code&gt;npm-run-all&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run a set of similar npm scripts with a &lt;code&gt;wildcard&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;pre&lt;/code&gt; and &lt;code&gt;post&lt;/code&gt; npm script lifecycle hooks with test coverage&lt;/li&gt;
&lt;li&gt;Pass arguments to npm scripts via &lt;code&gt;--&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Pipe data from one npm script to another with build-site scripts&lt;/li&gt;
&lt;li&gt;Run npm scripts when files change with &lt;code&gt;onchange&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use package.json &lt;code&gt;variables&lt;/code&gt; in npm scripts&lt;/li&gt;
&lt;li&gt;Use custom config settings in your npm scripts&lt;/li&gt;
&lt;li&gt;Run npm scripts with git hooks using &lt;code&gt;husky&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Change the level of console output when running npm scripts&lt;/li&gt;
&lt;li&gt;Make npm scripts cross-environment friendly with &lt;code&gt;cross-env&lt;/code&gt;, &lt;code&gt;rimraf&lt;/code&gt;, &lt;code&gt;opn-cli&lt;/code&gt;, &lt;code&gt;cross-var&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;List available npm scripts and support tab completion with &lt;code&gt;ntl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add comments to your npm scripts&lt;/li&gt;
&lt;li&gt;Pull out npm scripts into another file with &lt;code&gt;p-s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Create a &lt;code&gt;bash script&lt;/code&gt; to replace a complex npm script&lt;/li&gt;
&lt;li&gt;Create a &lt;code&gt;node script&lt;/code&gt; to replace a complex npm script&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;links&#34;&gt;Links&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://egghead.io/courses/how-to-use-npm-scripts-as-your-build-tool&#34;&gt;egghead course - How to Use npm Scripts as Your Build Tool&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Front End Handbook 2017</title>
      <link>https://qetr1ck-op.github.io/blog/post/front-end-handbook-2017/</link>
      <pubDate>Sun, 23 Apr 2017 19:11:25 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/front-end-handbook-2017/</guid>
      <description>&lt;p&gt;This is a guide that anyone could use to learn about the practice of front-end development. It broadly outlines and discusses the practice of front-end engineering: how to learn it and what tools are used when practicing it in 2017&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The handbook is divided into three parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Part I. The Front-End Practice

&lt;ul&gt;
&lt;li&gt;Part one broadly describes the practice of front-end engineering.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Part II: Learning Front-End Development

&lt;ul&gt;
&lt;li&gt;Part two identifies self-directed and direct resources for learning to become a front-end developer.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Part III: Front-End Development Tools

&lt;ul&gt;
&lt;li&gt;Part three briefly explains and identifies tools of the trade.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;link&#34;&gt;Link&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://frontendmasters.com/books/front-end-handbook/2017/&#34;&gt;read online&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Building a JavaScript development environment</title>
      <link>https://qetr1ck-op.github.io/blog/post/building-a-javaScript-development-environment/</link>
      <pubDate>Sun, 02 Apr 2017 14:31:50 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/building-a-javaScript-development-environment/</guid>
      <description>&lt;p&gt;Starting a new JavaScript project from scratch is overwhelming. This course provides a playbook outlining the key decisions you need to make. Build a robust development environment that handles bundling, linting, transpiling, testing, and much more.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;description&#34;&gt;Description&lt;/h1&gt;

&lt;p&gt;Building a JavaScript application from scratch today is overwhelming. You have to make decisions about package management, bundling, linting, transpiling, automated testing, and much more. There are literally over 40 important decisions to consider. This course is a playbook of potential options that provides a clear path through the key decisions. Along the way, we&amp;rsquo;ll build a robust automated development environment from the ground up using ES6. You’ll learn how to set up a reusable development environment that provides a powerful foundation for future projects, that’s tailored just for your team’s needs.&lt;/p&gt;

&lt;h1 id=&#34;link&#34;&gt;Link&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.pluralsight.com/courses/javascript-development-environment&#34;&gt;course on pluralsight&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RESTful Web Services with Node.js and Express</title>
      <link>https://qetr1ck-op.github.io/blog/post/RESTful-Web-Services-with-Node-js-and-Express/</link>
      <pubDate>Sun, 18 Dec 2016 12:01:04 +0000</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/RESTful-Web-Services-with-Node-js-and-Express/</guid>
      <description>&lt;p&gt;Node.js is a simple and powerful tool for backend development. When combined with express, you can create lightweight, fast, scalable APIs quickly and simply.
&lt;/p&gt;

&lt;h1 id=&#34;what-is-rest-anyway&#34;&gt;What is REST anyway?&lt;/h1&gt;

&lt;p&gt;The term &lt;strong&gt;RE&lt;/strong&gt;presentational &lt;strong&gt;S&lt;/strong&gt;tate &lt;strong&gt;T&lt;/strong&gt;ransfer came from a dissertation written by Roy Fielding back in 2000.
He described a series of constraints that should be in place whenever two systems talk to each other.&lt;/p&gt;

&lt;p&gt;So ultimately REST is just a series of rules in place for your server, so everyone who uses your service understand
what it does and how it works.&lt;/p&gt;

&lt;h1 id=&#34;the-uniform-interface&#34;&gt;The Uniform interface&lt;/h1&gt;

&lt;p&gt;Whenever you&amp;rsquo;re dealing with RESTful service you&amp;rsquo;ll be dealing with a resource or resources and all that really means
is you&amp;rsquo;re dealing with with &lt;strong&gt;nouns&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Uniform resource are built around things, not actions.&lt;/p&gt;

&lt;p&gt;For example dealing with books as a resource, the url be &lt;code&gt;http://domain/books&lt;/code&gt;. With authors it would be &lt;code&gt;/authors&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The another part of uniform interface are HTTP &lt;strong&gt;verbs&lt;/strong&gt; that we use in our request will dictate the type of activity
we&amp;rsquo;re trying to do on the resource:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GET&lt;/code&gt; will simply request data (&lt;code&gt;/books&lt;/code&gt; get all or &lt;code&gt;/books/:id&lt;/code&gt; a unique book)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST&lt;/code&gt; uses to add data (&lt;code&gt;/books&lt;/code&gt; add new book)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DELETE&lt;/code&gt; will remove an entity (&lt;code&gt;books/:id&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PUT&lt;/code&gt; is used for update or replace a resource&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PATCH&lt;/code&gt; updates piece of that resource&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The last part of interface is HATEOS (Hypermedia as the Engine of Application State). Basically all that means is
that in each request will be a set of hyperlinks that you can use to navigate the API. In example, what type of
actions you can do on a particular resource.&lt;/p&gt;

&lt;h1 id=&#34;the-project&#34;&gt;The project&lt;/h1&gt;

&lt;p&gt;The project walk through how to stand up a lightweight Express server serving truly RESTful services using &lt;code&gt;Node.js&lt;/code&gt;, &lt;code&gt;Mongoose&lt;/code&gt;, and &lt;code&gt;MongoDB&lt;/code&gt;.
There are implemented all of the RESTful verbs to get, add, and update data with working through unit and e2e-integration tests for our services.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/qetr1ck-op/RESTful-Web-Services-with-Node.js-and-Express&#34;&gt;Link on GitHub&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Save my day:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://app.pluralsight.com/library/courses/node-js-express-rest-web-services/description&#34;&gt;RESTful Web Services with Node.js and Express&lt;/a&gt; by Jonathan Mills on pluralsight&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Book: &#39;Node.js design pattern&#39;</title>
      <link>https://qetr1ck-op.github.io/blog/post/Node-js-design-pattern-book-review/</link>
      <pubDate>Thu, 06 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/Node-js-design-pattern-book-review/</guid>
      <description>&lt;p&gt;&amp;ldquo;How could I organize my code?&amp;rdquo;, &amp;ldquo;What is the best way to design this?&amp;rdquo;, &amp;ldquo;How can I make my application more modular?&amp;rdquo;, &amp;ldquo;How do I handle a set of asynchronous call effectively?&amp;rdquo;, &amp;ldquo;How can I make sure that my application will not collapse while it grows?&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;If you have such questions without answers, that book is definitely for you!&lt;/p&gt;

&lt;p&gt;The aim of this book is to guide you through this emerging world of patterns, techniques and practices, showing proven solution to the common problem.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/Node-js-Design-Patterns-Mario-Casciaro/dp/1783287314&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;chapter-1-welcome-to-the-node-js-platform&#34;&gt;Chapter 1: Welcome to the Node.js platform&lt;/h1&gt;

&lt;h2 id=&#34;the-node-js-philosophy&#34;&gt;The Node.js philosophy&lt;/h2&gt;

&lt;p&gt;Some of these principles arise from the technology itself, some of them are enabled by its ecosystem, some are just trends in community, some directly comes from its creator, another are influenced by the Unix culture.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Small core&lt;/li&gt;
&lt;li&gt;Small modules&lt;/li&gt;
&lt;li&gt;Small surface area&lt;/li&gt;
&lt;li&gt;Simplicity and pragmatism&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;i-o-is-slow&#34;&gt;I/O is slow&lt;/h2&gt;

&lt;p&gt;I/O is definitely the slowest among the fundamental operations of a computer. Accessing to RAM is in the order of nanoseconds, while accessing data on disk the network is in order of milliseconds. For the bandwidth is the same story. RAM has a transfer rate consistently in the order of GB/s, while disk and network varies from MB/s to, optimistically, GB/s.&lt;/p&gt;

&lt;p&gt;On the top of that, we also have to consider the human factor. Often input of an application comes from a real person, so the speed or frequency of I/O doesn&amp;rsquo;t only depend on technical aspects.&lt;/p&gt;

&lt;h3 id=&#34;blocking-i-o&#34;&gt;Blocking I/O&lt;/h3&gt;

&lt;p&gt;In traditional blocking I/O programming the function call corresponding to an I/O request will block the execution of the thread until the operation completes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// block the thread until the data is available
data = socket.read()
// data is available
print(data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s trivial to notice how web-server which is busing blocking I/O will not be able to handle multiple connection in the same thread. Each operation will block the processing of any other connection:&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/blocking-input-output.png %}&lt;/p&gt;

&lt;p&gt;The preceding image emphasis on the amount of time each thread is idle, waiting for new data to be received from associated connection. Also we need to consider how much time of I/O can possibly block a request, for example, while interacting with database or with filesystem.&lt;/p&gt;

&lt;h3 id=&#34;non-blocking-i-o-with-busy-waiting&#34;&gt;Non-blocking I/O with &amp;ldquo;busy-waiting&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;In this operation mode, the system call always returns immediately without waiting for data to be read or written. If no result are available at the moment of call, the function will simply return a predefined constant, indicating that there is no data available to return at the moment.&lt;/p&gt;

&lt;p&gt;The most basic pattern for accessing this kind of non-blocking I/O is &lt;code&gt;busy-waiting&lt;/code&gt; - it actively poll the resource within a loop until some actual data is returned.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;resource = [socketA, socketB, pipeA]

while(!resources.isEmpty()) {
  foreach resource in resources {
    // try to read
    let data = resource.read()

    if (data === NO_DATA_AVAILABLE) {
      // there is no data to read at the moment
      continue
    }
    if (data === RESOUCE_CLOSED) {
      // there was closed, remove it from list
      resources.remove(resource)
    } else {
      // data was received, proceed it
      consumeData(data)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this technique it&amp;rsquo;s already possible to achieve handling different resources in the same thread, but still it isn&amp;rsquo;t efficient.&lt;/p&gt;

&lt;h3 id=&#34;event-demultiplexing&#34;&gt;Event demultiplexing&lt;/h3&gt;

&lt;p&gt;Luckily, most modern operation systems provide a mechanism to handle concurrent, non-blocking resources in efficient way. It&amp;rsquo;s a &lt;code&gt;synchronous event demultiplexing&lt;/code&gt; or &lt;code&gt;event notification interface&lt;/code&gt; - it&amp;rsquo;s collect and queues I/O events that come from set of watched resources, and block until new events are available for process.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;watchedList.add(socketA, FOR_READ)
watchedList.add(socketB, FOR_READ)
watchedList.add(pipeA, FOR_READ) // [1]

while(events = demultiplexer.watch(watchedList)) { // [2]
  // event loop
  foreach (event in events) { // [3]
    // this read operation won&#39;t never block
    // and we will always return data
    data = event.resource.read()
    if (data === RESOUCE_CLOSED) {
      // remove from watched list
      demultiplexer.unwatch(event.resource)
    } else {
      // data was received, proceed it
      consumeData(data)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;The resources was added to a data structure, associated with specific operation&lt;/li&gt;
&lt;li&gt;The event notifier is set up with the group of resources to be watched. This call is synchronous and blocks until any of watched resource is ready for &lt;code&gt;read&lt;/code&gt; operation. When the resource is ready for an operation the &lt;code&gt;event demultiplexer&lt;/code&gt; returns from the call new set of events.&lt;/li&gt;
&lt;li&gt;Each event is proceed. At this point, the resource associated with each event is guaranteed to be ready to processing and not to block during the operation. When all events are processed, the flow will be blocked again on the &lt;code&gt;event demultiplexer&lt;/code&gt; until new events are again available to be proceed.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;This is called the &lt;code&gt;event loop&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It&amp;rsquo;s interesting that with this pattern, we can now handle several I/O operation inside a single thread. How web-server will handle multiple requests using synchronous &lt;code&gt;event demultiplexer&lt;/code&gt; with single thread:&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/webserver-event-demultiplexer.png %}&lt;/p&gt;

&lt;h2 id=&#34;the-reactor-pattern&#34;&gt;The reactor pattern&lt;/h2&gt;

&lt;p&gt;The main idea behind it is to have a handler (which in Node.js is represented by &lt;code&gt;callback&lt;/code&gt; function) associated with each I/O operation, which will be invoked as soon as an event is produces and processed by &lt;code&gt;event loop&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/reactor-pattern.png %}&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s happen when application use the &lt;code&gt;reactor patter&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The application generates a new I/O operation by submitting a request to &lt;code&gt;event demultiplexer&lt;/code&gt;. Also application specified a handler, which will be invoked when the operation is completes. Submitting a new request is non-blocking call and it immediately returns control to the application&lt;/li&gt;
&lt;li&gt;When set of I/O operation completes, the &lt;code&gt;event demultiplexer&lt;/code&gt; pushes the new events into the &lt;code&gt;event loop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;At this point, &lt;code&gt;event loop&lt;/code&gt; iterates over the items of the &lt;code&gt;event queue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;For each event, the associated handler is invoked&lt;/li&gt;
&lt;li&gt;

&lt;ul&gt;
&lt;li&gt;(a) The handler which is a part of application code, will give control to &lt;code&gt;event loop&lt;/code&gt; when it&amp;rsquo;s execution completes.&lt;/li&gt;
&lt;li&gt;(b) However, new asynchronous operation might be requested during the execution of handler, causing new operation to registered in the &lt;code&gt;event demultiplexer&lt;/code&gt;, before control is given back to &lt;code&gt;event loop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;When all items are processed in &lt;code&gt;event queue&lt;/code&gt;, the loop will blocked again on &lt;code&gt;event demultiplexer&lt;/code&gt; which will trigger another cycle of when a new events are available&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A Node.js application will exit automatically when there are no more pending operation in &lt;code&gt;event demultiplexer&lt;/code&gt; and no more events to be processed in &lt;code&gt;event queue&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Pattern Reactor&lt;/code&gt; handles I/O by blocking until new events are available from a set of observable resources and then reacts by dispatching each event with associated handler.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-non-blocking-i-o-engine-of-node-js-libuv&#34;&gt;The non-blocking I/O engine of Node.js-libuv&lt;/h2&gt;

&lt;p&gt;Each operation system has its own interface for the &lt;code&gt;event demultiplexer&lt;/code&gt;. Besides that, each I/O operation can behave quite differently depending on type of resource, even within the same OS. All this inconsistencies required a higher abstraction for &lt;code&gt;event demultiplexer&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is exactly why Node.js core created a C library called &lt;code&gt;libuv&lt;/code&gt; with objective to make Node.js compatible with all the major platform and normalize the non-blocking behavior of the different types of resource.&lt;/p&gt;

&lt;h2 id=&#34;the-building-blocks-of-node-js-platform&#34;&gt;The building blocks of Node.js platform&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;reactor pattern&lt;/code&gt; and &lt;code&gt;libuv&lt;/code&gt; are the basic building blocks but we need the following three other components to build the full platform:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a set of bindings responsible for wrapping and expose &lt;code&gt;libuv&lt;/code&gt; and other low-level functionality to Javascript&lt;/li&gt;
&lt;li&gt;&lt;code&gt;V8&lt;/code&gt; the Javascript engine, this one of the reason why Node.js is so fast and efficient&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;node-core&lt;/code&gt; that implements the high-level Node.js API&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;{% image fancybox center images/building-nodejs-blocks.png %}&lt;/p&gt;

&lt;h1 id=&#34;chapter-2-node-js-essential-patterns&#34;&gt;Chapter 2: Node.js essential patterns&lt;/h1&gt;

&lt;p&gt;In this chapter, we&amp;rsquo;ll use two of the most important asynchronous patterns: &lt;code&gt;callback&lt;/code&gt; and &lt;code&gt;event-emitter&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-callback-pattern&#34;&gt;The callback pattern&lt;/h2&gt;

&lt;p&gt;Callbacks are materialization of the handlers of the &lt;code&gt;reactor pattern&lt;/code&gt;. Callback is a function that is invoked to propagate the result of an operation and this is exactly what we need when we dealing with asynchronous operation. Another ideal construct for implementing callbacks is &lt;code&gt;closure&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-continue-passing-style&#34;&gt;The continue-passing style&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;In Javascript, a callback is a function that is passed as an argument to another function and is invoked with the result when operation is complete.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Meanwhile,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;in function programming, this way of propagating the result is called &lt;code&gt;continuation-passing style&lt;/code&gt; (CPS)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To clarify the concept lets see a &lt;code&gt;direct style&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function add(a, b) {
  return a + b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The equivalent &lt;code&gt;continue-passing style&lt;/code&gt; would be as follow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function add(a, b, callback) {
  callback(a + b);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;code&gt;add()&lt;/code&gt; is a synchronous &lt;code&gt;CPS&lt;/code&gt; function the result will be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(&#39;before&#39;);
add(1, 2, result =&amp;gt; console.log(`Result ${result}`));
console.log(&#39;after&#39;);

// before
// Result 3
// after
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;asynchronous-continue-passing-style&#34;&gt;Asynchronous continue-passing style&lt;/h3&gt;

&lt;p&gt;Lets consider a case where the &lt;code&gt;add()&lt;/code&gt; function is asynchronous:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function addAsync(a, b, callback) {
  setTimeout(callback(a + b));
}

console.log(&#39;before&#39;);
addAsync(1, 2, result =&amp;gt; console.log(`Result ${result}`));
console.log(&#39;after&#39;);

// before
// after
// Result 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;code&gt;setTimeout()&lt;/code&gt; triggers an asynchronous operation, it won&amp;rsquo;t wait for the callback to be executed, but instead, it returns immediately, giving control back to &lt;code&gt;addAsync()&lt;/code&gt; and then back to its caller. This is crucial and following image shows how it works:&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/async-cps-in-action.png %}&lt;/p&gt;

&lt;p&gt;The execution will start from the &lt;code&gt;event loop&lt;/code&gt; so it will have a fresh stack. Thanks to &lt;code&gt;closure&lt;/code&gt; it&amp;rsquo;s trivial to maintain the context of the caller in asynchronous function.&lt;/p&gt;

&lt;h3 id=&#34;synchronous-or-asynchronous&#34;&gt;Synchronous or asynchronous?&lt;/h3&gt;

&lt;p&gt;The following is an analysis of these two paradigms and their pitfalls.&lt;/p&gt;

&lt;h4 id=&#34;an-unpredictable-function&#34;&gt;An unpredictable function&lt;/h4&gt;

&lt;p&gt;One of the most dangerous situation is to have API that behaves synchronously under certain conditions and asynchronous under others:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fs = require(&#39;fs&#39;);
const cache = {};

function inconsistentRead(filename, callback) {
  if (cache[filename]) {
    // invoked synchronously
    callback(cache[filename]);
  } else {
    // async call
    fs.readFile(filename, &#39;utf8&#39;, (err, data) =&amp;gt; {
      cache[filename] = data;
      callback(data);
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;unleashing-zalgo&#34;&gt;Unleashing Zalgo&lt;/h4&gt;

&lt;p&gt;Now lets see how to use an unpredictable function, such as to easily break an application:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function createFileReader(filename) {
  const listeners = [];

  incosistentRead(filename, value =&amp;gt; {
    listeners.forEach(listener =&amp;gt; listener(value));
  })

  return {
    onDateReady: listener =&amp;gt; listeners.push(listener)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the preceding function is invoked, it creates a new object that acts as notifier, allowing us to set multiple listeners for a file read operation. All listeners will be invoked at once when the read operation completes and the data is available:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const reader1 = createFileReader(&#39;data.txt&#39;);

reader1.onDateReady(data =&amp;gt; {
  console.log(`First data call ready: ${data}`);

  // same time letter we try to read the same file again
  const reader2 = createFileReader(&#39;data.txt&#39;);

  reader2.onDateReady(data =&amp;gt; {
    console.log(`Second data call ready: ${data}`);
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result output is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;First data call ready: foo bar here!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see the callback of the second operation is never invoked. Lets see why:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;During the creation of &lt;code&gt;reader1&lt;/code&gt;, our &lt;code&gt;inconsistentRead()&lt;/code&gt; function behaves asynchronously, because there isn&amp;rsquo;t cached result. Therefore, we have all time in the world to register our listener, as it will invoked later in another cycle of &lt;code&gt;event loop&lt;/code&gt;, when the read operation is complete.&lt;/li&gt;
&lt;li&gt;Then the &lt;code&gt;reader2&lt;/code&gt; is created when requested file is in the cache. In this case the inner call of &lt;code&gt;inconsistentRead()&lt;/code&gt; will be synchronous. So its call back will be invoked immediately, which mean that listener of &lt;code&gt;reader2&lt;/code&gt; will be invoked synchronously as well. However, we registering the listeners after creation of &lt;code&gt;reader2&lt;/code&gt;, so they will never be invoked!&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;using-synchronous-apis&#34;&gt;Using synchronous APIs&lt;/h3&gt;

&lt;p&gt;One suitable fix for our &lt;code&gt;inconsistentRead()&lt;/code&gt; function is to make it totally synchronous:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fs = require(&#39;fs&#39;);
const cache = {};

function consistentRead(filename) {
  if (cache[filename]) {
    return cache[filename];
  }
  cache[filename] = fs.readFileSync(filename, &#39;utf8&#39;);
  return cache[filename];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is no reason for a function to have a continue-passing style it&amp;rsquo;s synchronous. In fact, it&amp;rsquo;s always a best practice to implement synchronous API using a &lt;code&gt;direct style&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pattern:
Prefer &lt;code&gt;direct style&lt;/code&gt; for purely synchronous function&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Bear in mind, that changing an API from &lt;code&gt;CPS&lt;/code&gt; to a &lt;code&gt;direct style&lt;/code&gt; (from asynchronous to synchronous or vice versa) require a change of style of all code using:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function createFileReader(filename) {
  const listeners = [];
  const fileData = consistentRead(filename)

  return {
    onDateReady: listener =&amp;gt; {
      listeners.push(listener);
      listeners.forEach(listener =&amp;gt; listener(fileData));
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;using-asynchronous-operation-with-deferred-execution&#34;&gt;Using asynchronous operation with deferred execution&lt;/h3&gt;

&lt;p&gt;The trick here is to schedule the synchronous callback invocation to be executed &amp;ldquo;in the future&amp;rdquo;, instead of being run immediately in the same event loop cycle. In Node.js this is possible using &lt;code&gt;process.nextTick()&lt;/code&gt;, which defers the execution of a function until next the event loop cycle. This function is a very simple, it takes a callback and pushes it to the top of event queue, in front of any pending I/O event, and returns control immediately. So callback will run be invoked as soon as the event loop runs again.&lt;/p&gt;

&lt;p&gt;Apply this technique to fix &lt;code&gt;inconsistentRead()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fs = require(&#39;fs&#39;);
const cache = {};

function inconsistentRead(filename, callback) {
  if (cache[filename]) {
    // now invoked asynchronously
    process.nextTick(() =&amp;gt; callback(cache[filename]));
  } else {
    // async call
    fs.readFile(filename, &#39;utf8&#39;, (err, data) =&amp;gt; {
      cache[filename] = data;
      callback(data);
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, our function is guaranteed to invoke its callback asynchronous, under any circumstances.&lt;/p&gt;

&lt;p&gt;Another API for deferring the execution is &lt;code&gt;setImmediate()&lt;/code&gt;. While their purposes are very similar, their semantics are quite different. Callback deferred with &lt;code&gt;process.nextTick()&lt;/code&gt; run before any other I/O event fired, while with &lt;code&gt;setImmediate()&lt;/code&gt;, the execution is queued behind any I/O event that is already in the queue. Since &lt;code&gt;process.nextTick()&lt;/code&gt; runs before any already scheduled I/O, it might cause I/O starvation under certain circumstances, for example, a recursive invocation, this can never happen with &lt;code&gt;setImmediate()&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pattern:
We guarantee that a callback is invoked asynchronously be deferring it execution using &lt;code&gt;process.nextTick()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;node-js-callback-convention&#34;&gt;Node.js callback convention&lt;/h3&gt;

&lt;p&gt;CPS APIs and callbacks follows a set of specific convention.&lt;/p&gt;

&lt;h4 id=&#34;callback-come-last&#34;&gt;Callback come last&lt;/h4&gt;

&lt;p&gt;In all core Node.js methods, the standard convention is that when a function accept callback as input, this has to be passed as last parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;fs.readFile(filename[, options], callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;error-comes-first&#34;&gt;Error comes first&lt;/h4&gt;

&lt;p&gt;In Node.js, any errors produced by a CPS function is always passed as first argument of the callback, and any actual result is passed starting from the second argument. It the operation is succeeds without errors, the first error will be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;fs.readFile(&#39;foo.txt&#39;, &#39;utf8&#39;, (err, data) =&amp;gt; {
  if (err) {
    handleError(err);
  } else {
    handleData(data);
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;propagation-errors&#34;&gt;Propagation errors&lt;/h4&gt;

&lt;p&gt;Propagation errors in synchronous, direct function is done with well-known &lt;code&gt;throw&lt;/code&gt; statement.&lt;/p&gt;

&lt;p&gt;In CPS style however, proper propagation is done by passing the error to the next callback in the chain:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function readJson(filename, callback) {
  fs.readFile(filename, &#39;utf8&#39;, (err, data) =&amp;gt; {
    let parsed;
    if (err) {
      // propagate the error and exit
      return callback(err);
    }

    try {
      parsed = JSON.parse(data);
    } catch(err) {
      // catch parsing error
      return callback(err);
    }

    // no error propagate just data
    callback(null, parsed);
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-module-system-and-its-pattern&#34;&gt;The module system and its pattern&lt;/h2&gt;

&lt;p&gt;Modules are bricks for structuring non-trivial application, but also the main mechanism to enforce hiding information by keeping private all the function and variable that are not explicitly marked to be exported.&lt;/p&gt;

&lt;h3 id=&#34;the-revealing-module-pattern&#34;&gt;The revealing module pattern&lt;/h3&gt;

&lt;p&gt;Once of the major problem in Javascript is an absence of namespacing. A popular technique to solve this issue is called &lt;code&gt;the revealing module pattern&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const module = (() =&amp;gt; {
  const privateFoo = () =&amp;gt; {};
  const privateBar = [];

  const exported = {
    publicFoo: &#39;dataFoo&#39;,
    publicBar: &#39;dataBar&#39;,
  }

  return export
}())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have a private scope and exporting only the parts that are meant to be public. As we&amp;rsquo;ll see at the moment, the idea behind this pattern is used as a base for a Node.js module system.&lt;/p&gt;

&lt;h3 id=&#34;node-js-modules-explained&#34;&gt;Node.js modules explained&lt;/h3&gt;

&lt;p&gt;CommonJS is a group with the aim to standardize the Javascript ecosystem, and one of their most popular proposal is &lt;code&gt;CommonJS module system&lt;/code&gt;. Node.js built its module system on the top of this specification, with the addition of some custom extensions.&lt;/p&gt;

&lt;h4 id=&#34;a-homemade-module-loader&#34;&gt;A homemade module loader&lt;/h4&gt;

&lt;p&gt;To explain how Node.js modules work let&amp;rsquo;s built a similar system from scratch. The code mimics a subset of functionality of original &lt;code&gt;require&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function loadModule(filename, module, require) {
  const wrappedSrc = `function(module, module, require) {
    ${fs.readFileSync(filename, &#39;utf8&#39;)}
  }(module, module.exports, require)`;

  eval(wrappedSrc);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bear in mind, that this code is only for example, feature such as &lt;code&gt;eval()&lt;/code&gt; or &lt;code&gt;vm&lt;/code&gt; &lt;a href=&#34;https://nodejs.org/api/vm.html&#34;&gt;module&lt;/a&gt; can be easily used in a wrong way or with a wrong input to inject attack. They should be used always with extreme care.&lt;/p&gt;

&lt;p&gt;Now implementation of our &lt;code&gt;require()&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function require(moduleName) {
  console.log(`Require invoked for module: ${moduleName}`);
  const id = require.resolve(moduleName); // [1]

  if (require.cache[id]) { // [2]
    return require.cache[id].exports;
  }

  // module metadata
  const module = { // [3]
    exports: {},
    id
  };
  // update the cache
  require.cache[id] = module; // [4]

  // load the module
  loadModule(id, module, require); // [5]

  // return exported variables
  return module.exports; // [6]
}

require.cache = {};
require.resolve = function(moduleName) {
  // resolve a full module id from the moduleName
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What our homemade module system does is explain as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Module name is accepted as input, and the very first thing that we do is resolve the full path of module, and receive module &lt;code&gt;id&lt;/code&gt;. It&amp;rsquo;s implementing by special resolving algorithm of &lt;code&gt;require.resolve()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If the module has already been loaded it should be available in the cache.&lt;/li&gt;
&lt;li&gt;If the module hasn&amp;rsquo;t loaded yet, we set up environment for the first load. The property &lt;code&gt;module.exports&lt;/code&gt; will be used to export public API.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;module&lt;/code&gt; object is cached.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;loadModule()&lt;/code&gt; code reads from its file, and the code is evaluated. We provide the module with &lt;code&gt;module&lt;/code&gt; object that we just created, and a reference to &lt;code&gt;require()&lt;/code&gt; function. The module exports its public API by manipulation or replacing the &lt;code&gt;module.exports&lt;/code&gt; object.&lt;/li&gt;
&lt;li&gt;Finally the content of &lt;code&gt;module.exports&lt;/code&gt; is returned from caller.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;defining-a-modules&#34;&gt;Defining a modules&lt;/h4&gt;

&lt;p&gt;By looking how us &lt;code&gt;require()&lt;/code&gt; works be are able to define a module:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// module.js
// load another module-dependency
const dependency = require(&#39;./anotherModule&#39;);

// private section
function privateFoo() {}

// the exported API
module.exports.run = function publicBar() {
  privateFoo()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The essential concept to remember that everything in the module is private unless it&amp;rsquo;s assigned to &lt;code&gt;module.exports&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;defining-globals&#34;&gt;Defining globals&lt;/h4&gt;

&lt;p&gt;It&amp;rsquo;s still possible to define a global variable, in fact, module system exposes a special variable &lt;code&gt;global&lt;/code&gt;, which can be used for this purpose&lt;/p&gt;

&lt;h4 id=&#34;module-exports-vs-exports&#34;&gt;&amp;ldquo;module.exports&amp;rdquo; VS &amp;ldquo;exports&amp;rdquo;&lt;/h4&gt;

&lt;p&gt;A common source of confusion is the difference between using &lt;code&gt;module.exports&lt;/code&gt; and &lt;code&gt;exports&lt;/code&gt; to expose the public API. The code of our custom &lt;code&gt;require&lt;/code&gt; function should again clear any doubts.&lt;/p&gt;

&lt;p&gt;The variable &lt;code&gt;exports&lt;/code&gt; is just a reference to initial value of &lt;code&gt;module.exports&lt;/code&gt;, essentially it&amp;rsquo;s an empty object before the module is loaded. This means that we can only attach new properties referencing by &lt;code&gt;exports&lt;/code&gt; variable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;exports.hello = () =&amp;gt; { console.log(&#39;Hello&#39;) };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reassigning the &lt;code&gt;exports&lt;/code&gt; variable doesn&amp;rsquo;t have any sense, because it doesn&amp;rsquo;t change content of &lt;code&gt;module.exports&lt;/code&gt;. That&amp;rsquo;s how object in Javascript works. The following code therefore is wrong:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;exports.hello = () =&amp;gt; { console.log(&#39;Hello&#39;) };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to export something other than an object literal, we can reassigning &lt;code&gt;module.exports&lt;/code&gt; as follow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module.exports = () =&amp;gt; { console.log(&#39;Hello&#39;) };
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-require-function-is-synchronous&#34;&gt;The &amp;ldquo;require&amp;rdquo; function is synchronous&lt;/h4&gt;

&lt;p&gt;We should take into account that our homemade &lt;code&gt;require&lt;/code&gt; is synchronous. In fact, it returns the module contents using simple direct style therefore no callback is required. This is true for original Node.js &lt;code&gt;require&lt;/code&gt; function too. As a consequence any assignments to &lt;code&gt;module.exports&lt;/code&gt; must be synchronous. The following code is incorrect:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;setTimeout(() =&amp;gt; {
  module.exports = () =&amp;gt; {}
}, 100);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is one of the important reasons why Node.js libraries offer synchronous APIs as alternative to asynchronous ones.&lt;/p&gt;

&lt;h4 id=&#34;the-resolving-algorithm&#34;&gt;The resolving algorithm&lt;/h4&gt;

&lt;p&gt;Node.js solver the &lt;code&gt;dependency hell&lt;/code&gt; elegantly by loading different version of module depending on where the module is loaded from. As we saw the &lt;code&gt;resolve()&lt;/code&gt; function takes a module name (&lt;code&gt;moduleName&lt;/code&gt; in our loader) as input, and it returns the full path of module. This path is used to load its code and to identify the module uniquely.&lt;/p&gt;

&lt;p&gt;The resolving algorithm can be divided into the following three major branches:
* file modules
* core modules
* package modules&lt;/p&gt;

&lt;p&gt;The resolving algorithm can be be found at &lt;a href=&#34;https://nodejs.org/api/modules.html#modules_all_together&#34;&gt;official spec&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;node_modules&lt;/code&gt; directory is where &lt;code&gt;npm&lt;/code&gt; installs the dependencies of each package. Based on the algorithm, each package can have its own private dependencies. Consider the following structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myApp
├── foo.js
└── node_modules
    ├── depA
    │   └── index.js
    ├── depB
    │   ├── bar.js
    │   └── node_modules
    │       └── depA
    │           └── index.js
    └── depC
        ├── foobar.js
        └── node_modules
            └── depA
            └── index.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Following rules of resolving algorithm, using &lt;code&gt;require(&#39;depA&#39;)&lt;/code&gt; will load a different file depending on the module that requires it:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Calling &lt;code&gt;require(&#39;depA&#39;)&lt;/code&gt; from &lt;code&gt;/myApp/foo.js&lt;/code&gt; will load &lt;code&gt;/myApp/node_modules/depA/index.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Calling &lt;code&gt;require(&#39;depA&#39;)&lt;/code&gt; from &lt;code&gt;/myApp/node_modules/depB/bar.js&lt;/code&gt; will load &lt;code&gt;/myApp/node_modules/depB/node_modules/depA/index.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Calling &lt;code&gt;require(&#39;depA&#39;)&lt;/code&gt; from &lt;code&gt;/myApp/node_modules/depC/foobar.js&lt;/code&gt; will load &lt;code&gt;/myApp/node_modules/depc/node_modules/depA/index.js&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;the-module-cache&#34;&gt;The module cache&lt;/h4&gt;

&lt;p&gt;Each module is only loaded and evaluated the first time it&amp;rsquo;s required, since any subsequent call of &lt;code&gt;require()&lt;/code&gt; will return the cached version. Again, it should be clear by looking at the code of homemade &lt;code&gt;require()&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;The module cache is exposed via the &lt;code&gt;require.cache&lt;/code&gt; reference, so it&amp;rsquo;s possible to directly access it if needed.&lt;/p&gt;

&lt;h3 id=&#34;module-definition-patterns&#34;&gt;Module definition patterns&lt;/h3&gt;

&lt;p&gt;The module system besides being a mechanism for loading dependencies, is also a tool for defining APIs. To aim is to maximize information hading and API usability, with balancing with other software quality such as &lt;code&gt;code reuse&lt;/code&gt; and &lt;code&gt;extensibility&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;named-exports&#34;&gt;Named exports&lt;/h4&gt;

&lt;p&gt;The most basic method for exposing public API is using &lt;code&gt;named exports&lt;/code&gt;, which consist to assignment all the public values to object referenced by &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;module.exports&lt;/code&gt;. Most of the Node.js core modules use this pattern.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// file logger.js
exports.info = (msg) = {
  console.log(`info: ${msg}`)
};

exports.verbose = (msg) = {
  console.log(`verbose: ${msg}`)
};

// file main.js
const logger = require(&#39;./logger&#39;);

logger.info(&#39;Info massage&#39;);
logger.verbose(&#39;Verbose massage&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;exporting-a-function&#34;&gt;Exporting a function&lt;/h4&gt;

&lt;p&gt;One of the most popular module definition pattern consists of reassigning of the whole &lt;code&gt;module.exports&lt;/code&gt; variable to the function. The main goal to provide a clear entry point for the module, making it simpler to understand and use. It also honors the principle of &lt;code&gt;small area surface&lt;/code&gt;. This way of defining modules also is known as the &lt;code&gt;substack pattern&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// file logger.js
module.exports = (msg) = {
  console.log(`info: ${msg}`)
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A possible extension for this pattern is using the exported function as namespace for other public APIs. This is a very powerful technique, because it still gives clarity of a single entry point.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// the same file logger.js
module.exports.verbose = (msg) = {
  console.log(`verbose: ${msg}`)
};

// file main.js
const logger = require(&#39;./logger&#39;);

logger(&#39;Info massage&#39;);
logger.verbose(&#39;Verbose massage&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Pattern:
Substack or Single Responsibility Principle (SRP)
Expose the main functionality of a module by exporting only one function. Use the exported function as a namespace to expose any auxiliary functionality&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;exporting-a-constructor&#34;&gt;Exporting a constructor&lt;/h4&gt;

&lt;p&gt;The difference is with this approach we allow user to create a new instance using the constructor with ability to extend its prototype and forge new classes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// file logger.js
class Logger {
  constructor(name) {
    this.name = name;
  }

  log(msg) {
    console.log(`[${this.name}] ${msg}`)
  }

  info(msg) {
    console.log(`info: ${msg}`)
  }

  verbose(msg) {
    console.log(`info: ${msg}`)
  }
}

module.exports = Logger;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A variation of this pattern consists of applying a security check against invocation that doesn&amp;rsquo;t use &lt;code&gt;new&lt;/code&gt; directive. This a little trick allows us to use our module as &lt;code&gt;factory&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function LoggerFactory(name) {
  if (!this instanceof Logger) {
    return new Logger(name)
  }
  return new Logger(name);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A much cleaner approach is offered by ES6 &lt;code&gt;new.targer&lt;/code&gt; which is available starting from Node.js v6. The syntax expose the &lt;code&gt;new.targer&lt;/code&gt; which is called &lt;code&gt;meta property&lt;/code&gt;, made available inside all the function, end evaluates to true at runtime if the function was called using the &lt;code&gt;new&lt;/code&gt; directive.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function LoggerFactory(name) {
  if (!new.target) {
    return new Logger(name);
  }
  return new Logger(name);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;exporting-an-instance&#34;&gt;Exporting an instance&lt;/h4&gt;

&lt;p&gt;We can leverage the caching mechanism of &lt;code&gt;require()&lt;/code&gt; to define stateful instance with a state created from a constructor or factory, shared across different modules:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// file logger.js
class Logger {
  constructor(name) {
    this.name = name;
    this.count = 0;
  }

  log(msg) {
    this.count++;
    console.log(`[${this.name}] ${msg}`)
  }
}

module.exports = new Logger(&#39;default&#39;);

// file main.js
const logger = require(&#39;./logger.js&#39;);
logger.log(&#39;test the singleton&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is much like a &lt;code&gt;singleton pattern&lt;/code&gt;, however it doesn&amp;rsquo;t guarantee the uniqueness of the instance across the whole application, as it happens with traditional singleton pattern. When analyzing the resolving algorithm, we have seen in fact, that a module might be installed multiple times inside the dependency tree of an application.&lt;/p&gt;

&lt;h4 id=&#34;modifying-other-modules-or-the-global-scope&#34;&gt;Modifying other modules or the global scope&lt;/h4&gt;

&lt;p&gt;A module can even export nothing. We should not forger that module can modify the global scope and the object in it, including other modules in the cache. In general it&amp;rsquo;s considering as a bad practice.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pattern:
Monkey patching is when module can modify other modules or object in global scope. It change the existing objects at runtime to change or extend their behavior or apply temporary fixes&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;How we can add a new function to another module:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// file patcher.js
require(&#39;./logger&#39;).customMessage = () =&amp;gt; console.log(&#39;this is a new functionality&#39;);

// main.js
require(&#39;./patcher&#39;);

const logger = require(&#39;./logger&#39;);
logger.customMessage();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The technique is dangerous, because it affects the state of entire app.&lt;/p&gt;

&lt;h2 id=&#34;the-observer-pattern&#34;&gt;The observer pattern&lt;/h2&gt;

&lt;p&gt;Together with the &lt;code&gt;reactor&lt;/code&gt;, &lt;code&gt;callbacks&lt;/code&gt; and &lt;code&gt;modules&lt;/code&gt;, the &lt;code&gt;observer pattern&lt;/code&gt; is one of the pillars of the platform and is used by mane Node.js core and user-land modules.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pattern Observer:
Defines an object (subject), which can notify a set of observers (listeners) when change is occur.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The main difference from the callback pattern is that the &lt;code&gt;subject&lt;/code&gt; can notify multiple observers, while a traditional &lt;code&gt;CPS&lt;/code&gt; will propagate its result to only one listener, the callback.&lt;/p&gt;

&lt;h3 id=&#34;the-eventemitter-class&#34;&gt;The EventEmitter class&lt;/h3&gt;

&lt;p&gt;The observer pattern built into core and it&amp;rsquo;s available through the &lt;code&gt;EventEmitter&lt;/code&gt; class. It allows to register one or multiple function as &lt;code&gt;listeners&lt;/code&gt;, which will be notified when a particular event type is fired. The following explains the concept:&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/event-emitter.png %}&lt;/p&gt;

&lt;p&gt;How to require &lt;code&gt;EventEmitter&lt;/code&gt; from core &lt;code&gt;events&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const EventEmitter = require(&#39;events&#39;);
const eeInstance = new EventEmitter;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The API is in &lt;a href=&#34;https://nodejs.org/api/events.html#events_class_eventemitter&#34;&gt;official Node.js specification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We can already see that there is a big difference between a listener and a traditional Node.js callback, in particular, the first argument isn&amp;rsquo;t an error, but any data which is passed to &lt;code&gt;emit()&lt;/code&gt; at the moment of invocation.&lt;/p&gt;

&lt;h3 id=&#34;creating-and-using-eventemitter&#34;&gt;Creating and using EventEmitter&lt;/h3&gt;

&lt;p&gt;The following code shows a function that uses &lt;code&gt;EventEmitter&lt;/code&gt; to notify its subscribers in real time when a particular pattern is found in a list of files:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const EventEmitter = require(&#39;events&#39;);
const fs = require(&#39;fs&#39;);

function findPattern(files, regexp) {
  const emitter = new EventEmitter;

  files.forEach(file =&amp;gt; {
    fs.readFile(file, &#39;utf8&#39;, (err, content) =&amp;gt; {
      let match;

      if (err) {
        emitter.emit(&#39;error&#39;, err);
      }

      emitter.emit(&#39;fileread&#39;, file); 

      if (match = content.match(regexp)) {
        match.forEach(elem =&amp;gt; emitter.emit(&#39;found&#39;, file, elem))        
      }
    })
  })

  return emitter;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets see how &lt;code&gt;findPattern&lt;/code&gt; can be used:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;findPattern(
  [&#39;data1.txt&#39;, &#39;data2.txt&#39;],
  /foo \w+/g
)
  .on(&#39;fileread&#39;, file =&amp;gt; console.log(`${file} was read`))
  .on(&#39;found&#39;, (file, match) =&amp;gt; console.log(`matched ${match} in file ${file}`))
  .on(&#39;error&#39;, err =&amp;gt; console.log(`Error: ${err}`))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;extends-from-eventemitter-class&#34;&gt;Extends from EventEmitter class&lt;/h3&gt;

&lt;p&gt;To demonstrate the pattern lets implement the functionality of the &lt;code&gt;findPattern()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const EventEmitter = require(&#39;events&#39;);
const fs = require(&#39;fs&#39;);

class FindPattern extends EventEmitter {
  constructor(regexp) {
    super();
    this.regexp = regexp;
    this.files = [];
  }

  addFile(file) {
    this.files.push(file);

    return this;
  }

  find() {
    this.files.forEach(file =&amp;gt; {
      fs.readFile(file, &#39;utf8&#39;, (err, content) =&amp;gt; {
        let match;

        if (err) {
          this.emit(&#39;error&#39;, err);
        }

        this.emit(&#39;fileread&#39;, content); 

        if (match = content.match(this.regexp)) {
          match.forEach(elem =&amp;gt; this.emit(&#39;found&#39;, file, elem); )        
        }
      })
    })
    return this;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;FindPattern&lt;/code&gt; prototype extends &lt;code&gt;EventEmitter&lt;/code&gt;. In this way it becomes a fully-fledged observable class. The usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const findPatternObj = new FindPattern(/hello \w+/g);

findPatternObj
  .addFile(&#39;data1.txt&#39;)
  .addFile(&#39;data2.txt&#39;)
  .on(&#39;fileread&#39;, file =&amp;gt; console.log(`${file} was read`))
  .on(&#39;found&#39;, (file, match) =&amp;gt; console.log(`matched ${match} in file ${file}`))
  .on(&#39;error&#39;, err =&amp;gt; console.log(`Error: ${err}`))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a pretty common pattern in the Node.js ecosystem, for example, the &lt;code&gt;Server&lt;/code&gt; object of the core HTTP module defines methods such as &lt;code&gt;listen()&lt;/code&gt;, &lt;code&gt;close()&lt;/code&gt;, &lt;code&gt;setTimeout()&lt;/code&gt; and internally it inherits from the &lt;code&gt;EventEmitter&lt;/code&gt; function. It allows to produce events such as &lt;code&gt;request&lt;/code&gt; when a new connection is received, or &lt;code&gt;connection&lt;/code&gt; when a new connection is established, or &lt;code&gt;close&lt;/code&gt; when server is shut down.&lt;/p&gt;

&lt;h3 id=&#34;combining-callbacks-with-eventemitter&#34;&gt;Combining callbacks with EventEmitter&lt;/h3&gt;

&lt;p&gt;There are also circumstances where &lt;code&gt;EventEmitter&lt;/code&gt; can be combining with a &lt;code&gt;callback&lt;/code&gt;. One example of this pattern is offered by the &lt;code&gt;node-glob&lt;/code&gt; module, which performs a glob-style searching. The function &lt;code&gt;glob(pattern, [options], callback)&lt;/code&gt; takes a &lt;code&gt;callback&lt;/code&gt; that is invoked with the list of all files which are matched by the providing pattern. At the same time it returns &lt;code&gt;EventEmitter&lt;/code&gt; that provides an interface to report over the state of the process:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const glob = require(&#39;glob&#39;);

glob(&#39;*.txt&#39;, (err, files) =&amp;gt; console.log(`Founded files: ${JSON.stringify(files)}`))
  .on(&#39;match&#39;, match =&amp;gt; console.log(`Matched files: ${match}`))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;chapter-3-asynchronous-control-flow-patterns-with-callbacks&#34;&gt;Chapter 3: Asynchronous control flow patterns with callbacks&lt;/h1&gt;

&lt;p&gt;One of the common mistake is to fail into the trap of the callback hell and see how the code is growing horizontally rather than vertically, with the nesting which makes even simple routine hard to read and maintain.&lt;/p&gt;

&lt;p&gt;In this chapter we we&amp;rsquo;ll see how it&amp;rsquo;s actually possible to tame callbacks and write clean, manageable asynchronous code with the aid of some patterns.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-simple-web-spider&#34;&gt;Creating a simple web spider&lt;/h2&gt;

&lt;p&gt;To explain the problem we&amp;rsquo;ll create a little CLI application that takes a web URL as input and downloads its contents locally into file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// file spider.js
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const request = require(&#39;request&#39;); // HTTP request client
const mkdirp = require(&#39;mkdirp&#39;); // Recursively mkdir, like mkdir -p
const chalk = require(&#39;chalk&#39;); // Terminal string styling done right.

const utils = require(&#39;./utils&#39;);

function spider(url, cb) {
  const filePath = utils.urlToFilePath(url);
  const fileName = utils.urlToFileName(url);
  let isFileExists = false;

  fs.stat(filePath, (err, stats) =&amp;gt; { // [1]
    if (stats) {
      cb(null, fileName, isFileExists = true);
    } else {
      request(url, (err, response, body) =&amp;gt; { // [2]
        if (err) {
          cb(err);
        } else {
          mkdirp(filePath, err =&amp;gt; { // [3]
            if (err) {
              cb(err);
            } else {
              fs.writeFile(path.join(filePath, fileName), body, err =&amp;gt; { // [3]
                if (err) {
                  cb(err);
                } else {
                  cb(null, fileName, isFileExists);
                }
              })
            }
          })
        }
      })
    }
  })
}

spider(process.argv[2], (err, fileName, fileExists) =&amp;gt; {
  if (err) {
    console.log(chalk.red(`Error: ${err}`));
  } else if (fileExists) {
    console.log(chalk.blue(`File: ${fileName} exists`));
  } else {
    console.log(chalk.green(`File: ${fileName} is downloaded`));

  }
})

// file utils.js
/*
* Converts urls to simplified strings
*/
const slugifyUrl = require(&#39;slugify-url&#39;);

exports.urlToFilePath = urlToFilePath;
exports.urlToFileName = urlToFileName;

function urlToFilePath(url) { // http://example.com/bar
  const slashChar = &#39;/&#39;;

  return slugifyUrl(url, { slashChar }); // example.com/bar
}

function urlToFileName(url) { // http://example.com/bar
  const slashChar = &#39;/&#39;;
  const parsedUrl = slugifyUrl(url, { slashChar }).split(&#39;/&#39;);

  return parsedUrl[parsedUrl.length - 1]; // bar
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The preceding functions execute the following tasks:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Check if the URL was already downloaded by verifying that corresponding file hasn&amp;rsquo;t already created.&lt;/li&gt;
&lt;li&gt;If the file is not found, it would download content of provided URL&lt;/li&gt;
&lt;li&gt;Then it creates recursively directories&lt;/li&gt;
&lt;li&gt;Finally, it writes the body of HTTP response to file system&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;the-callback-hell&#34;&gt;The callback hell&lt;/h2&gt;

&lt;p&gt;We can surely notice that even though the algorithm was straightforward, the resulting code has several level of indentation and it&amp;rsquo;s very hard to read. Implementing a similar function in &lt;code&gt;direct style&lt;/code&gt; would more straightforward, and it would be very few chances to make it look so wrong. However, using &lt;code&gt;CPS&lt;/code&gt; is another story, and making bad use of closure may lead to to incredible bad code.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s known as &lt;code&gt;callback hell&lt;/code&gt; or &lt;code&gt;piramid of domm&lt;/code&gt;. The typical structure of code affected by the problem looks like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;asyncFoo(err =&amp;gt; {
  asyncBar(err2 =&amp;gt; {
    asyncFooBar(err3 =&amp;gt; {
      // ...
    })
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another problem is caused by overlapping of the variable names used in each scope. Some people try to avoid it with variation of variables &lt;code&gt;error, err, err2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Also we should keep in mind that closure can create memory leaks that are not so easy to identify. We shouldn&amp;rsquo;t forget that any context referenced by an active closure is retained from garbage collector.&lt;/p&gt;

&lt;h2 id=&#34;applying-the-callback-discipline&#34;&gt;Applying the callback discipline&lt;/h2&gt;

&lt;p&gt;Basic principles that can help to keep the nesting level low and improve the organization of our code in general:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;you must exit as soon as possible. Use &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt; or &lt;code&gt;break&lt;/code&gt;, depending on context to immediately exit the current statement&lt;/li&gt;
&lt;li&gt;create a named function for callbacks. Will keep our code shallow and better look for stack trace&lt;/li&gt;
&lt;li&gt;modularize the code. Create a small, reusable function whenever it&amp;rsquo;s possible&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After applying the following recommendation our &lt;code&gt;spider()&lt;/code&gt; would look as following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function spider(url, cb) {
  const filePath = utils.urlToFilePath(url);
  const fileName = utils.urlToFileName(url);
  let isFileExists = false;

  fs.stat(filePath, (err, stats) =&amp;gt; {
    if (stats) {
      return cb(null, fileName, isFileExists = true); // [!]
    }
    download(url, filePath, fileName, isFileExists, cb);
  })
}

function download(url, filePath, fileName, isFileExists, cb) {
  request(url, (err, response, body) =&amp;gt; {
    if (err) {
      return cb(err); // [!]
    } else {
      saveFile(filePath, fileName, body, isFileExists, cb); // [!]
    }
  })
}

function saveFile(filePath, fileName, content, isFileExists, cb) {
  mkdirp(filePath, err =&amp;gt; {
    if (err) {
      return cb(err); // [!]
    } else {
      writeContent(filePath, fileName, content, isFileExists, cb);
    }
  })
}

function writeContent(filePath, fileName, content, isFileExists, cb) {
  fs.writeFile(path.join(filePath, fileName), content, err =&amp;gt; {
    if (err) {
      return cb(err); // [!]
    } else {
      return cb(null, fileName, isFileExists); // [!]
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sequential-execution&#34;&gt;Sequential execution&lt;/h2&gt;

&lt;p&gt;Executing a set of task in sequence means running them one at time, one ofter other. The order of execution matters. The concept:&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/sequential-execution.png %}&lt;/p&gt;

&lt;p&gt;There are different variation of this flow:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;execution a set of known task in sequence&lt;/code&gt;, without chaining and propagate the result&lt;/li&gt;
&lt;li&gt;using output of task as the input to the next task, also known as &lt;code&gt;chain&lt;/code&gt;, &lt;code&gt;pipe&lt;/code&gt;, or &lt;code&gt;waterfall&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;iterating over a collection while running an asynchronous task on each element, one ofter other&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;execution-a-set-of-known-task-in-sequence&#34;&gt;Execution a set of known task in sequence&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve already met a sequential execution while implementing the &lt;code&gt;spider()&lt;/code&gt; function. Taking that code as guideline we can generalize the solution into the following pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function task1(cb) {
  asyncOperation(() =&amp;gt; task2(cb))
}

function task2(cb) {
  asyncOperation(() =&amp;gt; task3(cb))
}

function task3(cb) {
  asyncOperation(() =&amp;gt; cb()) // finally executes the callback
}

function asyncOperation(cb) { // emulates asynchronous operation
  setTimeout(() =&amp;gt; cb());
}

task1(() =&amp;gt; console.log(&#39;task 1, 2 and 3 executed&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sequential-iteration-with-crawling-of-links&#34;&gt;Sequential iteration with crawling of links&lt;/h3&gt;

&lt;p&gt;What if we want to invoke an asynchronous operation for each file in a collection?&lt;/p&gt;

&lt;p&gt;With new feature, downloading all the links contained in the web-page recursively. To do that, we are going to extract all links from the page and than trigger our web spider on each of them recursively and in sequence.&lt;/p&gt;

&lt;p&gt;The new version of &lt;code&gt;spider()&lt;/code&gt; is as following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function spider(url, nesting, callback) {
  const filename = utilities.urlToFilename(url);
  fs.readFile(filename, &#39;utf8&#39;, (err, body) =&amp;gt; {
    if(err) {
      if(err.code ! == &#39;ENOENT&#39;) {
        return callback(err);
      } 
      return download(url, filename, (err, body) =&amp;gt; {
        if(err) {
          return callback(err);
        }
        spiderLinks(url, body, nesting, callback);
      });
    }

    spiderLinks(url, body, nesting, callback);
  });
}

function spiderLink(url, body, nesting, cb) {
  if (nesting === 0) {
    return process.nextTick(cb);
  }
  // require(&#39;get-urls&#39;)
  const links = utils.getUrls(body); // [1]

  function iterate(index) { // [2]
    if (index === links.length) {
      return cb();
    }

    spider(links[index], nesting - 1, err =&amp;gt; { // [3]
      if (err) {
        return cb(err);
      }
      iterate(index - 1);
    })
  }
  iterate(0); // [4]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important steps to understand:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Obtain the list of all links on the page using the &lt;code&gt;utils.getUrls()&lt;/code&gt;. This links should return only with the same hostname&lt;/li&gt;
&lt;li&gt;Iterate through links via local function &lt;code&gt;iterate()&lt;/code&gt;. The first thing it checks if the &lt;code&gt;index&lt;/code&gt; is equal to the length of &lt;code&gt;links&lt;/code&gt;, in which case it immediately invokes the &lt;code&gt;cb()&lt;/code&gt; as it means it proceeds all items&lt;/li&gt;
&lt;li&gt;At this point everything is ready to processing the links. It invokes the &lt;code&gt;spider()&lt;/code&gt; function by decreasing the nesting level and invoking the next step of iteration then the operation is complete&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s a bootstrapping the iteration by &lt;code&gt;iterate(0)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;the-pattern-sequential-iteration&#34;&gt;The pattern &amp;ldquo;sequential iteration&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;It can be generalize as follow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function iterate(index) {
  if (index === tasks.length) {
    return finish();
  }

  const task = tasks[index];
  task(function() {
    iterate(index + 1);
  })
}

function finish() {
  // iteration completed
}

iterate(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s important to notice that these type of algorithm become really recursive if &lt;code&gt;task()&lt;/code&gt; is an asynchronous operation. In such a case there might be a risk of hitting the maximum call stack limit.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pattern sequential iterator:
execute a list of tasks in sequence by creating a function &lt;code&gt;iterate()&lt;/code&gt; which invokes the next available task in the collection and makes sure to invoke next step of iteration when the current task is completed&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;parallel-execution&#34;&gt;Parallel execution&lt;/h2&gt;

&lt;p&gt;There is some situation when the order of execution of the set of asynchronous tasks is not important and we want just to be notified when all these running tasks are completed.&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/parallel-execution.png %}&lt;/p&gt;

&lt;p&gt;We realize that even thought we have one thread we can still achieve &lt;code&gt;concurrency&lt;/code&gt;, thanks to not-blocking nature of Node.js. In fact, the word &lt;code&gt;parallel&lt;/code&gt; is used improperly in this case, as it doesn&amp;rsquo;t mean that the task run simultaneously, but rather their execution is carried out by an underlying non-blocking API and invoked by the event loop.&lt;/p&gt;

&lt;p&gt;As we know, a task gives control back to the event loop when it request a new asynchronous operation, allowing the event loop to execute another task. The proper word is to use for this kind of flow is &lt;code&gt;concurrency&lt;/code&gt;, but we still use parallel for simplicity sake.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/1050222/concurrency-vs-parallelism-what-is-the-difference&#34;&gt;Concurrency vs Parallelism&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The following diagram shows how two asynchronous tasks can run in parallel in a Node.js program:&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/parallel-execution-diagram.png %}&lt;/p&gt;

&lt;p&gt;We have &lt;code&gt;Main&lt;/code&gt; function that executes two asynchronous tasks:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;Main&lt;/code&gt; function triggers the execution of &lt;code&gt;Task1&lt;/code&gt; and &lt;code&gt;Task2&lt;/code&gt;. As they are asynchronous operations the immediately return control to &lt;code&gt;Main&lt;/code&gt;, which then returns to &lt;code&gt;event loop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;When the asynchronous operation of &lt;code&gt;Task1&lt;/code&gt; is completed, the &lt;code&gt;event loop&lt;/code&gt; gives control to it. When &lt;code&gt;task1&lt;/code&gt; completes the internal synchronous operation processing as well, it notifies the &lt;code&gt;Main&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The same as described in p2 but now with &lt;code&gt;event loop&lt;/code&gt; triggers the &lt;code&gt;Task2&lt;/code&gt;. At this point &lt;code&gt;Main&lt;/code&gt; function knows that &lt;code&gt;Task1&lt;/code&gt; and &lt;code&gt;Task2&lt;/code&gt; are completed, so it can continue the execution or return the result of the operation to another callback.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;execution-with-spiderlinks&#34;&gt;Execution with &amp;ldquo;spiderLinks&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;So far application is executing the recursive download of the linked pages in a sequential fashion. We can easily improve performance of this process by downloading all the linked pages in parallel:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function spiderLink(url, body, nesting, cb) {
  if (nesting === 0) {
    return process.nextTick(cb);
  }
  const links = utils.getUrls(body);

  if (links.length === 0) {
    return process.nextTick(cb)
  }

  let completed = 0;
  let hasErrors = false;

  function done(err) {
    if (err) {
      hasErrors = true;
      return cb(err);
    }
    if (++completed === links.length &amp;amp;&amp;amp; !hasErrors) {
      return cb()
    }
  }

  links.forEach(link =&amp;gt; {
    spider(link, nesting - 1, done);
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The trick to make our application to wait for all the task to complete is to invoke the &lt;code&gt;spider()&lt;/code&gt; with a special callback &lt;code&gt;done()&lt;/code&gt;. The &lt;code&gt;done()&lt;/code&gt; increases a counter when a &lt;code&gt;spider()&lt;/code&gt; task completes. When the number of completed downloads reaches the size of &lt;code&gt;links[]&lt;/code&gt;, the final callback is invoked.&lt;/p&gt;

&lt;h3 id=&#34;the-pattern-unlimited-parallel-execution&#34;&gt;The pattern &amp;ldquo;unlimited parallel execution&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;We can represent a generic version of the pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const tasks = [ /*...*/ ];
let completed = 0;

tasks.forEach(task =&amp;gt; {
  task(() =&amp;gt; {
    if (++competed === tasks.length) {
      finish();  
    }
  })
})

function finish() {
  // all tasks are completed
}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Pattern unlimited parallel execution
Run a set of asynchronous tasks in parallel by spawning them all at once, and then waiting for all of them to complete by counting the number of the times their callback are invoked&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;limited-parallel-execution&#34;&gt;Limited parallel execution&lt;/h3&gt;

&lt;p&gt;Imagine having thousands of files to read, URLs to access, or DB queries run in parallel. A common problem in such situation is running out of memory. In all such situation its a good idea to limit the number of tasks that can run in the same time. The following diagram show a situation where we have five tasks that run in parallel with an concurrency limit of 2:&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/concurency-limit.png %}&lt;/p&gt;

&lt;p&gt;The algorithm to execute a set of given tasks in parallel with limited concurrency:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const tasks = [ /*...*/ ];
let concurrency = 0;
let running = 0;
let completed = 0;
let index = 0;

function next() {
  while(running &amp;lt; concurrency &amp;amp;&amp;amp; index &amp;lt; tasks.length) {
    const task = tasks[index];

    running++;
    task(() =&amp;gt; {
      if (completed === tasks.length) {
        return finish();
      }
      completed++;
      running--;
      next();
    })
  }
}

next();

function finish() {
  // all tasks are completed
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;taskqueue-to-rescue&#34;&gt;&amp;ldquo;TaskQueue&amp;rdquo; to rescue&lt;/h3&gt;

&lt;p&gt;We are now going to implement a simple class which will combine a queue algorithm we presented before:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class TaskQueue {
  constructor(concurrency) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }

  pushTask(taks) {
    this.queue.push(task);
    this.next();
  }

  next() {
    while(this.running &amp;lt; this.concurrency &amp;amp;&amp;amp; this.queue.length) {
      const task = this.queue.shift();

      this.running++;
      task(() =&amp;gt; {
        this.running--;
        this.next();
      })
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can update our &lt;code&gt;spiderLink()&lt;/code&gt; to execute tasks in a limited parallel flow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const TaskQueue = require(&#39;./task-queue&#39;);
const downloadQueue = new TaskQueue(2);

function spiderLink(url, body, nesting, cb) {
  if (nesting === 0) {
    return process.nextTick(cb);
  }
  const links = utils.getUrls(body);

  if (links.length === 0) {
    return process.nextTick(cb)
  }

  let completed = 0;
  let hasErrors = false;

  links.forEach(link =&amp;gt; {
    downloadQueue.pushTask(done =&amp;gt; {
      spider(link, nesting - 1, done);
    })
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;chapter-4-asynchronous-control-flow-with-es6-and-beyond&#34;&gt;Chapter 4: Asynchronous Control Flow with ES6 and beyond&lt;/h1&gt;

&lt;p&gt;We are going to explore some of the most famous alternatives, &lt;code&gt;promises&lt;/code&gt;, &lt;code&gt;generators&lt;/code&gt; and an innovative syntax of ES7 the &lt;code&gt;async await&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Historically, there have been many different implementation of promise libraries, and most of them aren&amp;rsquo;t compatible between each other. The JS community worked hard to sort out this limitation and these efforts leads to creation of &lt;code&gt;Promise/A+&lt;/code&gt; spec.&lt;/p&gt;

&lt;p&gt;The several poplar libraries which implement the &lt;code&gt;Promise/A+&lt;/code&gt; spec:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bluebird&lt;/li&gt;
&lt;li&gt;Q&lt;/li&gt;
&lt;li&gt;RSVP&lt;/li&gt;
&lt;li&gt;When.js&lt;/li&gt;
&lt;li&gt;ES6 promises&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;es6-promises-techniques&#34;&gt;ES6 Promises techniques&lt;/h2&gt;

&lt;h3 id=&#34;promisifying-a-node-js-style-function&#34;&gt;Promisifying a Node.js style function&lt;/h3&gt;

&lt;p&gt;In JS not all the asynchronous functions and libraries support promises out-of-box. We can convert a typical callback-based function into one that returns a promise, this process is also known as &lt;code&gt;promisification&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module.exports.promisify = function(fn) {
  return function promisified(...callArgs) {
    return new Promise((resolve, reject) =&amp;gt; { //[1]
      callArgs.push((err, result, ...restResults) =&amp;gt; { //[2]
        if (err) {
          return reject(err); //[3]
        }
        console.log(callArgs)
        if (callArgs.length &amp;lt;= 2) { //[4]
          resolve(result);
        } else {
          resolve([result, ...restResults]);
        }
      });

      // the same as fn.apply(null, callArgs)
      fn(...callArgs); //[5]
    });
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how it works:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;promisified()&lt;/code&gt; creates a new promise using &lt;code&gt;Promise&lt;/code&gt; constructor and immediately return it to caller&lt;/li&gt;
&lt;li&gt;We make sure to pass a special callback to &lt;code&gt;fn()&lt;/code&gt;. As we know that the callback always comes last, we append it to the arguments (&lt;code&gt;args&lt;/code&gt;) provided to the &lt;code&gt;promisified()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;In the special callback if we receive an error we immediately reject an error&lt;/li&gt;
&lt;li&gt;If no error, we resolve the promise with a value or an array of values, depending how many results are passing to callback&lt;/li&gt;
&lt;li&gt;Finally, we simply invoke the &lt;code&gt;fs()&lt;/code&gt; with the list of arguments we have built&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Another approach is to use one of the ready-production npm packages, for example &lt;a href=&#34;https://www.npmjs.com/package/tiny-promisify&#34;&gt;tini-promisify&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;sequential-execution-1&#34;&gt;Sequential execution&lt;/h3&gt;

&lt;p&gt;We are now ready to convert our web spider application to use promises:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const utilities = require(&#39;utilities&#39;);
const promisify = utilities.promisify;

// const fs = require(fs);
const request = promisify(require(&#39;request&#39;));
const makedirp = promisify(require(&#39;makedirp&#39;));
const readFile = promisify(require(fs.readFile));
const writeFile = promisify(require(fs.writeFile));

function spider(url, nesting) {
  const filePath = utils.urlToFilePath(url);
  const fileName = utils.urlToFileName(url);

  return readFile(path.join(filePath, fileName), &#39;utf8&#39;)
    .then(body =&amp;gt; spiderLink(url, body, nesting))
    .catch((err) =&amp;gt; {
      if (err) {
        if (err.code === &#39;ENOENT&#39;) { 
          return download(url, fileName);
        }
      }
    })
    .then(body =&amp;gt; {
      spiderLink(url, body, nesting)
    })
}

function download(url, filename) {
  let body = body;

  return request(url)
    .then(resp =&amp;gt; {
      body = resp.body;
      return mkdirp(path.dirname(url));
    })
    .then(() =&amp;gt; writeFile(filename, body))
    .then(() =&amp;gt; {
      console.log(`Download and saved ${fileName} from ${url}`);
      return body;
    })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also we modify its invocation as follow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;spider(url, 5)
  .then(() =&amp;gt; console.log(chalk.green(`Download and saved from ${url}`)))
  .catch((err) =&amp;gt; console.log(chalk.red(`Error: ${err}`)));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we look again at code we have written so far, we would be pleasantly surprised by the fact that we haven&amp;rsquo;t include any error propagation logic, as we would be forced to do with callbacks. This is clearly a huge advantage, as it reduced boilerplate in our code.&lt;/p&gt;

&lt;h3 id=&#34;sequential-iteration&#34;&gt;Sequential iteration&lt;/h3&gt;

&lt;p&gt;So far it was shown how simple and elegant is to implement sequential execution flow using promises. However code involves only the &lt;code&gt;execution of a well known set of asynchronous operation&lt;/code&gt;. So, we missing peace that will complete our exploration of sequential execution flow with implementation of &lt;code&gt;asynchronous iteration&lt;/code&gt; using promises&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function spiderLink(url, body, nesting) {
  const links = utils.getUrls(body);
  let promise = Promise.resolve();
  
  if (nesting === 0) {
    return promise;
  }

  links.forEach(link =&amp;gt; {
    promise = promise.then(() =&amp;gt; spider(link, nesting--;))
  })

  return promise;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To iterate asynchronously over links we had dynamically build a chain of promises:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Starting with an &amp;ldquo;empty&amp;rdquo; promise, resolving to &lt;code&gt;undefined&lt;/code&gt;. This is a starting point to build our chain&lt;/li&gt;
&lt;li&gt;Then, in the loop, we&amp;rsquo;re updating the &lt;code&gt;promise&lt;/code&gt; variable with a new promise which is invoked from &lt;code&gt;then()&lt;/code&gt; on the previous promise in the chain. This is actually our asynchronous iteration pattern using promises.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s extract a pattern for a sequential execution using promises:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const tasks = [/*...*/];
let promise = Promise.resolve();

tasks.forEach(task =&amp;gt; {
  promise = promise.then(() =&amp;gt; task());
})

// an alternative with &amp;quot;reduce()&amp;quot;
/*
tasks.reduce((prev, task) =&amp;gt; {
  return prev.then(() =&amp;gt; task());
}, Promise.resolve())
*/

promise.then(() =&amp;gt; /*all task are completed*/)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The pattern: sequential iteration with promises
Dynamically builds a chain of promises in a loop&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;parallel-execution-1&#34;&gt;Parallel execution&lt;/h3&gt;

&lt;p&gt;Another execution flow is become trivial with promises is the parallel execution flow using &lt;code&gt;Promise.all()&lt;/code&gt;. This static method creates promise which fulfills only when all the promises received as input are fulfilled:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function spiderLink(url, body, nesting) {
  const links = utils.getUrls(body);
  
  if (nesting === 0) {
    Promise.resolve()
  }

  let promises = links.map(link =&amp;gt; spider(link, --nesting));

  return Promise.all(promises);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;limited-parallel-execution-1&#34;&gt;Limited parallel execution&lt;/h4&gt;

&lt;p&gt;In fact, the pattern we&amp;rsquo;ve implemented in &lt;code&gt;TaskQueue&lt;/code&gt; class can be easily adapted to support tasks that return a promise. This can be achieve by modifying &lt;code&gt;next()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;next() {
  while(this.running &amp;lt; this.concurrency &amp;amp;&amp;amp; this.queue.length) {
    const task = this.queue.shift();

    this.running++;
    
    task().then(() =&amp;gt; {
      completed++;
      running--;
      this.next();
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can modify the &lt;code&gt;spideLinks()&lt;/code&gt; to achieve limit of concurrency:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const TaskQueue = require(&#39;./task-queue&#39;);
const downloadQueue = new TaskQueue(2);

function spiderLink(url, body, nesting) {
  if (nesting === 0 || links.length === 0) {
    return Promise.resolve;
  }
  const links = utils.getUrls(body);

  let completed = 0;
  let hasErrors = false;

  return Promise((resolve, reject) =&amp;gt; {
    let completed = 0;
    let error = false;

    links.forEach(link =&amp;gt; {
      let task = () =&amp;gt; {
        return spider(link, --nesting)
          .then(() =&amp;gt; {
            if (++completed === links.length) {
              resolve()
            }
          })
          .catch((err) =&amp;gt; {
            if (!error) {
              error = true;
              reject();
            }
          })
      };
      downloadQueue.pushTask(task)
    })
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;exposing-callbacks-and-promises-in-public-apis&#34;&gt;Exposing callbacks and promises in public APIs&lt;/h4&gt;

&lt;p&gt;Now let&amp;rsquo;s imagine that we want to build a public library that performs asynchronous operations. Do we need to create CPS API or a promise-oriented one?&lt;/p&gt;

&lt;p&gt;The first approach is used by popular libraries such as &lt;code&gt;request&lt;/code&gt;, &lt;code&gt;redis&lt;/code&gt; and &lt;code&gt;mysql&lt;/code&gt;, consists of offering a simply API that is only based on callbacks and leaves the developer the option to promisify the exposed functionality of needed. Some of these libraries provides helpers to achieve a such behavior.&lt;/p&gt;

&lt;p&gt;The second approach is more transparent. It offers the developers a callback-oriented API, but it makes the callback argument optional. When the callback is not passed, the function will immediately return a &lt;code&gt;Promise&lt;/code&gt; object. This approach gives possibility to choose at call time what interface to adopt, without any needs to promisify the functionality in advance. Many libraries, such as &lt;code&gt;mongoose&lt;/code&gt; or &lt;code&gt;sequelize&lt;/code&gt;, support this approach.&lt;/p&gt;

&lt;p&gt;A dummy module that executes division asynchronously:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//divider.js
module.exports = (divident, divisor, cb) {
  return new Promise(resolve, reject) =&amp;gt; {
    process.nextTich(() =&amp;gt; {
      const result = divident / divisor;

      if (!Number.isInteger(result)) {
        const err = new Error(&#39;Invalid operands&#39;);

        if (cb) return cb(err);
        reject(err);
      }
      if (cb) return cb(null, result);
      resolve(result);
    })
  }
}

//main.js
const divider = require(&#39;./divider&#39;)
divider(10, 0, (err, res) =&amp;gt; {
  if (err) return console.error(err);

  console.log(res);
});

divider(10, 2)
  .then(res =&amp;gt; console.log(res))
  .catch(err =&amp;gt; console.error(err));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;generators&#34;&gt;Generators&lt;/h2&gt;

&lt;p&gt;In fact, in a normal function we can only have one entry point which corresponds to the invocation of function itself. A generator is similar to a function, but in addition, it can be suspended (using the &lt;code&gt;yield&lt;/code&gt; statement) and then resumed at a later time.&lt;/p&gt;

&lt;h3 id=&#34;asynchronous-control-flow-with-generators&#34;&gt;Asynchronous control flow with generators&lt;/h3&gt;

&lt;p&gt;To demonstrate how generator will help us with this by creating a special function that accepts a generator as an argument and allows us to use asynchronous code inside the generator. The function take care to resume the execution of the generator when the asynchronous operation is complete:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function asyncFlow(generatorFn) {
  const generator = generatorFn(cb);
  generator.next();

  // special callback to resume/stop the generator
  // resume by passing back the result receiving in the cb function
  function cb(err, ...result) {
    if (err) {
      return generator.throw(err);
    }

    generator.next(result);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To demonstrate the power of this simple function with new module:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// clone.js
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

asyncFlow(function* (cb) {
  const filename = path.basename(__filename);
  const content = yield fs.readFile(filename, &#39;utf8&#39;, cb);

  yield fs.writeFile(`clone_of_${filename}`, content, cb);
  console.log(&#39;clone created&#39;);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remarkable with help of &lt;code&gt;asyncFlow()&lt;/code&gt; we were able to write asynchronous code using the linear approach, as we using blocking function! The callback passed to each asynchronous function will in turn resume the generator as soon as a asynchronous operation is complete.&lt;/p&gt;

&lt;p&gt;There are two other variation of these technique, one involves to use &lt;code&gt;promises&lt;/code&gt; and other use &lt;code&gt;thunks&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;thunk&lt;/code&gt; used in the generator based control flow it&amp;rsquo;s just a function which partially applies all the arguments of original function except its callback. An example of thunkified version of &lt;code&gt;fs.readFile()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function readFileThunk(filename, options) {
  return function(cb) {
    fs.readFile(filename, options, cb);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both promises and thunks allow us to create generators that do not need a callback argument. Thunkfied version of &lt;code&gt;asynkFlow()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

asyncFlowWithThunks(function* () {
  const filename = path.basename(__filename);
  const content = yield readFileThunk(filename, &#39;utf8&#39;);

  yield writeFileThunk(`clone_of_${filename}`, content);
  console.log(&#39;clone created&#39;);
})

function readFileThunk(filename, options) {
  return function(cb) {
    fs.readFile(filename, options, cb);
  }
}

function writeFileThunk(filename, constent) {
  return function(cb) {
    fs.writeFile(filename, constent, cb);
  }
}


function asyncFlow(generatorFn) {
  const generator = generatorFn();
  const thunk = generator.next().value;
  thunk &amp;amp;&amp;amp; thunk(cb);
  
  function cb(err, ...result) {
    let thunk;

    if (err) {
      return generator.throw(err);
    }

    thunk = generator.next(result).value;
    thunk &amp;amp;&amp;amp; thunk(cb);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the same way we could implement a version with promises:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

asyncFlowWithPromises(function* () {
  const filename = path.basename(__filename);
  const content = yield readFilePromise(filename, &#39;utf8&#39;);

  yield writeFilePromise(`clone_of_${filename}`, content);
  console.log(&#39;clone created&#39;);
})

function readFilePromise(filename, options) {
  const readFile = promisify(fs.readFile);
  return (cb) =&amp;gt; {
    fs.readFile(filename, options, cb);
  };
}

function writeFilePromise(filename, content) {
  const readFile = promisify(fs.writeFile);
  return (cb) =&amp;gt; {
    fs.writeFile(filename, content, cb);
  };
}

function promisify(fn) {
  return function promisified(...callArgs) {
    return new Promise((resolve, reject) =&amp;gt; { 
      callArgs.push((err, result, ...restResults) =&amp;gt; { 
        if (err) {
          return reject(err); 
        }
        console.log(callArgs)
        if (callArgs.length &amp;lt;= 2) { 
          resolve(result);
        } else {
          resolve([result, ...restResults]);
        }
      });
      
      fn(...callArgs); 
    });
  }
}

function asyncFlow(generatorFn) {
  const generator = generatorFn();
  const thunk = generator.next().value;
  thunk &amp;amp;&amp;amp; thunk(cb);
  
  function cb(err, ...result) {
    let thunk;

    if (err) {
      return generator.throw(err);
    }

    thunk = generator.next(result).value;
    thunk &amp;amp;&amp;amp; thunk(cb);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generator based control flow using &amp;ldquo;co&amp;rdquo;&lt;/p&gt;

&lt;p&gt;In this section we chose to use &lt;a href=&#34;https://www.npmjs.com/package/co&#34;&gt;co&lt;/a&gt;. It supports several types of yieldables:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;thunks&lt;/li&gt;
&lt;li&gt;promises&lt;/li&gt;
&lt;li&gt;array (parallel execution)&lt;/li&gt;
&lt;li&gt;object (parallel execution)&lt;/li&gt;
&lt;li&gt;generators (delegation)&lt;/li&gt;
&lt;li&gt;generator function (delegation)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To convert Node.js style function to thunks, we are going to library &lt;a href=&#34;https://www.npmjs.com/package/thunkify&#34;&gt;thunkify&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;sequential-execution-2&#34;&gt;Sequential execution&lt;/h3&gt;

&lt;p&gt;Load and convert all dependencies:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// spider.js
const thunkify = require(&#39;thunkify&#39;);
const co = require(&#39;co&#39;);
const path = require(&#39;path&#39;);

const request = thunkify(require(&#39;request&#39;));
const fs = require(&#39;fs&#39;);
const mkdirp = thunkify(require(&#39;mkdirp&#39;));
const readFile = thunkify(fs.readFile);
const writeFile = thunkify(fs.writeFile);
const nextTick = thunkify(process.nextTick);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Is interesting to point out if we decided to use the promisified version of our function instead of their thunkified alternatives, so code would be remain exactly the same, thanks to the fact that &lt;code&gt;co&lt;/code&gt; supports both promises and thunks yiedlable objects.&lt;/p&gt;

&lt;p&gt;Now implementation of &lt;code&gt;download()&lt;/code&gt; and &lt;code&gt;spider()&lt;/code&gt; becomes trivial:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function* download(url, filename) {
  console.log(`download ${url}`);
  const response = yield request(url);
  const body = response[1];

  yield mkdirp(path.dirname(filename));
  yield writeFile(filename, body);
  console.log(`downloaded and saved file ${filename}`);

  return body;
}

function* spider(url, nesting) {
  const filename = utilities.urlToFilename(url);
  let body;

  try {
    body = yield readFile(url, &#39;utf8&#39;);
  } catch(e) {
    if (e.code !== &#39;ENOENT&#39;) {
      throw e;
    }
    body = yield download(url, filename);
  }
  yield spiderLink(url, body, nesting);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The interesting detail to notice that we&amp;rsquo;re able to use a &lt;code&gt;try...catch&lt;/code&gt; and propagate error with &lt;code&gt;throw&lt;/code&gt;! Another remarkable line is where we use &lt;code&gt;yield download()&lt;/code&gt; which is not a promise nor a thunk, but just another generator. This is possible thanks to &lt;code&gt;co&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Converting &lt;code&gt;spiderLinks()&lt;/code&gt; becomes trivial as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function spiderLinks(url, body, nesting) {
  if (nesting === 0) {
    return nextTick();
  }

  const links = utilities.getPageLinks(body);
  links.forEach(link =&amp;gt; {
    yield spider(link, nesting - 1);
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The is no pattern to show for sequential iteration, generators and &lt;code&gt;co&lt;/code&gt; are doing the all dirty work for us, so we&amp;rsquo;re able to write asynchronous iteration as we were using blocking, direct APIs.&lt;/p&gt;

&lt;p&gt;Now an important entry point:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;co(function* () {
  const nesting = 1;
  try {
    yield spider(process.argv[2], nesting);
  } catch(e) {
    console.log(e);
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The whole implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const thunkify = require(&#39;thunkify&#39;);
const co = require(&#39;co&#39;);
const path = require(&#39;path&#39;);

const request = thunkify(require(&#39;request&#39;));
const fs = require(&#39;fs&#39;);
const mkdirp = thunkify(require(&#39;mkdirp&#39;));
const readFile = thunkify(fs.readFile);
const writeFile = thunkify(fs.writeFile);
const nextTick = thunkify(process.nextTick);

const utilities = require(&#39;./utils&#39;);

co(function* () {
  const nesting = 1;
  try {
    yield spider(process.argv[2], nesting);
  } catch(e) {
    console.log(e);
  }
})

function* download(url, filename) {
  console.log(`download ${url}`);
  const response = yield request(url);
  const body = response[1];

  yield mkdirp(path.dirname(filename));
  yield writeFile(filename, body);
  console.log(`downloaded and saved file ${filename}`);

  return body;
}

function* spider(url, nesting) {
  const filename = utilities.urlToFileName(url);
  let body;

  try {
    body = yield readFile(filename, &#39;utf8&#39;);
  } catch(e) {
    if (e.code !== &#39;ENOENT&#39;) {
      throw e;
    }
    body = yield download(url, filename);
  }
  yield spiderLinks(filename, body, nesting);
}

function* spiderLinks(url, body, nesting) {
  if (nesting === 0) {
    return nextTick();
  }

  const links = utilities.getUrls(body);

  for (var i = 0; i &amp;lt; links.length; i++) {
    yield spider(links[i], nesting - 1);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;parallel-execution-2&#34;&gt;Parallel execution&lt;/h3&gt;

&lt;p&gt;The bad news about generators is that they are good to write sequential algorithm, they can&amp;rsquo;t be used to parallelize the execution of set of tasks.&lt;/p&gt;

&lt;p&gt;Luckily, for the specific case of the unlimited parallel execution, &lt;code&gt;co&lt;/code&gt; already allows us to obtain it natively by simpling yielding an array of promises, thunks, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function* spiderLinks(url, body, nesting) {
  if (nesting === 0) {
    return nextTick();
  }

  const links = utilities.getUrls(body);
  const tasks = links.map(link =&amp;gt; spider(link, nesting - 1));
  yield tasks;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we just did was just to collect all the download tasks, which are essentially generators, and then yield on the resulting array. All these task will be executed by &lt;code&gt;co&lt;/code&gt; in parallel and then execution will be resumed when all tasks finish running.&lt;/p&gt;

&lt;h3 id=&#34;limited-parallel-execution-2&#34;&gt;Limited parallel execution&lt;/h3&gt;

&lt;p&gt;The main straightforward approach for me is to use &lt;a href=&#34;https://www.npmjs.com/package/co-limiter&#34;&gt;co-limiter&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const co = require(&#39;co&#39;);
const wait = require(&#39;co-wait&#39;);
const limiter = require(&#39;co-limiter&#39;);

const limit = limiter(2);

const job = function *() {
  console.log(&#39;Doing something...&#39;);
  yield wait(1000);
}

for (let i = 0; i &amp;lt; 10; i++) {
  co(function *() {
    yield limit(job());
  })();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;async-await-with-babel&#34;&gt;&amp;ldquo;async&amp;hellip;await&amp;rdquo; with Babel&lt;/h2&gt;

&lt;p&gt;Preparation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# install babel cli
$ npm install -D babel-cli
# extension to support &amp;quot;async...await&amp;quot; parsing
$ npm install -D babel-plugin-syntax-async-functions
babel-plugin-transform-async-to-generator
# run the example
$ node_modules\.bin\babel-node --plugins
&amp;quot;syntax-async-functions,transform-async-to-generator&amp;quot; index.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is that generator function are designed to deal mostly as iterators and their usage with asynchronous operations feel a bit cumbersome. It might be hard to understand, leading to code that hard to read and maintain.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;async&lt;/code&gt; function specification aims to dramatically improve the language model for waiting asynchronous code by introducing &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; directives:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const promisify = require(&#39;tiny-promisify&#39;);
const request = promisify(require(&#39;request&#39;));

function getPage(url) {
  return request(url).then(res =&amp;gt; {
    return res.body;
  });
}

async function main() {
  const html = await getPage(&#39;http://example.com&#39;);
  console.log(html);
}
main();

console.log(&#39;loading...&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;comparison-table&#34;&gt;Comparison Table&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Plain JS

&lt;ul&gt;
&lt;li&gt;Pros:&lt;/li&gt;
&lt;li&gt;Does not require any additional libraries or technology&lt;/li&gt;
&lt;li&gt;Offer the best performance&lt;/li&gt;
&lt;li&gt;Provides the best compatibility with 3-th party libraries&lt;/li&gt;
&lt;li&gt;Allows creation of ad hoc and more advanced algorithms&lt;/li&gt;
&lt;li&gt;Cons:&lt;/li&gt;
&lt;li&gt;Require extra code and relatively complex algorithms&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Promises

&lt;ul&gt;
&lt;li&gt;Pros:&lt;/li&gt;
&lt;li&gt;Simplify the most common control flow patters&lt;/li&gt;
&lt;li&gt;Robust error handling&lt;/li&gt;
&lt;li&gt;Part of ES6 spec&lt;/li&gt;
&lt;li&gt;Cons:&lt;/li&gt;
&lt;li&gt;Require promisify callback-based APIs&lt;/li&gt;
&lt;li&gt;A small performance hit&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Generators:

&lt;ul&gt;
&lt;li&gt;Pros:&lt;/li&gt;
&lt;li&gt;Makes non-blocking code looks like a blocking one&lt;/li&gt;
&lt;li&gt;Simplify error handling&lt;/li&gt;
&lt;li&gt;Part of ES6 spec&lt;/li&gt;
&lt;li&gt;Cons:&lt;/li&gt;
&lt;li&gt;Require a complementary control flow library&lt;/li&gt;
&lt;li&gt;Require callback or promises to implement non-sequential flows&lt;/li&gt;
&lt;li&gt;Require thunkify or promisify nongenerator-based APIs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Async await

&lt;ul&gt;
&lt;li&gt;Pros:&lt;/li&gt;
&lt;li&gt;Makes a non-blocking code looks like blocking&lt;/li&gt;
&lt;li&gt;Clean and intuitive syntax&lt;/li&gt;
&lt;li&gt;Future part of spec&lt;/li&gt;
&lt;li&gt;Cons:&lt;/li&gt;
&lt;li&gt;Not yet a standard&lt;/li&gt;
&lt;li&gt;Require transpilers such as Babel&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Front End Interview Questions</title>
      <link>https://qetr1ck-op.github.io/blog/post/Front-End-Interview-Questions/</link>
      <pubDate>Sun, 14 Aug 2016 11:39:13 +0000</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/Front-End-Interview-Questions/</guid>
      <description>&lt;p&gt;To rock the interview to achieve what you deserve and to improve your concepts about front end technologies, I have consolidated a list of questions and answers. It&amp;rsquo;s a one stop solution for front end interview process.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;web-core&#34;&gt;Web Core&lt;/h1&gt;

&lt;h2 id=&#34;javascript-basics&#34;&gt;JavaScript: basics&lt;/h2&gt;

&lt;h3 id=&#34;types&#34;&gt;Types&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;What are the differences between &lt;code&gt;undeclared&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;null&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; JavaScript has two distinct values for nothing, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;. Also there are &lt;code&gt;undeclared&lt;/code&gt; variables which don’t even exist.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var declaredVariable = 1;

(function scoppedVariables() {
  undeclaredVariable = 1;
  var declaredVariable = 2;
})();

undeclaredVariable;
declaredVariable;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;undeclared&lt;/code&gt; when it does not use the var keyword. It gets created on the global object, thus it operates in a different space as the declared variables.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;undefined&lt;/code&gt; means, value of the variable is not defined. JavaScript has a global variable &lt;code&gt;undefined&lt;/code&gt; whose value is &amp;ldquo;undefined&amp;rdquo; and &lt;code&gt;typeof undefined&lt;/code&gt; is also &amp;ldquo;undefined&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt; means empty or non-existent value which is used by programmers to indicate “no value”. &lt;code&gt;null&lt;/code&gt; is a primitive value and you can assign &lt;code&gt;null&lt;/code&gt; to any variable. You cannot add properties to it. Sometimes people wrongly assume that it is an object, because &lt;code&gt;typeof null&lt;/code&gt; returns &amp;ldquo;object&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;What are the differences between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt;? To what type &lt;code&gt;==&lt;/code&gt; operands will be converted to if they have
different types?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; The simplest way of saying that, &lt;code&gt;==&lt;/code&gt; will not check types and &lt;code&gt;===&lt;/code&gt; will check whether both sides are of same type. So, &lt;code&gt;==&lt;/code&gt; under the hood converts to number type if they have not the same type and then do the comparison.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;As &lt;code&gt;[]&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;[] == true&lt;/code&gt; should also be &lt;code&gt;true&lt;/code&gt;, right? Explain comparison algorithm.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Not.&lt;/p&gt;

&lt;p&gt;You are right about first part, &lt;code&gt;[]&lt;/code&gt;, empty array is an object and object is always truths.&lt;/p&gt;

&lt;p&gt;However, special case about &lt;code&gt;==&lt;/code&gt; (not-strict equal) is that it will do some implicit coercion.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Since left and right side of the equality are two different types, JavaScript can&amp;rsquo;t compare them directly.&lt;/li&gt;
&lt;li&gt;JavaScript implementation will try to convert &lt;code&gt;[]&lt;/code&gt; by using &lt;code&gt;toPrimitive&lt;/code&gt; (of JavaScript implementation). since &lt;code&gt;[].valueOf&lt;/code&gt; is not primitive will use &lt;code&gt;toString&lt;/code&gt; and will get &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Now you are comparing &lt;code&gt;&amp;quot;&amp;quot; == 1&lt;/code&gt; and still left and right is not same type. Hence left side will be converted again to a number and empty string will be &lt;code&gt;0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Finally, they are of same type, you are comparing &lt;code&gt;0 === 1&lt;/code&gt; which will be &lt;code&gt;false&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;Why &lt;code&gt;typeof bar === object&lt;/code&gt; isn&amp;rsquo;t right? How can this pitfall be avoided?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Use &lt;code&gt;Object.prototype.toString.call(&amp;lt;object&amp;gt;)&lt;/code&gt; or use Duck Typing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt; The surprising gotcha in JavaScript is that &lt;code&gt;null&lt;/code&gt; is also considered an object!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is &lt;code&gt;NaN&lt;/code&gt;? What is its type? How can you reliably test if a value is equal to &lt;code&gt;NaN&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; &amp;ldquo;not a number&amp;rdquo;, &amp;ldquo;number&amp;rdquo;, &lt;code&gt;NaN&lt;/code&gt; compared to anything – even itself! to &lt;code&gt;false&lt;/code&gt;. Use &lt;code&gt;Number.isNaN&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt; The NaN property represents a value that is “not a number”. This special value results from an operation that could not be performed either because one of the operands was non-numeric (e.g., &amp;ldquo;abc&amp;rdquo; / 4), or because the result of the operation is non-numeric (e.g., an attempt to divide by zero).&lt;/p&gt;

&lt;p&gt;ES6 offers a new &lt;code&gt;Number.isNaN()&lt;/code&gt; function, which is a different and more reliable than the old global &lt;code&gt;isNaN()&lt;/code&gt; function.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is the significance, and what are the benefits, of including &lt;code&gt;&#39;use strict&#39;&lt;/code&gt; at the beginning of a JavaScript source file?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; &lt;code&gt;&#39;use strict&#39;&lt;/code&gt; is a way to enforce stricter parsing and error handling on your code at runtime. Code errors that would otherwise have been ignored or would have failed silently will now generate errors or throw exceptions.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt; Some of the key benefits of strict mode include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Makes debugging easier. Code errors that would otherwise have been ignored or would have failed silently will now generate errors or throw exceptions, alerting you sooner to problems in your code and directing you more quickly to their source.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Prevents accidental globals. Without strict mode, assigning a value to an undeclared variable automatically creates a global variable with that name. This is one of the most common errors in JavaScript. In strict mode, attempting to do so throws an error.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Eliminates &lt;code&gt;this&lt;/code&gt; coercion. Without &lt;code&gt;strict mode&lt;/code&gt;, a reference to a this value of &lt;code&gt;undefined&lt;/code&gt; is automatically coerced to the global. This can cause many headfakes and pull-out-your-hair kind of bugs.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Disallows duplicate property names or parameter values. Strict mode throws an error when it detects a duplicate named property in an object (e.g.,&lt;code&gt;var object = {foo: &amp;quot;bar&amp;quot;, foo: &amp;quot;baz&amp;quot;};&lt;/code&gt;) or a duplicate named argument for a function (e.g., &lt;code&gt;function foo(val1, val2, val1){}&lt;/code&gt;), thereby catching what is almost certainly a bug in your code that you might otherwise have wasted lots of time tracking down.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Throws error on invalid usage of delete. The delete operator (used to remove properties from objects) cannot be used on non-configurable properties of the object. Non-strict code will fail silently when an attempt is made to delete a non-configurable property, whereas strict mode will throw an error in such a case.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;scope-and-hoisting-closure-and-functions&#34;&gt;Scope and hoisting, closure and functions&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Example. What is the result will be an error?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;say(&#39;World&#39;);

const phrase = &#39;Hello&#39;;

function say(name) {
  console.log(`${name}, ${phrase}!`);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; &amp;lsquo;undefined, World!&amp;rsquo;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Example. What is the result? What if to remove &lt;code&gt;var value = false&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var value = 0;

function f() {
  if (1) {
    value = true;
  } else {
    var value = false;
  }

  console.log(value);
}

f();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; &lt;code&gt;true&lt;/code&gt;, after remove line of code, will be changed global variable and the result will be the same.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Example. What is the result? How to fix?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fn1();
fn2();
fn3();
fn4();

function fn1() {
  setTimeout(() =&amp;gt; {
    console.log(&#39;fn1&#39;)
  })
}

function fn2() {
  console.log(&#39;fn2&#39;);
}

function fn3() {
  Promise.resolve().then(() =&amp;gt; {
    console.log(&#39;fn3&#39;);
  })
}

const fn4 = function () {
  console.log(&#39;fn4&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; &lt;code&gt;fn4&lt;/code&gt; function expression isn&amp;rsquo;t hoisted. Change to function declaration. The result should be &lt;code&gt;fn2, fn4, fn3, fn1&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is a closure? What is a practical use for a closure? Provide an example.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Closure is a function with all accessible variables in lexical environment. Main usage is encapsulating data from outer usage.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Example. What is the result? How to make them independent?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let initCount = 1;

function makeCounter() {
  return () =&amp;gt; initCount++
}

let counter = makeCounter();
let counter2 = makeCounter();

console.log( counter() ); // ?
console.log( counter() ); // ?

console.log( counter2() ); // ?
console.log( counter2() ); // ?
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Closures Inside in loop with &lt;code&gt;setTimeout&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If log the loop counter inside &lt;code&gt;setTimeout&lt;/code&gt;, what will be logged?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(var i = 0; i &amp;lt; 10; i++) {
  setTimeout(function() {
    console.log(i);  
  }, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: The above will not output the numbers 0 through 9, but will simply print the number 10 ten times.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The console log is inside the anonymous function of &lt;code&gt;setTimeout&lt;/code&gt; and &lt;code&gt;setTimeout&lt;/code&gt; is executed when current call stack is over.&lt;/li&gt;
&lt;li&gt;So, the loop finishes and before setTimeout get the chance to execute. However, anonymous functions keep a reference to &lt;code&gt;i&lt;/code&gt; by creating a closure.&lt;/li&gt;
&lt;li&gt;Since, the loop is already finished, the value &lt;code&gt;i&lt;/code&gt; has been set to &lt;code&gt;10&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can fix it by avoiding closure. Just create a &lt;code&gt;IIFE&lt;/code&gt; (Immediately Invoked Function Expression), it will create its own scope and you can pass i to the function. In that case i will be a local variable (will not refer to i in the closure) and value of the i in every loop will be preserved.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// ES5
for(var i = 0; i &amp;lt; 10; i++) {
    setTimeout((function(i) {
      console.log(i);
    })(i), 10)
}

//or
for(var i = 0; i &amp;lt; 10; i++) {
  setTimeout(console.log.bind(console, i), 10);
}

// ES6
for(let i = 0; i &amp;lt; 10; i++) {
  setTimeout(() =&amp;gt; {
    console.log(i);  
  }, 10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a simple function to tell whether &lt;code&gt;&#39;foo&#39;&lt;/code&gt; is passed as parameter or not?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; First convert &lt;code&gt;arguments&lt;/code&gt; to an array with &lt;code&gt;rest&lt;/code&gt; operator, after that simply use &lt;code&gt;Array.prototype.includes&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// ES5
function isFooPassed(){
  return Array.prototype.indexOf.call(arguments, &#39;foo&#39;) &amp;gt; 0;
}

// ES6
function isFooPassed(...params) {
  return params.includes(&#39;foo&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;How could you use &amp;ldquo;Math.max&amp;rdquo; to find the max value in an array?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Math.max(...arr);  

//ES5 way
//Math.max.apply(Math, arr);  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;How could you set a prefix before everything you log? for example, if you &lt;code&gt;log(&#39;my message&#39;)&lt;/code&gt; it will log: &lt;code&gt;(app) my message&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Just get the arguments, convert it to an array and &lt;code&gt;unshift&lt;/code&gt; whatever prefix you want to set. Finally, use apply to pass all the arguments to console.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// ES5
function log(){
  var args = Array.prototype.slice.call(arguments);
  args.unshift(&#39;(app)&#39;);
  console.log.apply(console, args);
}

// ES6 
function log(...params){
  console.log([&#39;(app)&#39;, ...params]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Cashing / Memoization. How could you implement cache to save calculation time for a recursive fibonacci function?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fibonacci = (() =&amp;gt; {
  const memo = {};

  function f(n) {
    let value;

    if (memo[n]) {
      value = memo[n];
    } else {
      if (n === 0 || n === 1)
        value = n;
      else
        value = f(n - 1) + f(n - 2);

      memo[n] = value;
    }

    return value;
  }

  return f;
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Memoization is a programming technique which attempts to increase a function’s performance by caching its previously computed results. Because JavaScript objects behave like associative arrays, they are ideal candidates to act as caches. Each time a memoized function is called, its parameters are used to index the cache. If the data is present, then it can be returned, without executing the entire function.  However, if the data is not cached, then the function is executed, and the result is added to the cache.&lt;/p&gt;

&lt;p&gt;In the following example, the original Fibonacci function is rewritten to include memoization. In the example, a self-executing anonymous function returns an inner function, f(), which is used as the Fibonacci function. When f() is returned, its closure allows it to continue to access the “memo” object, which stores all of its previous results. Each time f() is executed, it first checks to see if a result exists for the current value of “n”. If it does, then the cached value is returned. Otherwise, the original Fibonacci code is executed. Note that “memo” is defined outside of f() so that it can retain its value over multiple function calls. Recall that the original recursive function was called over 40 billion times to compute the 50th Fibonacci number. By implementing memoization, this number drops to 99.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Why wrapping the entire content of a JavaScript source file in IIFE?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;(function($) { /*...*/ } )(jQuery);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; This technique creates a closure around the entire contents of the file which, perhaps most importantly, creates a private namespace and thereby helps avoid potential name clashes between different JavaScript modules and libraries.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt; Another feature of this technique is to allow for an easily referenceable (presumably shorter) alias for a global variable.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Explain why the following doesn&amp;rsquo;t work as an IIFE: &lt;code&gt;function foo(){ }();&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Because &lt;code&gt;foo&lt;/code&gt; isn’t being called! This is a function definition, it defines &lt;code&gt;foo&lt;/code&gt;. But it’s not a function expression - that is, it’s not understood by the JS parser to actually call a function.&lt;/p&gt;

&lt;p&gt;For the parser, things look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function foo(){
} // ok, done with that function definition
  // (silly human left off the semicolon, how embarrassing!)

(); // Are they trying to call something? What’s the function’s name?
    // PARSE ERROR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to prep the parser that we&amp;rsquo;re actually dealing with a function expression we have to wrap things up in &lt;code&gt;()&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(
  function foo(){
  }()
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also will work with &lt;code&gt;!&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; operators:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;+function() {
  
}();

!function() {

}();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;objects&#34;&gt;Objects&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;What the heck is &lt;code&gt;this&lt;/code&gt; in JavaScript?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; At the time of execution of every function, JavaScript engine sets a property to the function called &lt;code&gt;this&lt;/code&gt; which refer to the current execution context. &lt;code&gt;this&lt;/code&gt; is always refer to an object and depends on how function is called:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;In the global context or inside a function this refers to the &lt;code&gt;window&lt;/code&gt;/&lt;code&gt;global&lt;/code&gt; object. In ES6 module or with &lt;code&gt;use strict&lt;/code&gt; directive it&amp;rsquo;s &lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;While executing a method in the context of an object, the object becomes the value of &lt;code&gt;this&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If you use a constructor (by using &lt;code&gt;new&lt;/code&gt; keyword) to create an object, the value of &lt;code&gt;this&lt;/code&gt; will refer to the newly created object.&lt;/li&gt;
&lt;li&gt;Set the value of &lt;code&gt;this&lt;/code&gt; to any arbitrary object by passing the object as the first parameter of &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt; or &lt;code&gt;apply&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;arrow function&lt;/code&gt; for use parent LexicalEnvironment.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;Why we need &lt;code&gt;call&lt;/code&gt; or &lt;code&gt;apply&lt;/code&gt; or &lt;code&gt;bind&lt;/code&gt;. If you want to use an arbitrary object as value of this, how will you do that?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; To use an arbitrary object as value of this.&lt;/p&gt;

&lt;p&gt;There are at least four different ways to doing this by using &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;arrow function&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qetr1ck-op.github.io/2016/08/06/call-apply-VS-bind-the-simplest-explanation/&#34;&gt;call &amp;amp; apply VS bind, the simplest explanation&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;How would you compare two objects?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; JavaScript has two different approaches for testing equality. Primitives like strings and numbers are compared by their value, while objects like arrays, dates, and user defined objects are compared by their reference. This means it compares whether two objects are referring to the same location in memory.&lt;/p&gt;

&lt;p&gt;Equality check will check whether two objects have same value for same property. To check that, you can get the keys for both the objects.&lt;/p&gt;

&lt;p&gt;Use &lt;a href=&#34;https://www.npmjs.com/package/lodash.isequal&#34;&gt;lodash&lt;/a&gt; or any npm equivalent.&lt;/p&gt;

&lt;p&gt;Or implement by own:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function isEqual(a, b) {
    var aProps = Object.getOwnPropertyNames(a),
        bProps = Object.getOwnPropertyNames(b);

    if (aProps.length !== bProps.length) {
        return false;
    }

    for (var i = 0; i &amp;lt; aProps.length; i++) {
        var propName = aProps[i];
        
        if (a[propName] !== b[propName]) {
            return false;
        }
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Extend Core Object through prototype. Example 1. How could you write a method on instance of a date which will give you next day?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; You need to declare a method on the prototype of Date object. To get access to the current value of the instance of the date use &lt;code&gt;this&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Date.prototype.nextDay = function () {
  return new Date(this.setDate(this.getDate() + 1));
} 

const date = new Date(); 
date; //Fri May 16 2014 20:47:14 GMT-0500 (Central Daylight Time)
date.nextDay();//Sat May 17 2014 20:47:14 GMT-0500 (Central Daylight Time)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Extend Core Object through prototype. Example 2. How could you make this work &lt;code&gt;[1,2,3,4,5].duplicator()&lt;/code&gt; to return &lt;code&gt;[1,2,3,4,5,1,2,3,4,5]&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; We need to add a method in the prototype of Array object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// ES5
Array.prototype.duplicator = function(){
  return this.concat(this);
}

Array.prototype.duplicator = function() {
  return [...this, ...this];
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;In what order are logging properties in the object?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var codes = {
  // keys of country: name of country
  &#39;7&#39;: &#39;Russian Federation&#39;,
  &#39;38&#39;: &#39;Ukraine&#39;,
  &#39;1&#39;: &#39;USA&#39;,
  &#39;57&#39;: &#39;Norway&#39;
};

for (var code in codes) console.log(code); // ?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; &lt;code&gt;1, 7, 38, 57&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;
If name of property is non-numeric string, such keys always moving in the order in which they assigned. On the other hand, if the name of the property - a number or a numeric string, then all modern browsers such properties are sorted for internal optimization.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Why using &lt;code&gt;for...in&lt;/code&gt; for Array iteration is wrong?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Array indexes are just enumerable properties with integer names and are otherwise identical to general &lt;code&gt;Object&lt;/code&gt; properties. There is no guarantee that &lt;code&gt;for...in&lt;/code&gt; will return the indexes in any particular order. The &lt;code&gt;for...in&lt;/code&gt; loop statement will return all enumerable properties, including those with non–integer names and those that are inherited.&lt;/p&gt;

&lt;p&gt;Another point is that &lt;code&gt;for (var i = 0; i &amp;lt; arr.length; i++)&lt;/code&gt; is up to 10-100x time faster.&lt;/p&gt;

&lt;h3 id=&#34;oop&#34;&gt;OOP&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;How prototype inheritance works? Are you aware of classical approach and with OOLO.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; In most languages, there are classes and objects. Classes inherit from other classes. In JavaScript, the inheritance is prototype-based. That means that there are no classes. Instead, an object inherits from another object. The main point is that one object can be &lt;code&gt;prototype&lt;/code&gt; of another object. That means if property isn’t found in the object - than it takes from &lt;code&gt;prototype&lt;/code&gt; object. In JavaScript this implementation is at the language level.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt; &lt;a href=&#34;http://qetr1ck-op.github.io/2014/09/15/OOP-in-prototype-style/&#34;&gt;OOP in prototype style&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Example. Make a subclass from parent class &lt;code&gt;Animal&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// parent class or abstract class
function Animal(name) {
  this.name = name;
  this.speed = 0;
}

Animal.prototype.run = function() {
  console.log(`${this.name} run!`);
}

function Rabbit() {
  /*...*/
}

/*...*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Animal(name) {
  this.name = name;
  this.speed = 0;
}

Animal.prototype.run = function() {
  console.log(`${this.name} run!`);
}

function Rabbit() {
  Animal.apply(this, arguments)
}

Rabbit.prototype = Object.create(Animal.prototype);

// optionally
Rabbit.prototype.constructor = Rabbit;

Rabbit.prototype.run = function() {
  // optionally
  Animal.prototype.run.apply(this);
  console.log(`${this.name} jumps!`);
};

var rabbit = new Rabbit(&#39;white rabbit&#39;);
rabbit.run();
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Rewrite previous example to ES6 classes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Animal {
  constructor(name) {
    this.name = name;
    this.speed = 0;
  }
  run() {
    console.log(`${this.name} run!`);
  }
}

class Rabbit extends Animal {
  constructor(name) {
    super(name)
  }
  run() {
    super.run();
    console.log(`${this.name} jumps`);
  };
}

var rabbit = new Rabbit(&#39;white rabbit&#39;);
rabbit.run();
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Difference between: &lt;code&gt;function Person(){}&lt;/code&gt;, &lt;code&gt;var person = Person()&lt;/code&gt;, and &lt;code&gt;var person = new Person()&lt;/code&gt;? What &lt;code&gt;new&lt;/code&gt; operator do?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; In the example below we define a new &amp;ldquo;class&amp;rdquo; called Person with an empty constructor. Invoke function &lt;code&gt;Person()&lt;/code&gt; will return &lt;code&gt;undefined&lt;/code&gt;. On the other hand invoking &lt;code&gt;new Person&lt;/code&gt; will return an empty object &lt;code&gt;{}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JavaScript is a prototype-based language and contains no class statement, such as is found in C++ or Java. This is sometimes confusing for programmers accustomed to languages with a class statement. Instead, JavaScript uses functions as constructors for classes. Defining a class is as easy as defining a function. In the example below we define a new class called &lt;code&gt;Person&lt;/code&gt; with an empty constructor.&lt;/p&gt;

&lt;p&gt;And the spec says, the &lt;code&gt;new&lt;/code&gt; operator uses the internal &lt;code&gt;[[Construct]]&lt;/code&gt; method, and it basically does the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Initializes a new empty object (no properties)&lt;/li&gt;
&lt;li&gt;Sets the prototype of the new object to the value of the &lt;code&gt;prototype&lt;/code&gt; property of Person.

&lt;ul&gt;
&lt;li&gt;Note: The default value of &lt;code&gt;prototype&lt;/code&gt; for a function is an object (automatically created when the function is declared) with its prototype set to &lt;code&gt;Object.prototype&lt;/code&gt; and a &lt;code&gt;constructor&lt;/code&gt; property pointing back to the function Person.&lt;/li&gt;
&lt;li&gt;Note: The terminology can be confusing. The property named &lt;code&gt;prototype&lt;/code&gt; is not the same as the prototype of the object. Only functions have the property named &amp;ldquo;prototype&amp;rdquo;, but all objects have a prototype.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Calls the function &lt;code&gt;Person&lt;/code&gt; with &lt;code&gt;this&lt;/code&gt; set to the new object, and with the supplied &lt;code&gt;arguments&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If calling the function &lt;code&gt;Person&lt;/code&gt; returns an object, this object is the result of the expression. Otherwise the newly created object is the result of the expression.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;new F&lt;/code&gt; vs &lt;code&gt;Object.create&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; &lt;code&gt;new F&lt;/code&gt; is &lt;code&gt;Object.create(F.prototype)&lt;/code&gt; with additionally running the constructor function. And giving the constructor the chance to return the actual object that should be the result of the expression instead of this. So basically &lt;code&gt;Object.create&lt;/code&gt; doesn&amp;rsquo;t execute the constructor.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Object.create&lt;/code&gt; methods allows you to easily implement differential inheritance, where objects can directly inherit from other objects.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var userB = {
  sayHello: function() {
    console.log(&#39;Hello &#39;+ this.name);
  }
};

var bob = Object.create(userB, { // object descriptor
  &#39;id&#39; : {
    value: MY_GLOBAL.nextId(),
    enumerable:true // writable:false, configurable(deletable):false by default
  },
  &#39;name&#39;: {
    value: &#39;Bob&#39;,
    enumerable: true
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dom&#34;&gt;DOM&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Is there are a difference &lt;code&gt;window&lt;/code&gt; VS &lt;code&gt;document&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;  Yes. JavaScript has a global &lt;code&gt;window&lt;/code&gt; object and everything runs under it. &lt;code&gt;document&lt;/code&gt; is a property of &lt;code&gt;window&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;window&lt;/code&gt; is global object that holds global variables, global functions, location, history everything is under it. Besides, &lt;code&gt;setTimeout&lt;/code&gt;, ajax call (&lt;code&gt;XMLHttpRequest&lt;/code&gt;), &lt;code&gt;console&lt;/code&gt; or &lt;code&gt;localStorage&lt;/code&gt; are part of window.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;document&lt;/code&gt; is also under &lt;code&gt;window&lt;/code&gt;. &lt;code&gt;document&lt;/code&gt; represents the &lt;code&gt;DOM&lt;/code&gt;,  the object oriented representation of the html markup. All the nodes are part of document. Hence you can use &lt;code&gt;getElementById&lt;/code&gt; or &lt;code&gt;addEventListener&lt;/code&gt; on document. These methods are not present in the &lt;code&gt;window&lt;/code&gt; object.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;How could you make sure to run some javaScript when DOM is ready like &lt;code&gt;$(document).ready?&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; There are four different ways:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Put your script in the last tag of html body element. DOM would be ready by the time browser hits the script tag.&lt;/li&gt;
&lt;li&gt;Place your code inside a &lt;code&gt;DOMContentLoaded&lt;/code&gt; handler. This event will be fired when DOM is completely loaded.&lt;/li&gt;
&lt;li&gt;Watch changes in the &lt;code&gt;readyState&lt;/code&gt; of the &lt;code&gt;document&lt;/code&gt;. And the last state is &lt;code&gt;&amp;quot;complete&amp;quot;&lt;/code&gt; state, you can put your code there.&lt;/li&gt;
&lt;li&gt;Use jQuery &lt;code&gt;$(document).ready&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;window.onload&lt;/code&gt; VS &lt;code&gt;document.onload&lt;/code&gt; VS &lt;code&gt;document.addEventListener(&#39;DOMContentLoaded&#39;)&lt;/code&gt;. Do they fire at the same time?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;
* &lt;code&gt;window.onload&lt;/code&gt; is fired when all page is loaded, including all resources (images, styles, iframes)
* &lt;code&gt;document.onload&lt;/code&gt; is fired when DOM (DOM tree built from markup code within the document) is ready which without external content.
* &lt;code&gt;DOMContentLoaded&lt;/code&gt; means that DOM has already been built, we can use handlers or search through the nodes, but resources such as images, styles don&amp;rsquo;t be loaded yet&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is &lt;code&gt;attribute&lt;/code&gt; similar to &lt;code&gt;property&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; We operate with DOM-properties via JS. Attributes are part of HTML markup.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;What is a property?&lt;/p&gt;

&lt;p&gt;JS objects have DOM-properties. These properties are kind of like instance variables for the particular element. As such, a property can be different types (boolean, string, etc.). Properties can be accessed as object properties: &lt;code&gt;a.href&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;What is an attribute?&lt;/p&gt;

&lt;p&gt;Attributes are in the HTML itself, rather than in the DOM. They are very similar to properties, but not quite as good. When a property is available it’s recommended that you work with properties rather than attributes.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;elem.hasAttribute(name)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;elem.getAttribute(name)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;elem.setAttribute(name, value)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;elem.removeAttribute(name)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;elem.attributes&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;What are the different ways to get an element from DOM?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; You can use the following methods in &lt;code&gt;document&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getElementById&lt;/code&gt; to get a element that has the provided Id.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getElementsByClassName&lt;/code&gt; to get a nodelist (nodelist is not an array, rather it is array-like object) by providing a class name.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getElementsByTagName&lt;/code&gt; to get a nodelist by the provided tag name.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getElementsByName&lt;/code&gt; to get a nodelist by name property&lt;/li&gt;
&lt;li&gt;&lt;code&gt;querySelector&lt;/code&gt; you will pass css style selector and this will return first matched element in the DOM.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;querySelectorAll&lt;/code&gt; will return a non-live nodelist by using depth-first pre order traversal of all the matched elements. Non-live means, any changes after selecting the elements will not be reflected.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are two more options but don&amp;rsquo;t used frequently:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getElementsByName&lt;/code&gt; returns the list of elements by the provided name of the html tag&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getElementsByTagNameNS&lt;/code&gt; returns elements with particular tag name within the provided namespace&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Fastest way to Query DOM:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; If you have an ID of an element &lt;code&gt;getElmentById&lt;/code&gt; is the fastest way to select an element. However, you should not have so many ID in you document to avoid style repetition. &lt;code&gt;getElementsByClassName&lt;/code&gt; is the second quickest way to select an element.&lt;/p&gt;

&lt;p&gt;Here is the list. As we go downwards through the list, it takes more time to select elements.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ID (#myID)&lt;/li&gt;
&lt;li&gt;Class (.myClass)&lt;/li&gt;
&lt;li&gt;Tag (div, p)&lt;/li&gt;
&lt;li&gt;Sibling (div+p, div~p)&lt;/li&gt;
&lt;li&gt;child (div&amp;gt;p)&lt;/li&gt;
&lt;li&gt;Descendant (div p)&lt;/li&gt;
&lt;li&gt;Universal (*)&lt;/li&gt;
&lt;li&gt;Attribute (input[type=&amp;ldquo;checkbox&amp;rdquo;])&lt;/li&gt;
&lt;li&gt;Pseudo (p:first-child)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Why &lt;code&gt;querySelectorAll(&#39;.my-class&#39;)&lt;/code&gt; is slower than &lt;code&gt;getElementsByClassName(&#39;my-class&#39;)&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; &lt;code&gt;querySlectorAll&lt;/code&gt; is a generic purpose method. It is optimized for different kinds of selectors. Hence it has to check whether you put a &lt;code&gt;&amp;quot;#&amp;quot;&lt;/code&gt; or &lt;code&gt;&amp;quot;.&amp;quot;&lt;/code&gt; in front of the parameter you are passing. If you are just passing a class name with &lt;code&gt;&amp;quot;.&amp;quot;&lt;/code&gt;, under the hood it uses &lt;code&gt;getElementsByClassName&lt;/code&gt; (could vary based on browser implements). Whereas if you directly uses &lt;code&gt;getElementsByClassName&lt;/code&gt; it directly uses this method and doesn&amp;rsquo;t have to go through all the initial processing of &lt;code&gt;querySelectorAll&lt;/code&gt;. Hence to search elements with a particular class name, &lt;code&gt;getElementsByClassName&lt;/code&gt; is faster than &lt;code&gt;querySelectorAll&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Why we can&amp;rsquo;t use &lt;code&gt;forEach&lt;/code&gt; or similar array methods on a &lt;code&gt;NodeList&lt;/code&gt;? How could you solve this problem?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Both &lt;code&gt;array&lt;/code&gt; and &lt;code&gt;nodeList&lt;/code&gt; have &lt;code&gt;length&lt;/code&gt; and you can loop through elements but they are not same object.&lt;/p&gt;

&lt;p&gt;Both are inherited from &lt;code&gt;Object&lt;/code&gt;. However &lt;code&gt;array&lt;/code&gt; has different &lt;code&gt;prototype&lt;/code&gt; object than &lt;code&gt;nodeList&lt;/code&gt;. &lt;code&gt;forEach&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, etc are on &lt;code&gt;array.prototype&lt;/code&gt; which doesn&amp;rsquo;t exist in the &lt;code&gt;NodeList.prototype&lt;/code&gt; object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;myArray --&amp;gt; Array.prototype --&amp;gt; Object.prototype --&amp;gt; null

myNodeList --&amp;gt; NodeList.prototype --&amp;gt; Object.prototype --&amp;gt; null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Convert &lt;code&gt;NodeList&lt;/code&gt; to an &lt;code&gt;array&lt;/code&gt;. After that you will have access to all &lt;code&gt;array.prototype&lt;/code&gt; methods.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// ES5
var myNodeList = document.querySelectorAll(&#39;.my-class&#39;);
var nodesArray = Array.prototype.slice.call(myNodeList);

//use array method on nodeList
nodesArray.forEach(function(el, idx){
  console.log(idx, el);
});

// ES6
const myNodeList = document.querySelectorAll(&#39;.my-class&#39;);

// Spread operator
[...myNodeList].forEach(cb);

// Array.from()
Array.from(myNodeList).forEach(cb);

// for...of statement
for (var el of myNodeList) cb(el);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;How would you add/remove/toggle a class to an element?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;el.classList.remove(&#39;my-class&#39;); //removing a class
el.classList.toggle(&#39;my-class&#39;);  // toggling a class
el.classList.contains(&#39;my-class&#39;); // checking whether class exists
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;How to check if element isn&amp;rsquo;t empty, without children?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (!elem.childNodes.length) { ... }

if (!elem.hasChildNodes()) { ... }

if (!elem.firstChild) { ... }

if (!elem.lastChild) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;How you would perform next operation: create element with content, add &lt;code&gt;data-foo&lt;/code&gt; attribute, append newly created element to whatever you want, then move it before some element, change text of it, remove it from DOM. How to clone an element?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Use the next methods &lt;code&gt;document.createElement(tag)&lt;/code&gt;, &lt;code&gt;el.innerHTML&lt;/code&gt;, &lt;code&gt;parent.appendChild(el)&lt;/code&gt;, &lt;code&gt;parent.insertBefore(el, someEl)&lt;/code&gt;, &lt;code&gt;parent.removeChild(el)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For clone an element we can create function or use &lt;code&gt;el.cloneNode(true)&lt;/code&gt; where &lt;code&gt;true&lt;/code&gt; means deep cloning.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;How to delete all children of element?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function removeChildren(elem) {
  try {
    elem.innerHTML = &#39;&#39;; //dont work with table cells and etc.
  } catch (e) {
    while (elem.firstChild) {
      elem.removeChild(elem.firstChild);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;createTextNode vs innerHTML&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; It depends on content. &lt;code&gt;innerHTML&lt;/code&gt; inserts content as HTML, but &lt;code&gt;createTextNode&lt;/code&gt; inserts tags as text.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is the best way to create a DOM element? Set &lt;code&gt;innherHTML&lt;/code&gt; or use &lt;code&gt;createElement&lt;/code&gt;? Do you know about &lt;code&gt;insertAdjacentHTML&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; According to jsPerf option 1 is approximately 3 times slower than option 2.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;appendChild&lt;/code&gt; does not cause a complete rebuild of the DOM or even all of the elements/nodes within the target.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;innerHTML&lt;/code&gt; does cause a complete rebuild of the content of the target element, which if you&amp;rsquo;re appending is unnecessary.&lt;/p&gt;

&lt;p&gt;Appending via &lt;code&gt;innerHTML += content&lt;/code&gt; makes the browser run through all of the nodes in the element building an HTML string to give to the JavaScript layer. Your code then appends text to it and sets innerHTML, causing the browser to drop all of the old nodes in the target, re-parse all of that HTML, and build new nodes. So in that sense, it may not be efficient. (However, parsing HTML is what browsers do and they&amp;rsquo;re really, really fast at it.)&lt;/p&gt;

&lt;p&gt;Setting &lt;code&gt;innerHTML&lt;/code&gt; does indeed invalidate any references to elements within the target element you may be holding - because those elements don&amp;rsquo;t exist anymore, you removed them and then put in new ones (that look very similar) when you set &lt;code&gt;innerHTML&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In short, if you&amp;rsquo;re appending, I&amp;rsquo;d use &lt;code&gt;appendChild&lt;/code&gt; or &lt;code&gt;insertAdjacentHTML&lt;/code&gt;. If you&amp;rsquo;re replacing, there are very valid situations where using innerHTML is a better option than creating the tree yourself via the DOM API.&lt;/p&gt;

&lt;p&gt;Finally, it&amp;rsquo;s worth mentioning &lt;code&gt;insertAdjacentHTML&lt;/code&gt;, which is a function that you can use to insert nodes and elements into or next to an element using an HTML string. You can append to an element with it: &lt;code&gt;theElement.insertAdjacentHTML(&amp;quot;beforeend&amp;quot;, &amp;quot;the HTML goes here&amp;quot;);&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is &lt;code&gt;createDocumentFragment&lt;/code&gt; and why you might use it?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; If you are changing DOM that cause expensive reflow, you can avoid it by using &lt;code&gt;documentFragment&lt;/code&gt; as it is managed in the memory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;documentFragment&lt;/code&gt; a very lightweight or minimal part of a DOM or a subtree of a DOM tree. It is very helpful when you are manipulating a part of DOM for multiple times. It becomes expensive to hit a certain portion of DOM for hundreds time. You might cause reflow for hundred times.&lt;/p&gt;

&lt;p&gt;A bad practice, you are hitting the DOM every single time:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//
var list = [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, ... ],
    el, text;
for (var i = 0; i &amp;lt; list.length; i++) {
    el = document.createElement(&#39;li&#39;);
    text = document.createTextNode(list[i]);
    el.appendChild(text);
    document.body.appendChild(el);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A good practice, you causing reflow one time:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var fragment = document.createDocumentFragment(),
    list = [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, ...],
    el, text;
for (var i = 0; i &amp;lt; list.length; i++) {
    el = document.createElement(&#39;li&#39;);
    text = document.createTextNode(list[i]);
    el.appendChild(text);
    fragment.appendChild(el);
}
document.body.appendChild(fragment);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;When would you use &amp;ldquo;document.write()&amp;rdquo; ?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; In terms of vendors supplying third parties or analytics code (like Google Analytics) it&amp;rsquo;s actually the easiest way for them to distribute such snippets.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;
  var url = &#39;http://ads.com/buyme?screen=&#39; + screen.width + &amp;quot;x&amp;quot; + screen.height;

  document.write(&#39;&amp;lt;script src=&amp;quot;&#39; + url + &#39;&amp;quot;&amp;gt;&amp;lt;/scr&#39; + &#39;ipt&amp;gt;&#39;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It keeps the scripts small&lt;/li&gt;
&lt;li&gt;They don&amp;rsquo;t have to worry about overriding already established onload events or including the necessary abstraction to add onload events safely&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s extremely compatible&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;document.write&lt;/code&gt; only works while the page is loading; If you call it after the page is done loading, it will overwrite the whole page.&lt;/p&gt;

&lt;p&gt;This effectively means you have to call it from an inline script block - And that will prevent the browser from processing parts of the page that follow. Scripts and Images will not be downloaded until the writing block is finished.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is reflow? What causes reflow? How could you reduce reflow?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; When you change size or position of an element in the page, all the elements after it has to change their position according to the changes you made. For example, if you change height on an element, all the elements under it has to move down in the page to accomodate a change in height. Hence, flow of the elements in the page is changed and this is called &lt;em&gt;reflow&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Re-flows could be very expensive and it might have a performance hit specially in the smaller devices like phone. As it might causes changes in the portion (or whole) layout of the page.&lt;/p&gt;

&lt;p&gt;The following cases causes reflow:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;change layout (geometry of the page)&lt;/li&gt;
&lt;li&gt;resize the window&lt;/li&gt;
&lt;li&gt;change height/width of any element&lt;/li&gt;
&lt;li&gt;changing font&lt;/li&gt;
&lt;li&gt;change font size&lt;/li&gt;
&lt;li&gt;move DOM element (animation)&lt;/li&gt;
&lt;li&gt;adding or removing stylesheet&lt;/li&gt;
&lt;li&gt;calculating offset height or offset width&lt;/li&gt;
&lt;li&gt;&lt;code&gt;display: none;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How to avoid: To avoid reflow, try to avoid doing things in the above list and some more in the below&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;avoid setting multiple inline style&lt;/li&gt;
&lt;li&gt;apply animation to the elements that are positioned fixed or absolute&lt;/li&gt;
&lt;li&gt;avoid tables for layout&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;More: &lt;a href=&#34;http://www.stubbornella.org/content/2009/03/27/reflows-repaints-css-performance-making-your-javascript-slow/#animations&#34;&gt;reflow and repaint: css performance makes your JS slow&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is repaint and when does this happen?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; repaint happens when you change the look of an element without changing the size and shape. This doesn&amp;rsquo;t cause reflow as geometry of the element didn&amp;rsquo;t changed.&lt;/p&gt;

&lt;p&gt;How it happens:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;change background color&lt;/li&gt;
&lt;li&gt;change text color&lt;/li&gt;
&lt;li&gt;visibility hidden&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;What is &lt;code&gt;defer&lt;/code&gt; and &lt;code&gt;async&lt;/code&gt; attribute does in a script tag?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; HTML parser will ignore &lt;code&gt;defer&lt;/code&gt; and &lt;code&gt;async&lt;/code&gt; keyword for inline script (script that does not have a src attribute).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;with &lt;code&gt;&amp;lt;script async src=&amp;quot;...&amp;quot;&amp;gt;&lt;/code&gt; browser downloads the file during HTML parsing and will pause the HTML parser to execute it when it has finished downloading&lt;/li&gt;
&lt;li&gt;with &lt;code&gt;&amp;lt;script defer src=&amp;quot;...&amp;quot;&amp;gt;&lt;/code&gt; browser downloads the file during HTML parsing and will only execute it after the parser has completed. defer scripts are also guarenteed to execute in the order that they appear in the document.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&amp;quot;1.js&amp;quot; async&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;2.js&amp;quot; async&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;//1
&amp;lt;script src=&amp;quot;big.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;small.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

//2
&amp;lt;script async src=&amp;quot;big.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script async src=&amp;quot;small.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

//3
&amp;lt;script defer src=&amp;quot;big.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script defer src=&amp;quot;small.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;events&#34;&gt;Events&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;What is event bubble? How does event flows (event phases)?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; to understand event bubble, you have to understand what happen when you click on anything on a page.&lt;/p&gt;

&lt;p&gt;The event flow model specified by DOM Level 2 Events has three phases to it:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Capture: When you clicked, browser knows a click event occurred. It starts from the &lt;code&gt;window&lt;/code&gt; (lowest level/root of your website), then goes to &lt;code&gt;document&lt;/code&gt;, then &lt;code&gt;html&lt;/code&gt; root tag, then &lt;code&gt;body&lt;/code&gt;, then &lt;code&gt;table&lt;/code&gt;&amp;hellip; its trying to reach the the as lowest level of element as possible. This is called capture phase (phase -1).&lt;/li&gt;
&lt;li&gt;Target: When browser reach the lowest level of element. In this case, you have clicked on a table cell (table data) hence target would be &lt;code&gt;td&lt;/code&gt; tag. Then browser checks whether you have any click handler attached to this element. If there is any, browser executes that click hander. This is called target phase (phase -2).
&lt;code&gt;Bubbling&lt;/code&gt;: After firing click hander attached to &lt;code&gt;td&lt;/code&gt;, browser walks toward root. One level upward and check whether there is any click handler attached with table row &lt;code&gt;tr&lt;/code&gt; element. If there is any it will execute that. Then it goes to &lt;code&gt;tbody&lt;/code&gt;, &lt;code&gt;table&lt;/code&gt;, &lt;code&gt;body&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt;, &lt;code&gt;document&lt;/code&gt;, &lt;code&gt;window&lt;/code&gt;. In this stage its moving upward and this is called event bubbling or bubbling phase (phase-3).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Event handlers with &lt;code&gt;on&amp;lt;eventName&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t know anything about capture phase.&lt;/p&gt;

&lt;p&gt;To capture on &lt;code&gt;capture&lt;/code&gt; phase need to &lt;code&gt;addEventListener(&amp;lt;eventName&amp;gt;, &amp;lt;cb&amp;gt;, true)&lt;/code&gt;, otherwise it will work by bubble phase.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Explain event delegation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Event delegation allows you to avoid adding event listeners to specific nodes, instead, the event listener is added to one parent. That event listener analyzes bubbled events to find a match on child elements.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say that we have a parent UL element with several child elements:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul id=&amp;quot;parent-list&amp;quot;&amp;gt;
  &amp;lt;li id=&amp;quot;post-1&amp;quot;&amp;gt;Item 1&amp;lt;/li&amp;gt;
  &amp;lt;li id=&amp;quot;post-2&amp;quot;&amp;gt;Item 2&amp;lt;/li&amp;gt;
  &amp;lt;li id=&amp;quot;post-3&amp;quot;&amp;gt;Item 3&amp;lt;/li&amp;gt;
  &amp;lt;li id=&amp;quot;post-4&amp;quot;&amp;gt;Item 4&amp;lt;/li&amp;gt;
  &amp;lt;li id=&amp;quot;post-...&amp;quot;&amp;gt;...&amp;lt;/li&amp;gt;
  &amp;lt;li id=&amp;quot;post-1001&amp;quot;&amp;gt;Item 1001&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s also say that something needs to happen when each child element is clicked.  You could add a separate event listener to each individual &lt;code&gt;LI&lt;/code&gt; element, but what if &lt;code&gt;LI&lt;/code&gt; elements are frequently added and removed from the list?  Adding and removing event listeners would be a nightmare, especially if addition and removal code is in different places within your app. The better solution is to add an event listener to the parent UL element.&lt;/p&gt;

&lt;p&gt;When the event bubbles up to the &lt;code&gt;UL&lt;/code&gt; element, you check the event object&amp;rsquo;s target property to gain a reference to the actual clicked node:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Get the element, add a click listener...
document.getElementById(&amp;quot;parent-list&amp;quot;).addEventListener(&amp;quot;click&amp;quot;, function(e) {
  // e.target is the clicked element!
  // If it was a list item
  if(e.target &amp;amp;&amp;amp; e.target.nodeName == &amp;quot;LI&amp;quot;) {
    // List item found!  Output the ID!
    console.log(&amp;quot;List item &amp;quot;, e.target.id.replace(&amp;quot;post-&amp;quot;, &amp;quot;&amp;quot;), &amp;quot; was clicked!&amp;quot;);
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Can you remove an event handler from an element?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; &lt;code&gt;target.removeEventListener(&#39;click&#39;, &amp;lt;handledName&amp;gt;)&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;How could you prevent a click on an anchor from going to the link? How could you stop further propagation of an event?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; &lt;code&gt;preventDefault()&lt;/code&gt; inside event handler. However, this doesn&amp;rsquo;t stop further propagation. To stop it &lt;code&gt;event.stopPropagation();&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;How to capture all click in a page?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; You can leverage event bubble to get all the clicks. As all the clicks will be bubbled up to the body.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;document.querySelector(&#39;body&#39;).addEventListener(&#39;click&#39;, function(e){
  console.log(&#39;body clicked&#39;, e.target);
});

//or
window.onclick = function(e){
  console.log(&#39;someone clicked&#39;, e.target)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ajax&#34;&gt;AJAX&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Explain AJAX in as much detail as possible&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; AJAX is a way to communicate to the server without reloading the page. Once we receive the data from the server, we can then manipulate those data and display unto certain parts of the page, this is why we don’t need to reload the page.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt; AJAX stands for Asynchronous JavaScript and XML. In a nutshell, it is the use of the &lt;code&gt;XMLHttpRequest&lt;/code&gt; object to communicate with server-side scripts. It can send as well as receive information in a variety of formats, including JSON, XML, HTML, and even text files. AJAX’s most appealing characteristic, however, is its &amp;ldquo;asynchronous&amp;rdquo; nature, which means it can do all of this without having to refresh the page&lt;/p&gt;

&lt;p&gt;Typical example for GET request with &lt;code&gt;XMLHttpRequest&lt;/code&gt;:&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/qetr1ck-op/f52380392d7f0afb4835f8257a483ff7.js&#34;&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;What is COMET? How to achieve this technique?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; he AJAX - is a &amp;ldquo;request sent - get the result,&amp;rdquo; and the COMET - is &amp;ldquo;a continuous channel through which the data come.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Comet is a Web application model that enables web servers to send data to the client without having to explicitly request it.&lt;/p&gt;

&lt;p&gt;Examples COMET-app:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Chat - man sitting and watching what others write. At the same time new messages arrive &amp;ldquo;on their own&amp;rdquo;, he should not have to press a button to refresh the chat window.&lt;/li&gt;
&lt;li&gt;Auction - a person looks at the screen and sees renewed the current bid for the goods.&lt;/li&gt;
&lt;li&gt;Editing interface - when one editor is beginning to change the document, others see the information about it. Perhaps, and collaborative editing, editors when they see each other&amp;rsquo;s changes.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;COMET techniques overview:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Polling: a simple method based on periodically polling the server.&lt;/li&gt;
&lt;li&gt;Long poll: A method by which a client opens a connection and doesn&amp;rsquo;t close it up until the event occurs. In the event occurs, the client receives a notification and then opens a connection again.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Infinite&amp;rdquo; iframe: The method is based on html document download features. It creates an invisible iframe, which reads &amp;ldquo;infinite&amp;rdquo; file. When an event occurs, a new row is added to the file. The string can be a javascript snippet.&lt;/li&gt;
&lt;li&gt;HTML5 WebSockets: specification defines an API establishing &amp;ldquo;socket&amp;rdquo; connections between a web browser and a server. In plain words: There is an persistent connection between the client and the server and both parties can start sending data at any time.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;How to work with HTTP headers in AJAX. Do we have a restriction?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; There are three methods &lt;code&gt;setRequestHeader(name, value)&lt;/code&gt;, &lt;code&gt;getResponseHeader(name)&lt;/code&gt;, &lt;code&gt;getAllResponseHeaders()&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Send JSON Object with Ajax?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Use &lt;code&gt;xhr.setRequestHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/x-www-form-urlencoded&amp;quot;)&lt;/code&gt; and &lt;code&gt;JSON.stringify(&amp;lt;object&amp;gt;)&lt;/code&gt;;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var jsonRequest = &amp;quot;json_name=&amp;quot; + JSON.stringify({name:&amp;quot;John&amp;quot;, time:&amp;quot;2pm&amp;quot;});
var xhr = new XMLHttpRequest();

xhr.open(&amp;quot;POST&amp;quot;, &amp;quot;/submit&amp;quot;);
xhr.setRequestHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/x-www-form-urlencoded&amp;quot;);
xhr.send(json_upload);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Sending POST data using an XMLHttpRequest using different encoding patterns.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; With &lt;code&gt;XMLHttpRequest&lt;/code&gt; we don&amp;rsquo;t need explicitly set header with &lt;code&gt;Content-type&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In spec are 3 types for submitting body entity:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;multipart/form-data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;text-plain&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var xhr = new XMLHttpRequest();

var body = &#39;name=&#39; + encodeURIComponent(name) +
  &#39;&amp;amp;surname=&#39; + encodeURIComponent(surname);

xhr.open(&amp;quot;POST&amp;quot;, &#39;/submit&#39;, true)
xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;)

xhr.onreadystatechange = ...;

xhr.send(body);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With &lt;code&gt;multipart/form-data&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;form name=&amp;quot;person&amp;quot;&amp;gt;
  &amp;lt;input name=&amp;quot;name&amp;quot; value=&amp;quot;John&amp;quot;&amp;gt;
  &amp;lt;input name=&amp;quot;surname&amp;quot; value=&amp;quot;Doe&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;

&amp;lt;script&amp;gt;
  var formData = new FormData(document.forms.person);

  formData.append(&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;);

  var xhr = new XMLHttpRequest();
  xhr.open(&amp;quot;POST&amp;quot;, &amp;quot;/url&amp;quot;);
  xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;multipart/form-data&#39;)
  xhr.send(formData);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;What is CORS? What techniques you know to avoid it?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;es6&#34;&gt;ES6&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;When standard was finalized?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The ES6 specification was finalized in June 2015, (hence ES2015).&lt;/p&gt;

&lt;p&gt;Future versions of the specification will follow the ES[YYYY] pattern, e.g ES2016 for ES7.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tooling&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To get ES6 working today, you need a JavaScript-to-JavaScript transpiler:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They allow you to compile code in the latest version into older versions of the language&lt;/li&gt;
&lt;li&gt;As browser support gets better, we’ll transpile ES2016 and ES2017 into ES6 and beyond&lt;/li&gt;
&lt;li&gt;We’ll need better source mapping functionality&lt;/li&gt;
&lt;li&gt;They’re the most reliable way to run ES6 source code in production today (although browsers get ES5)&lt;/li&gt;
&lt;li&gt;
Use &lt;code&gt;babel&lt;/code&gt; to transpile ES6 into ES5 for static build&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Use &lt;code&gt;babelify&lt;/code&gt; to incorporate babel into your &lt;code&gt;Gulp&lt;/code&gt;, &lt;code&gt;Grunt&lt;/code&gt;, or &lt;code&gt;npm&lt;/code&gt; run build process&lt;/p&gt;

&lt;p&gt;Use &lt;code&gt;Node.js&lt;/code&gt; v4.x.x or greater as they have decent ES6 support baked in, thanks to v8&lt;/p&gt;

&lt;p&gt;Use &lt;code&gt;babel-node&lt;/code&gt; with any version of node, as it transpiles modules into ES5&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Assignment Destructing, the Rapid Table&lt;/p&gt;

&lt;p&gt;Spread Operator and Rest Parameters&lt;/p&gt;

&lt;p&gt;Arrow Functions&lt;/p&gt;

&lt;p&gt;Template Literals&lt;/p&gt;

&lt;p&gt;Object Literals&lt;/p&gt;

&lt;p&gt;Classes&lt;/p&gt;

&lt;p&gt;Let and Const&lt;/p&gt;

&lt;p&gt;Symbols&lt;/p&gt;

&lt;p&gt;Iterators&lt;/p&gt;

&lt;p&gt;Generators&lt;/p&gt;

&lt;p&gt;Promises&lt;/p&gt;

&lt;p&gt;Maps / WeakMaps&lt;/p&gt;

&lt;p&gt;Sets / WeakSets&lt;/p&gt;

&lt;p&gt;Modules&lt;/p&gt;

&lt;p&gt;Proxy&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TODO with &lt;a href=&#34;https://ponyfoo.com/articles/es6&#34;&gt;https://ponyfoo.com/articles/es6&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;javascript-advance&#34;&gt;JavaScript: advance&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;What do you think of AMD vs CommonJS and ES6 modules?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For many years JS had a single widely accepted module format, which is to say, there was none. Everything was a global variable petulantly hanging off the window object.&lt;/p&gt;

&lt;p&gt;Dark Ages. Long ago an adhoc group formed to solve the global conflict. The fruits of this vigilante justice are known today as CommonJS. Multiple competing formats were proposed and implemented in the wild by these dashing radicals and two bright lights emerged with significant adherents: AMD and CJS.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Asynchronous Module Design&lt;/em&gt; (AMD) accounts for the async nature of JS but some felt the aesthetics were harder to read with a wrapper function.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;CommonJS&lt;/em&gt; (CJS) is synchronous, thus blocking, but generally understood to be an easier read.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// this is an AMD module
define(function () {
  return something
})

// and this is CommonJS
module.exports = something
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript vendors and concerned citizens began formally standardizing modules into the language proper. After years of thrashing, a standard module format has finally emerged with ES6.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is asynchronous programming, and why is it important in JS? Non-blocking I/O in JS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Synchronous programming means that code is executed sequentially from top-to-bottom, blocking on long-running tasks such as network requests and disk I/O.&lt;/p&gt;

&lt;p&gt;Asynchronous programming means that the engine runs in an event loop. When a blocking operation is needed, the request is started, and the code keeps running without blocking for the result. When the response is ready, an interrupt is fired, which causes an event handler to be run, where the control flow continues. In this way, a single program thread can handle many concurrent operations.&lt;/p&gt;

&lt;p&gt;Node is asynchronous by default, meaning that the server works in much the same way, waiting in a loop for a network request, and accepting more incoming requests while the first one is being handled.&lt;/p&gt;

&lt;p&gt;In JavaScript, almost all I/O is non-blocking. This includes:
* Networking requests
* DB operations
* Disk reads and writes
* User interfaces are asynchronous by nature, and spend most of their time waiting for user input to interrupt the event loop and trigger event handlers&lt;/p&gt;

&lt;p&gt;The single thread of execution asks the runtime to perform an operation, providing a callback function and then moves on to do something else. When the operation has been completed, a message is enqueued along with the provided callback function. At some point in the future, the message is dequeued and the callback fired.&lt;/p&gt;

&lt;p&gt;Let’s compare two bits of code that make HTTP requests to &lt;code&gt;www.google.com&lt;/code&gt; and output the response to console with &lt;code&gt;Node.js&lt;/code&gt; and the &lt;code&gt;Request&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;request(&#39;http://www.google.com&#39;, function(error, response, body) {
  console.log(body);
});

console.log(&#39;Done!&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;The request function is executed, passing an anonymous function as a callback to execute when a response is available sometime in the future.&lt;/li&gt;
&lt;li&gt;“Done!” is immediately output to the console&lt;/li&gt;
&lt;li&gt;Sometime in the future, the response comes back and our callback is executed, outputting its body to the console&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;Do request two parallel request to &lt;code&gt;http://httpbin.org/ip&lt;/code&gt; and &lt;code&gt;http://httpbin.org/user-agent&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Promise.all([fetch(&#39;http://httpbin.org/ip&#39;), fetch(&#39;http://httpbin.org/user-agent&#39;)])
  .then(resps =&amp;gt; {
    return Promise.all([resps[0].json(), resps[1].json()])
  })
  .then((jsons) =&amp;gt; console.log(jsons))
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Resolve promises one after another (i.e. in sequence)?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function runSerial() {
    return Promise.resolve()
        .then(task1)
        .then(task2)
        .then(() =&amp;gt; {
            console.log(&amp;quot; ---- done ----&amp;quot;);
        });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With dynamic length of tasks&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let urls = [&#39;guest.json&#39;, &#39;user.json&#39;];
let results = [];
let chain = Promise.resolve();

urls.forEach(function(url) {
  chain = chain
    .then(() =&amp;gt; httpGet(url))
    .then((result) =&amp;gt; {
      results.push(result);
    });
});

chain.then(() =&amp;gt; {
  console.log(results);
});

// with reduce
urls
  .reduce((promise, url) =&amp;gt; {
    return promise.then(() =&amp;gt; httpGet(url)).then((json) =&amp;gt; results.push(json));
  }, Promise.resolve())
  .then(() =&amp;gt; {
    console.log(results);
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The Event Loop&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The decoupling of the caller from the response allows for the JavaScript runtime to do other things while waiting for your asynchronous operation to complete and their callbacks to fire. But where in memory do these callbacks live – and in what order are they executed? What causes them to be called?&lt;/p&gt;

&lt;p&gt;JavaScript runtimes contain a message queue which stores a list of messages to be processed and their associated callback functions. These messages are queued in response to external events (such as a mouse being clicked or receiving the response to an HTTP request) given a callback function has been provided. If, for example a user were to click a button and no callback function was provided – no message would have been enqueued.&lt;/p&gt;

&lt;p&gt;In a loop, the queue is polled for the next message (each poll referred to as a “tick”) and when a message is encountered, the callback for that message is executed.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.appsdev.is.ed.ac.uk/blog/wp-content/uploads/2015/03/Event-loop.png&#34; alt=&#34;Event Loop&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Macrotasks and Microtasks&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Take this little bit of JavaScript:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(&#39;script start&#39;)

const interval = setInterval(() =&amp;gt; {  
  console.log(&#39;setInterval&#39;)
}, 0)

setTimeout(() =&amp;gt; {  
  console.log(&#39;setTimeout 1&#39;)
  Promise.resolve().then(() =&amp;gt; {
    console.log(&#39;promise 3&#39;)
  }).then(() =&amp;gt; {
    console.log(&#39;promise 4&#39;)
  }).then(() =&amp;gt; {
    setTimeout(() =&amp;gt; {
      console.log(&#39;setTimeout 2&#39;)
      Promise.resolve().then(() =&amp;gt; {
        console.log(&#39;promise 5&#39;)
      }).then(() =&amp;gt; {
        console.log(&#39;promise 6&#39;)
      }).then(() =&amp;gt; {
        clearInterval(interval)
      })
    }, 0)
  })
}, 0)

Promise.resolve().then(() =&amp;gt; {  
  console.log(&#39;promise 1&#39;)
}).then(() =&amp;gt; {
  console.log(&#39;promise 2&#39;)
})
console.log(&#39;script end&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;script start
script end
promise 1  
promise 2  
setInterval  
setTimeout 1  
promise 3  
promise 4  
setInterval  
setTimeout 2  
setInterval  
promise 5  
promise 6  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To understand this you need to know how the event loop handles macrotasks and microtasks.&lt;/p&gt;

&lt;p&gt;macrotasks: &lt;code&gt;setTimeout&lt;/code&gt;, &lt;code&gt;setInterval&lt;/code&gt;, &lt;code&gt;setImmediate&lt;/code&gt;, I/O, UI rendering
microtasks: &lt;code&gt;process.nextTick&lt;/code&gt;, &lt;code&gt;Promises&lt;/code&gt;, &lt;code&gt;Object.observe&lt;/code&gt;, &lt;code&gt;MutationObserver&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/&#34;&gt;A great post&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is the difference between &amp;ldquo;classical inheritance&amp;rdquo; and &amp;ldquo;prototypal inheritance&amp;rdquo;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Class Inheritance: instances inherit from classes (like a blueprint — a description of the class), and create sub-class relationships: hierarchical class taxonomies. Instances are typically instantiated via constructor functions with the &lt;code&gt;new&lt;/code&gt; keyword. Class inheritance may or may not use the &lt;code&gt;class&lt;/code&gt; keyword from ES6.&lt;/p&gt;

&lt;p&gt;Prototypal Inheritance: instances inherit directly from other objects. Instances are typically instantiated via factory functions or &lt;code&gt;Object.create()&lt;/code&gt;. Instances may be composed from many different objects, allowing for easy selective inheritance.&lt;/p&gt;

&lt;p&gt;Good to hear:
* Classes: create tight coupling or hierarchies/taxonomies.
* Prototypes: mentions of concatenative inheritance, prototype delegation, functional inheritance, object composition.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What are the pros and cons of functional programming vs object-oriented programming?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;OOP Pros: It’s easy to understand the basic concept of objects and easy to interpret the meaning of method calls. OOP tends to use an imperative style rather than a declarative style, which reads like a straight-forward set of instructions for the computer to follow.&lt;/p&gt;

&lt;p&gt;OOP Cons: OOP Typically depends on shared state. Objects and behaviors are typically tacked together on the same entity, which may be accessed at random by any number of functions with non-deterministic order, which may lead to undesirable behavior such as race conditions.&lt;/p&gt;

&lt;p&gt;FP Pros: Using the functional paradigm, programmers avoid any shared state or side-effects, which eliminates bugs caused by multiple functions competing for the same resources. With features such as the availability of point-free style (aka tacit programming), functions tend to be radically simplified and easily recomposed for more generally reusable code compared to OOP.&lt;/p&gt;

&lt;p&gt;FP Cons: Over exploitation of FP features such as point-free style and large compositions can potentially reduce readability because the resulting code is often more abstractly specified, more terse, and less concrete.
More people are familiar with OO and imperative programming than functional programming, so even common idioms in functional programming can be confusing to new team members.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What does &amp;ldquo;favor object composition over class inheritance&amp;rdquo; mean?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is a quote from &amp;ldquo;Design Patterns: Elements of Reusable Object-Oriented Software&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Object composition is a way to combine simple objects or data types into more complex ones. It means that code reuse should be achieved by assembling smaller units of functionality into new objects instead of inheriting from classes and creating object taxonomies.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { a, b, c } from &#39;components&#39;;
composedObject = Object.assign({}, a, b, c);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Good to hear:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Avoid class hierarchies.&lt;/li&gt;
&lt;li&gt;Avoid brittle base class problem.&lt;/li&gt;
&lt;li&gt;Avoid tight coupling.&lt;/li&gt;
&lt;li&gt;Avoid rigid taxonomy (forced is-a relationships that are eventually wrong for new use cases).&lt;/li&gt;
&lt;li&gt;Avoid the gorilla banana problem (“what you wanted was a banana, what you got was a gorilla holding the banana, and the entire jungle”).&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;What are two-way data binding and one-way data flow, and how are they different?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Two way data binding means that UI fields are bound to model data dynamically such that when a UI field changes, the model data changes with it and vice-versa.&lt;/p&gt;

&lt;p&gt;One way data flow means that the model is the single source of truth. Changes in the UI trigger messages that signal user intent to the model (or “store” in React). Only the model has the access to change the app’s state. The effect is that data always flows in a single direction, which makes it easier to understand.&lt;/p&gt;

&lt;p&gt;One way data flows are deterministic, whereas two-way binding can cause side-effects which are harder to follow and understand.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Good to hear:&lt;/strong&gt;
React is the new canonical example of one-way data flow, so mentions of React are a good signal. Cycle.js is another popular implementation of uni-directional data flow.
Angular is a popular framework which uses two-way binding.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What are the pros and cons of monolithic vs microservice architectures?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A monolithic architecture means that your app is written as one cohesive unit of code whose components are designed to work together, sharing the same memory space and resources.&lt;/p&gt;

&lt;p&gt;A microservice architecture means that your app is made up of lots of smaller, independent applications capable of running in their own memory space and scaling independently from each other across potentially many separate machines.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Good to hear:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Monolithic Pros: The major advantage of the monolithic architecture is that most apps typically have a large number of cross-cutting concerns, such as logging, rate limiting, and security features such audit trails and DOS protection.&lt;/p&gt;

&lt;p&gt;When everything is running through the same app, it’s easy to hook up components to those cross-cutting concerns.&lt;/p&gt;

&lt;p&gt;Monolithic cons: Monolithic app services tend to get tightly coupled and entangled as the application evolves, making it difficult to isolate services for purposes such as independent scaling or code maintainability.&lt;/p&gt;

&lt;p&gt;Monolithic architectures are also much harder to understand, because there may be dependencies, side-effects, and magic which are not obvious when you’re looking at a particular service or controller.&lt;/p&gt;

&lt;p&gt;Microservice pros: Microservice architectures are typically better organized, since each microservice has a very specific job, and is not concerned with the jobs of other components. Decoupled services are also easier to recompose and reconfigure to serve the purposes of different apps (for example, serving both the web clients and public API).&lt;/p&gt;

&lt;p&gt;They can also have performance advantages depending on how they’re organized because it’s possible to isolate hot services and scale them independent of the rest of the app.&lt;/p&gt;

&lt;p&gt;Microservice cons: As you’re building a new microservice architecture, you’re likely to discover lots of cross-cutting concerns that you did not anticipate at design time. A monolithic app could establish shared magic helpers or middleware to handle such cross-cutting concerns without much effort.&lt;/p&gt;

&lt;h2 id=&#34;markup&#34;&gt;Markup&lt;/h2&gt;

&lt;h3 id=&#34;html&#34;&gt;HTML&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;What is doctype? Why do u need it?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; &lt;code&gt;doctype&lt;/code&gt; is an instruction to the browser to inform about the version of html document and how browser should render it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;It ensures how element should be displayed on the page by most of the browser. And it also makes browser&amp;rsquo;s life easier. otherwise, browser will guess and will go to quirks mode. Moreover, &lt;code&gt;doctype&lt;/code&gt; is required to validate markup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Difference between standard/strict mode and quirks mode?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; quirks mode in browser allows u to render page for as old browsers. This is for backward compatibility.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is the use of &lt;code&gt;data-&lt;/code&gt; attribute?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; allow you to store extra information/data in the DOM and allows to write valid html with embedded private data. You can easily access data attribute by using JS.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;myDiv&amp;quot; data-user=&amp;quot;jsDude&amp;quot; data-list-size=&amp;quot;5&amp;quot; data-maxage=&amp;quot;180&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;What is the difference between &lt;code&gt;span&lt;/code&gt; and &lt;code&gt;div&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; &lt;code&gt;div&lt;/code&gt; is a block element, &lt;code&gt;span&lt;/code&gt; is inline.&lt;/p&gt;

&lt;p&gt;This means that to use them semantically, divs should be used to wrap sections of a document, while spans should be used to wrap small portions of text, images, etc.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When should you use section, div or article?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; To decide which of these three elements is appropriate, choose the first suitable option:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Would the enclosed content would make sense on it’s own in a feed reader? If so use &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Is the enclosed content related? If so use &lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Finally if there’s no semantic relationship use &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;What is &amp;ldquo;Semantic HTML?&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Semantic HTML is a coding style where the tags embody what the text is meant to convey.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In Semantic HTML, tags like &lt;code&gt;&amp;lt;b&amp;gt;&amp;lt;/b&amp;gt;&lt;/code&gt; for bold, and &lt;code&gt;&amp;lt;i&amp;gt;&amp;lt;/i&amp;gt;&lt;/code&gt; for italic should not be used, reason being they just represent formatting, and provide no indication of meaning or structure. The semantically correct thing to do is use &lt;code&gt;&amp;lt;strong&amp;gt;&amp;lt;/strong&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;em&amp;gt;&amp;lt;/em&amp;gt;&lt;/code&gt;. These tags will have the same bold and italic effects, while demonstrating meaning and structure (emphasis in this case).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What are some new HTML5 markup elements?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;There are &lt;a href=&#34;https://www.w3.org/TR/html-markup/bdi.html#bdi&#34;&gt;several&lt;/a&gt;: &lt;article&gt;, &lt;aside&gt;, &lt;bdi&gt;, &lt;command&gt;, &lt;details&gt;, &lt;figure&gt;, &lt;figcaption&gt;, &lt;summary&gt;, &lt;header&gt;, &lt;footer&gt;, &lt;hgroup&gt;, &lt;mark&gt;, &lt;meter&gt;, &lt;nav&gt;, &lt;progress&gt;, &lt;ruby&gt;, &lt;rt&gt;, &lt;section&gt;, &lt;time&gt;, and &lt;wpr&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What are the new media-related elements in HTML5?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HTML5 has strong support for media. There are now special &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; tags. There are additional A/V support tags as well: &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; is a container for 3rd party applications.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is the difference between &lt;code&gt;SVG&lt;/code&gt; and &lt;code&gt;Canvas&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SVG&lt;/code&gt; is a document format for scalable vector graphics.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Canvas&lt;/code&gt; is a javascript API for drawing vector graphics to a bitmap of a specific size.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SVG is XML based, which means that every element is available within the SVG DOM. You can attach JavaScript event handlers for an element.&lt;/p&gt;

&lt;p&gt;With SVG you can view, save and edit the file in many different tools.&lt;/p&gt;

&lt;p&gt;In SVG, each drawn shape is remembered as an object. If attributes of an SVG object are changed, the browser can automatically re-render the shape.&lt;/p&gt;

&lt;p&gt;Canvas is rendered pixel by pixel. In canvas, once the graphic is drawn, it is forgotten by the browser. If its position should be changed, the entire scene needs to be redrawn, including any objects that might have been covered by the graphic.&lt;/p&gt;

&lt;p&gt;Canvas:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pixel based&lt;/li&gt;
&lt;li&gt;Single HTML element.(Inspect element in Developer tool. You can see only canvas tag)&lt;/li&gt;
&lt;li&gt;Modified through script only&lt;/li&gt;
&lt;li&gt;Event model/user interaction is granular (x,y)&lt;/li&gt;
&lt;li&gt;Performance is better with smaller surface, a larger number of objects (&amp;gt;10k), or both&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SVG:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Shape based&lt;/li&gt;
&lt;li&gt;Multiple graphical elements, which become part of the SVG DOM&lt;/li&gt;
&lt;li&gt;Modified through script and CSS&lt;/li&gt;
&lt;li&gt;Event model/user interaction is abstracted (rect, path)&lt;/li&gt;
&lt;li&gt;Performance is better with smaller number of objects (&amp;lt;10k), a larger surface, or both&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Describe the difference between &lt;code&gt;cookies&lt;/code&gt;, &lt;code&gt;sessionStorage&lt;/code&gt;, and &lt;code&gt;localStorage&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; &lt;code&gt;localStorage&lt;/code&gt;, &lt;code&gt;sessionStorage&lt;/code&gt; and &lt;code&gt;cookies&lt;/code&gt; are all client storage solutions.&lt;/p&gt;

&lt;p&gt;Cookies are small text files that websites place in a browser for tracking or login purposes. Meanwhile, &lt;code&gt;localStorage&lt;/code&gt; and &lt;code&gt;sessionStorage&lt;/code&gt; are new objects, both of which are storage specifications but vary in scope and duration. Of the two, &lt;code&gt;localStorage&lt;/code&gt; is permanent and website-specific whereas &lt;code&gt;sessionStorage&lt;/code&gt; only lasts as long as the duration of the longest open tab.&lt;/p&gt;

&lt;p&gt;You can save to &lt;code&gt;localStorage&lt;/code&gt; and &lt;code&gt;sessionStorage&lt;/code&gt; only primitives, for object you need you use &lt;code&gt;JSON.stringify1&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;css&#34;&gt;CSS&lt;/h3&gt;

&lt;h2 id=&#34;general-website-optimization-questions&#34;&gt;General Website Optimization Questions&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;How do you optimize a website’s assets?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; There are a &lt;a href=&#34;https://www.sitepoint.com/web-site-optimization-steps/&#34;&gt;number of answers&lt;/a&gt; to this question: File concatenation, file compression, CDN Hosting, offloading assets, re-organizing and refining code, etc.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What are ways to reduce page load time?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Again there are &lt;a href=&#34;https://blog.crazyegg.com/2013/12/11/speed-up-your-website/&#34;&gt;many answers&lt;/a&gt; here: Reduce image sizes, remove unnecessary widgets, HTTP compression, put CSS at the top and script references at the bottom or in external files, reduce lookups, minimize redirects, caching, etc.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What kind of things must you be wary of when design or developing for multilingual sites?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Another problem with &lt;a href=&#34;https://www.nomensa.com/blog/2010/7-tips-for-multi-lingual-website-accessibility&#34;&gt;many solutions&lt;/a&gt;: setting the default language, using Unicode encoding, using the &lt;code&gt;lang&lt;/code&gt; attribute, being aware of standard font sizes and text direction, and language word length (may affect layout).&lt;/p&gt;

&lt;h1 id=&#34;technologies&#34;&gt;Technologies&lt;/h1&gt;

&lt;h2 id=&#34;js-framework&#34;&gt;JS Framework&lt;/h2&gt;

&lt;h3 id=&#34;angularjs&#34;&gt;AngularJS&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;List at least three ways to communicate between modules of your application using core AngularJS functionality.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; There are at least three idiomatic way to achieve this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Using services&lt;/li&gt;
&lt;li&gt;Using events&lt;/li&gt;
&lt;li&gt;Directly between controllers, using &lt;code&gt;ControllerAs&lt;/code&gt;, or other forms of inheritance&lt;/li&gt;
&lt;li&gt;By assigning models on &lt;code&gt;$rootScope&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Directly between controllers, using &lt;code&gt;$parent&lt;/code&gt;, &lt;code&gt;$$childHead&lt;/code&gt;, &lt;code&gt;$$nextSibling&lt;/code&gt;, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Which means of communication between modules of your application are easily testable?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; The big deal is in DI pattern.&lt;/p&gt;

&lt;p&gt;Using a &lt;code&gt;service&lt;/code&gt; is definitely easy to test. Services are injected, and in a test either a real &lt;code&gt;service&lt;/code&gt; can be used or it can be mocked.&lt;/p&gt;

&lt;p&gt;Events can be tested. In unit testing controllers, they usually are instantiated. For testing events on &lt;code&gt;$rootScope&lt;/code&gt;, it must be injected into the test.&lt;/p&gt;

&lt;p&gt;For testing direct &lt;code&gt;communication&lt;/code&gt; between &lt;code&gt;controller&lt;/code&gt;s, the expected results should probably be mocked. Otherwise, controllers would need to be manually instantiated to have the right context.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The most popular e2e testing tool for AngularJS is Protractor. Describe how e2e testing of AngularJS applications work?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The e2e tests are executed against a running app, that is a fully initialized system. They most often spawn a browser instance and involve the actual input of commands through the user interface. The written code is evaluated by an automation program, such as a Selenium server (webdriver). That program sends commands to a browser instance, then evaluates the visible results and reports back to the user.&lt;/p&gt;

&lt;p&gt;The assertions are handled by another library, for Protractor (end-to-end) / Karma (unit tests) the default is Jasmine.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What are the basic steps to unit test an AngularJS filter?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;Inject the module that contains the filter.&lt;/li&gt;
&lt;li&gt;Provide any mocks that the filter relies on.&lt;/li&gt;
&lt;li&gt;Get an instance of the filter using $filter(&amp;lsquo;yourFilterName&amp;rsquo;).&lt;/li&gt;
&lt;li&gt;Assert your expectations.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;describe(&#39;Filter: myFltr&#39;, function () {
  var myFltr;

  beforeEach(function () {
    // Load the filters&#39;s module
    module(&#39;myApp&#39;);

    // Provide any mocks needed
    module(function ($provide) {
      //$provide.value(&#39;Name&#39;, new MockName());
    });

    // Inject in angular constructs otherwise,
    // you would need to inject these into each test
    inject(function ($filter) {
      myFltr = $filter(&#39;myFltr&#39;);
    });
  });

  it(&#39;should exist&#39;, function () {
    expect(!!myFltr).toBe(true);
  });

  describe(&#39;when evaluating an expression&#39;, function () {
    it(&#39;should return the expected output&#39;, function () {
      var text = &#39;AngularJS&#39;;
      expect(myFltr(text)).toBe(&#39;my filter: &#39; + text);
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;When a scope is terminated, “destroy” events are fired. What are they used for, and why are there two?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The first one is an AngularJS event, “$destroy” can be used by AngularJS scopes where they are accessible, such as in controllers or link functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;scope.$on(‘$destroy’, function () {
  // handle the destroy, i.e. clean up.
});

// in 1.5.x
$onDestroy() {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The jqLite / jQuery event is called whenever a node is removed, which may just happen without scope teardown:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;element.on(‘$destroy’, function () {
  // respectful jQuery plugins already have this handler.
  // angular.element(document.body).off(‘someCustomEvent’);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;How do you reset a &lt;code&gt;$timeout&lt;/code&gt;, and disable a &lt;code&gt;$watch()&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; The key to both is assigning the result of the function to a variable.&lt;/p&gt;

&lt;p&gt;To cleanup the timeout, just &lt;code&gt;.cancel()&lt;/code&gt; it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var customTimeout = $timeout(function () {
  // arbitrary code
}, 55);

$timeout.cancel(customTimeout);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same applies to &lt;code&gt;$interval()&lt;/code&gt;. To disable a watch, just call it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var deregisterWatchFn = $rootScope.$watch(‘someGloballyAvailableProperty’, function (newVal) {
  if (newVal) {
    // we invoke that deregistration function, to disable the watch
    deregisterWatchFn();
    ...
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Name and describe the phases of a directive definition function execution, or describe how directives are instantiated.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Each directive undergoes something similar to a life cycle as AngularJS compiles and links the DOM. The directive lifecycle begins and ends within the AngularJS bootstrapping process, before the page is rendered.&lt;/p&gt;

&lt;p&gt;In a directive’s life cycle, there are four distinct functions that can execute if they are defined. Each enables the developer to control and customize the directive at different points of the life cycle.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;compile&lt;/code&gt; function allows the directive to manipulate the DOM before it is compiled and linked thereby allowing it to add/remove/change directives, as well as, add/remove/change other DOM elements.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;controller&lt;/code&gt; function facilitates directive communication. Sibling and child directives can request the controller of their siblings and parents to communicate information.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;pre-link&lt;/code&gt; function allows for private &lt;code&gt;$scope&lt;/code&gt; manipulation before the &lt;code&gt;post-link&lt;/code&gt; process begins.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;post-link&lt;/code&gt; method is the primary workhorse method of the directive.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;.directive(&amp;quot;directiveName&amp;quot;,function () {
  return {
    controller: function() {
      // controller code here...
    },
    compile: {
      // compile code here...
      return {
        pre: function() {
          // pre-link code here...
        },
        post: function() {
          // post-link code here...
        }
      };
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Commonly, not all of the functions are needed. In most circumstances, developers will simply create a &lt;code&gt;controller&lt;/code&gt; and &lt;code&gt;link&lt;/code&gt; (which refers to &lt;code&gt;post-link&lt;/code&gt;) function following the pattern below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;.directive(&amp;quot;directiveName&amp;quot;,function () {
  return {
    controller: function() {
      // controller code here...
    },

    link: function() {
      // post-link code here...
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More &lt;a href=&#34;https://www.toptal.com/angular-js/angular-js-demystifying-directives&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;How does interpolation, e.g. &lt;code&gt;{% raw %}{{ someModel }}{% endraw %}&lt;/code&gt;, actually works?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;During the compilation process the &lt;code&gt;compiler&lt;/code&gt; uses the &lt;code&gt;$interpolate&lt;/code&gt; service to see if text nodes and element attributes contain interpolation markup with embedded expressions.&lt;/p&gt;

&lt;p&gt;If that is the case, the compiler adds watches on the computed interpolation function, which will update the corresponding text nodes or attribute values as part of the normal digest cycle.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;How does the digest phase work?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In a nutshell, on every digest cycle all scope models are compared against their previous values. That is dirty checking. If change is detected, the watches set on that model are fired. Then another digest cycle executes, and so on until all models are stable.&lt;/p&gt;

&lt;p&gt;As long as core directives are used, we don’t need to worry, but when external code changes models the digest cycle needs to be called manually. Usually to do that, &lt;code&gt;$apply()&lt;/code&gt;, &lt;code&gt;$digest()&lt;/code&gt;, &lt;code&gt;$timeout()&lt;/code&gt;, &lt;code&gt;$evalAsync()&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;List a few ways to improve performance in an AngularJS app&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The first one can be enabled through the &lt;code&gt;$compileProvider&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;.config(function ($compileProvider) {
  $compileProvider.debugInfoEnabled(false);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Call this method to enable/disable various debug runtime information in the compiler such as adding binding information and a reference to the current scope on to DOM elements. If enabled, the compiler will add the following to DOM elements that have been bound to the scope&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ng-binding&lt;/code&gt; CSS class&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$binding&lt;/code&gt; data property containing an array of the binding expressions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using one-time binding where possible. Those bindings are set, e.g. in &lt;code&gt;{ { ::someModel } }&lt;/code&gt; interpolations by prefixing the model with two colons. In such a case, no watch is set and the model is ignored during digest.&lt;/p&gt;

&lt;p&gt;Making $httpProvider use applyAsync:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myApp.config(function ($httpProvider) {
  $httpProvider.useApplyAsync(true);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That’s it! If the application now receives multiple &lt;code&gt;$http&lt;/code&gt; responses at around the same time, this is what happens (a bit simplified though):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The call’s promise is pushed into a queue&lt;/li&gt;
&lt;li&gt;An asynchronous &lt;code&gt;$apply&lt;/code&gt; is scheduled in case there’s no one scheduled yet, by telling the browser to execute &lt;code&gt;setTimeout()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Once timed out, the queue is flushed and the actual&lt;code&gt;$apply&lt;/code&gt; is triggered&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;setTimeout()&lt;/code&gt; is called with a 0 delay which causes an actual delay of around 10 milliseconds depending on the browser. That means, if our three asynchronous calls return at around the same time (somewhere inside that particular timeout delay), they get resolve with a single &lt;code&gt;$digest&lt;/code&gt; cycle instead of three which speeds up our application.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is $rootScope and how does it relate to $scope?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;$rootScope&lt;/code&gt; is the parent object of all &lt;code&gt;$scope&lt;/code&gt; Angular objects created in a web page.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is the difference between &amp;ldquo;ng-show&amp;rdquo;/&amp;ldquo;ng-hide&amp;rdquo; and &amp;ldquo;ng-if&amp;rdquo; directives?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;ng-show&lt;/code&gt;/&lt;code&gt;ng-hide&lt;/code&gt; will always insert the DOM element, but will display/hide it based on the condition.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ng-if&lt;/code&gt; will not insert the DOM element until the condition is not fulfilled.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ng-if&lt;/code&gt; is better when we needed the DOM to be loaded conditionally, as it will help load page bit faster compared to &lt;code&gt;ng-show&lt;/code&gt;/&lt;code&gt;ng-hide&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Where should we implement the DOM manipulation in AngularJS?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In the directives. DOM Manipulations should not exist in controllers, services or anywhere else but in directives.&lt;/p&gt;

&lt;p&gt;Otherwise it&amp;rsquo;s:
* It is not reusable
* It is not testable
* It include css hard coded selectors dependencies&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is it a good or bad practice to use AngularJS together with jQuery?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;jQuery takes a traditional imperative approach to manipulating the DOM. In an imperative approach, it is up to the programmer to express the individual steps leading up to the desired outcome. What do I mean by this? So if we want an action to occur when a user types say 150 characters into an input, in jQuery we would say, &amp;ldquo;every time the user hits a key, check how many characters are in the input, if it exceeds 150 characters, do the action.&amp;rdquo; Every step is addressed along the way.&lt;/p&gt;

&lt;p&gt;AngularJS however takes a declarative approach to DOM manipulation. Here instead of worrying about all of the step by step details regarding how to do the desired outcome, AngularJS abstracts that and allows you to just say what you want done, in this case, &amp;ldquo;AngularJS, when the state of the input is at 150 characters, do this.&amp;rdquo; We are just declaring what we want and AngularJS worries about the rest, taking care of everything for us.&lt;/p&gt;

&lt;p&gt;It might seem like I&amp;rsquo;m just splitting hairs here, but it&amp;rsquo;s really an important distinction. AngularJS wants you basing your actions around the data models you create. It&amp;rsquo;s how the entire framework works and how your applications will be structured.&lt;/p&gt;

&lt;p&gt;To simply begin writing side scripts in jQuery where you are plucking out elements and setting up side event listeners just goes against the AngularJS approach in my opinion.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you were to migrate from Angular 1.4 to Angular 1.5, what is the main thing that would need refactoring?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Changing &lt;code&gt;.directive&lt;/code&gt; to &lt;code&gt;.component&lt;/code&gt; to adapt to the new Angular 1.5 components. More about &lt;a href=&#34;http://qetr1ck-op.github.io/2016/07/22/Exploring-AngularJS-1-5-component-method/&#34;&gt;.component approach&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lifecycle hooks in Angular 1.5&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$onInit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$postLink&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$onChanges&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$onDestroy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;More in &lt;a href=&#34;https://toddmotto.com/angular-1-5-lifecycle-hooks&#34;&gt;awesome post&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;How would you specify that a scope variable should have one-time binding only?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;By using &lt;code&gt;::model.property&lt;/code&gt; in front of it. This allows the check if the candidate is aware of the available variable bindings in AngularJS.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is the difference between one-way binding and two-way binding?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;One way binding implies that the scope variable in the html will be set to the first value its model is bound to (i.e. assigned to).&lt;/p&gt;

&lt;p&gt;Two way binding implies that the scope variable will change it’s value everytime its model is assigned to a different value&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is the role of services in AngularJS and name any services made available by default?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Services are objects that provide separation of concerns to an AngularJS app.&lt;/li&gt;
&lt;li&gt;Services can be created using a factory method or a service method.&lt;/li&gt;
&lt;li&gt;Services are singleton components. All components of the application (into which the service is injected) will work with single instance of the service.&lt;/li&gt;
&lt;li&gt;Allows developing of business logic without depending on the View logic which will work with it.&lt;/li&gt;
&lt;li&gt;A typical service can be injected into another service or into an Controller.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Few of the inbuilt services in AngularJS are:
– the &lt;code&gt;$http&lt;/code&gt; service: The &lt;code&gt;$http&lt;/code&gt; service is a core Angular service that facilitates communication with the remote HTTP servers via the browser’s XMLHttpRequest object or via JSONP
– the &lt;code&gt;$log&lt;/code&gt; service: Simple service for logging. Default implementation safely writes the message into the browser’s console
– the &lt;code&gt;$anchorScroll&lt;/code&gt;: it scrolls to the element related to the specified hash or (if omitted) to the current value of &lt;code&gt;$location.hash()&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What are Providers and when to use them?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Each web application you build is composed of objects that collaborate to get stuff done. These objects need to be instantiated and wired together for the app to work. In Angular apps most of these objects are instantiated and wired together automatically by the &lt;code&gt;$injector&lt;/code&gt; service.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;$injector&lt;/code&gt; creates two types of objects, &lt;em&gt;services&lt;/em&gt; and &lt;em&gt;specialized objects&lt;/em&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Services are objects whose API is defined by the developer writing the service.&lt;/li&gt;
&lt;li&gt;Specialized objects conform to a specific Angular framework API. These objects are one of controllers, directives, filters or animations.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The injector needs to know how to create these objects. You tell it by registering a &amp;ldquo;recipe&amp;rdquo; for creating your object with the injector. There are five recipe types.&lt;/p&gt;

&lt;p&gt;The most verbose, but also the most comprehensive one is a &lt;code&gt;Provider&lt;/code&gt; recipe. The remaining four recipe types — &lt;code&gt;Value&lt;/code&gt;, &lt;code&gt;Factory&lt;/code&gt;, &lt;code&gt;Service&lt;/code&gt; and &lt;code&gt;Constant&lt;/code&gt; — are just syntactic sugar on top of a provider recipe.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Provider&lt;/code&gt; recipe is the core recipe type and all the other recipe types are just syntactic sugar on top of it. It is the most verbose recipe with the most abilities, but for most services it&amp;rsquo;s overkill.&lt;/p&gt;

&lt;p&gt;When to use?&lt;/p&gt;

&lt;p&gt;You should use the Provider recipe only when you want to expose an API for application-wide configuration that must be made before the application starts. This is usually interesting only for reusable services whose behavior might need to vary slightly between applications.&lt;/p&gt;

&lt;p&gt;The Provider recipe is syntactically defined as a custom type that implements a &lt;code&gt;$get&lt;/code&gt; method. This method is a factory function just like the one we use in the Factory recipe. In fact, if you define a Factory recipe, an empty Provider type with the $get method set to your factory function is automatically created under the hood.&lt;/p&gt;

&lt;p&gt;More in &lt;a href=&#34;https://docs.angularjs.org/guide/providers&#34;&gt;official docs&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;fundamentals&#34;&gt;Fundamentals&lt;/h1&gt;

&lt;h2 id=&#34;data-structure-and-algorithm&#34;&gt;Data Structure and algorithm&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Binary search&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A binary search tree is a great place to store data in an ordered way to allow for an easy search for specific information.
It works by comparing the target value to the midpoint of the array; if they are not equal, the lower or upper half of the array is eliminated depending on the result and the search is repeated until the position of the target value is found.&lt;/p&gt;

&lt;p&gt;The basic algorithm, then, can be described as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If currentValue equals value, you’re done.&lt;/li&gt;
&lt;li&gt;If value is less than currentValue, go left. Go to step 1.&lt;/li&gt;
&lt;li&gt;If value is greater than currentValue, go right. Go to step 1.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Binary search is intuitively recursive; however, it can be done iteratively by keeping track of the bounds of the search with two pointers. Binary search is efficient for sorted arrays that are stored contiguously (close together) in memory, making &lt;code&gt;O(log n)&lt;/code&gt; comparisons, where &lt;code&gt;n&lt;/code&gt; is the number of elements in the array.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function binarySearch(items, value){

    var startIndex  = 0,
        stopIndex   = items.length - 1,
        middle      = Math.floor((stopIndex + startIndex)/2);

    while(items[middle] != value &amp;amp;&amp;amp; startIndex &amp;lt; stopIndex){

        //adjust search area
        if (value &amp;lt; items[middle]){
            stopIndex = middle - 1;
        } else if (value &amp;gt; items[middle]){
            startIndex = middle + 1;
        }

        //recalculate middle
        middle = Math.floor((stopIndex + startIndex)/2);
    }

    //make sure it&#39;s the right value
    return (items[middle] != value) ? -1 : middle;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The fastest method to create unique items in array&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;With primitive values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;new Set([1, 2, 2, 1, 5]); // [1, 2, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With objects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Array.prototype.unique = function() {
    var o = {}, i, l = this.length, r = [];
    for(i=0; i&amp;lt;l;i+=1) o[this[i]] = this[i];
    for(i in o) r.push(o[i]);
    return r;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is somewhat classified  as “Hash Sorting Algorithm” where every item in the array is a hash value and a hash function inserts item into a bucket, replacing existing values in case of hash collision. As such, this can be applied to any programming language for faster sieving of very large arrays.&lt;/p&gt;

&lt;p&gt;This algorithm has a linear time complexity of &lt;code&gt;O(2n)&lt;/code&gt; in worst case scenario. This is way better than what we will observe for the classic method as described below.&lt;/p&gt;

&lt;p&gt;The classic (worst and most popular) method of finding unique items in an array runs two loops in a nested order to compare each element with rest of the elements. Consequently, the time complexity of the classic method to find the unique items in an array is around quadratic &lt;code&gt;O(n²)&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = [], l = this.length;
  for(var i=0; i&amp;lt;l; i++) {
    for(var j=i+1; j&amp;lt;l; j++)
          if (this[i] === this[j]) j = ++i;
    a.push(this[i]);
  }
  return a;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The fastest method to find items in array&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Create a classical hash table with complexity of &lt;code&gt;O(n)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var result = arr.reduce(function(map, obj) {
  map[obj.id] = obj;
  return map;
}, {});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And search in the structure is &lt;code&gt;O(1)&lt;/code&gt;;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Big-O Complexity Chart&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;http://bigocheatsheet.com/&#34;&gt;An awesome cheat sheet&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Save my day:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/javascript-scene/10-interview-questions-every-javascript-developer-should-know-6fa6bdf5ad95#.qwihvpqxq&#34;&gt;10 Interview Questions Every JavaScript Developer Should Know&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>