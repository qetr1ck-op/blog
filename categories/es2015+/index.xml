<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Es2015&#43; on My New Hugo Site</title>
    <link>https://qetr1ck-op.github.io/blog/categories/es2015&#43;/index.xml</link>
    <description>Recent content in Es2015&#43; on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <atom:link href="https://qetr1ck-op.github.io/blog/categories/es2015&#43;/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>PatternCraft</title>
      <link>https://qetr1ck-op.github.io/blog/post/pattern-craft/</link>
      <pubDate>Sun, 05 Mar 2017 01:35:33 +0200</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/pattern-craft/</guid>
      <description>&lt;p&gt;An awesome explanation of GOF design patterns. The only way to learn pattern is to know what problem it solves.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;state&#34;&gt;State&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.youtube.com/watch?v=yZt7mUVDijU&#34;&gt;State Design Pattern&lt;/a&gt; can be used, for example, to manage the state of tank in StarCraft game.&lt;/p&gt;

&lt;p&gt;The pattern consists in isolating the state logic in different &lt;code&gt;class&lt;/code&gt;es than having multiple &lt;code&gt;if&lt;/code&gt;s to determinate the flow.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class TankState {
    constructor(damage = 5, canMove = true) {
        Object.assign(this, { damage, canMove });
    }

    static get defaultState() { return new SiegeState(); }
}

// state #1
class SiegeState extends TankState {
    constructor() {
        super(20, false);
    }
}

// state #2
class SpeedState extends TankState {
    constructor() {
        super(5, true);
    }
}

class Tank {
    constructor() {
        this.state = TankState.defaultState;
    }

    // implementation bellow relies only on current state, without using multiple if/switch
    get canMove() { return this.state.canMove; } 

    get damage() { return this.state.damage; }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test specs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;describe(&#39;State pattern&#39;, () =&amp;gt; {
    it(&#39;Default tank state is SiegeState&#39;, () =&amp;gt; {
        const tank = new Tank();
        
        expect(tank.state instanceof SiegeTank).to.be.true;
    });

    it(&#39;SiegeState&#39;, () =&amp;gt; {
        const tank = new SiegeState();

        expect(tank.damage).to.equal(20);
        expect(tank.canMove).to.be.false;
    });

    it(&#39;SpeedState&#39;, () =&amp;gt; {
        const tank = new SpeedState();

        expect(tank.damage).to.equal(5);
        expect(tank.canMove).to.be.true;
    });
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;strategy&#34;&gt;Strategy&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.youtube.com/watch?v=MOEsKHqLiBM&#34;&gt;Strategy Design Pattern&lt;/a&gt; can be used, for example, to determinate how a unit moves in StarCraft game.&lt;/p&gt;

&lt;p&gt;The pattern consists in having different strategy for one functionality. A unit, for example, can move by walking or flying or swimming.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// strategy #1
class Walk() {
    move(unit) {
        unit.position += 5;
    }
}
// strategy #2
class Fly() {
    move(unit) {
        unit.position += 20;
    }
}

class Viking {
    constructor() {
        this.moveBehavior = new Walk();
        this.position = 0;
    }

    move() { this.moveBehavior.move(this); } // delegate behavior to strategy
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test specs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;describe(&#39;Strategy pattern&#39;, () =&amp;gt; {
    it(&#39;Default viking move behavior is Walk&#39;, () =&amp;gt; {
        const viking = new Viking();
        
        expect(viking.moveBehavior instanceof Walk).to.be.true;
    });

    it(&#39;Walk behavior&#39;, () =&amp;gt; {
        const viking = new Viking();

        viking.move();
        expect(viking.position).to.equal(5);
        viking.move();
        expect(viking.position).to.equal(10);
    });

    it(&#39;Fly behavior&#39;, () =&amp;gt; {
        const viking = new Viking();
        
        viking.moveBehavior = new Fly();
        viking.move();
        expect(viking.position).to.equal(20);
        viking.move();
        expect(viking.position).to.equal(40);
    });
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;adapter&#34;&gt;Adapter&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.youtube.com/watch?v=hvpXKZhNINc&#34;&gt;Adapter Design Pattern&lt;/a&gt; can be used, to insert an external character in the game.&lt;/p&gt;

&lt;p&gt;The pattern consists in having a wrapper class to adapt the external source.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// in app characters
class Marine {
  attack(target) {
    target.health -= 6;
  }
}

class Zealot {
  attack(target) {
    target.health -= 8;
  }
}

class Zergling {
  attack(target) {
    target.health -= 5;
  }
}

// external
class Mario {
  jumpAttack() {
    console.log(&#39;Mamamia!&#39;);
    return 3;
  }
}

// mario adapter
class MarioAdapter {
    constructor(mario) {
        this.mario = mario;
    }
    
    attack(target) {
        target.health -= this.mario.jumpAttack();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test specs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;describe(&#39;Adapter pattern&#39;, () =&amp;gt; {
    it(&#39;Mario can not attack&#39;, () =&amp;gt; {
        const mario = new Mario();
        
        expect(mario.attack).to.be.undefined;
    });

    it(&#39;MarioAdapter can attack&#39;, () =&amp;gt; {
        const mario = new MarioAdapter();
        const target = { health: 50 };

        mario.attack(target);

        expect(target.health).to.equal(47);
    });
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;visitor&#34;&gt;Visitor&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.youtube.com/watch?v=KSEyIXnknoY&#34;&gt;Strategy Design Pattern&lt;/a&gt; can be used, for example, to determinate how an attack deals a different amount of damage to unit in StarCraft game.&lt;/p&gt;

&lt;p&gt;The pattern delegates the responsibilities to different &lt;code&gt;class&lt;/code&gt;. When a unit takes a damage it can say to the &lt;code&gt;visitor&lt;/code&gt; what do with itself.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Soldier {
    constructor(health = 100) {
        Object.assign(this, { health });
    }
}

class Marine extends Soldier {
    constructor() {
        super();
    }
    
    // an idiomatic name
    accept(visitor) {
        visitor.visitLight(this);
    }
}

class Marauder extends Soldier {
    constructor() {
        super(180);
    }
    
    accept(visitor) {
        visitor.visitArmored(this);
    }
}

// visitor
class TankBullet {
    visitLight(unit) {
        unit.health -= 11;
    }
    visitArmored(unit) {
        unit.health -= 32;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test specs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;describe(&#39;Visitor pattern&#39;, () =&amp;gt; {
    it(&#39;Visit light&#39;, () =&amp;gt; {
        const marine = new Marine();
        const tankBullet = new TankBullet();
        
        tankBullet.visitLight(marine);

        expect(mario.health).to.be(89);
    });

    it(&#39;Visit armored&#39;, () =&amp;gt; {
        const marauder = new Marauder();
        const tankBullet = new TankBullet();
        
        tankBullet.visitArmored(marauder);

        expect(mario.health).to.be(148);
    });
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;decorator&#34;&gt;Decorator&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.youtube.com/watch?v=17XTOODeWQE&#34;&gt;Decorator Design Pattern&lt;/a&gt; can be used, for example, to manage upgrades.&lt;/p&gt;

&lt;p&gt;The pattern is consists in upgrade your base class with extra functionality.&lt;/p&gt;

&lt;p&gt;A decorator will receive an instance of base class and use it to call a new thing you want.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Marine {
    constructor(_damage, _armor) {
        Object.assign(this, { _damage, _armor });
    }

    get damage { return this._damage; }
    get armor { return this._armor; }
}

// decorator #1
class WeaponUpgrade {
    constructor(unit) {
        this.unit = unit;
    }

    get damage { return this.unit.damage + 1; }
    get armor { return this.unit.armor; }
}

// decorator #2
class ArmorUpgrade {
    constructor(unit) {
        this.unit = unit;
    }

    get damage { return this.unit.damage; }
    get armor { return this.unit.armor + 1; }
}

let marine = new Marine();
marine = new WeaponUpgrade(marine);
marine = new WeaponUpgrade(marine);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test specs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;describe(&#39;Decorator pattern&#39;, () =&amp;gt; {
    it(&#39;Weapon upgrade&#39;, () =&amp;gt; {
        let marine = new Marine(10, 2);
        
        marine = new WeaponUpgrade(marine);
        marine = new WeaponUpgrade(marine);

        expect(marine.damage).to.be(12);
        expect(marine.armor).to.be(2);
    });

    it(&#39;Armor upgrade&#39;, () =&amp;gt; {
        let marine = new Marine(10, 2);
        
        marine = new ArmorUpgrade(marine);
        marine = new ArmorUpgrade(marine);

        expect(marine.armor).to.be(4);
        expect(marine.damage).to.be(10);
    });
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;strategy-1&#34;&gt;Strategy&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.youtube.com/watch?v=MOEsKHqLiBM&#34;&gt;Strategy Design Pattern&lt;/a&gt; can be used, for example, to queue actions.&lt;/p&gt;

&lt;p&gt;The pattern consists in isolating command logic in a class so it can:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;queue: you can queue actions to move a probe to a different locations&lt;/li&gt;
&lt;li&gt;undone: you can tell a probe to build something and then call a stop command to undo the action&lt;/li&gt;
&lt;li&gt;validate: you can check if the action can be executed or not, you can not move if building action is in progress&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Probe {
    constructor(commands = [], minerals = 0, x = 0, y = 0) {
        Object.assign(this, {
            position: { x, y },
            commands,
            minerals
        });
    }

    move(x, y) {
        this.commands = [...this.commands, new MoveCommand(this, x, y)];
    }

    gather() {
        this.commands = [...this.commands, new GatherCommand(this)];
    }
}

// command #1
class MoveCommand {
    constructor(unit, x, y) {
        Object.assign(this, { unit, x, y});
    }

    // idiomatic 
    execute() {
        this.unit.position.x = this.x;
        this.unit.position.y = this.y;
    }
}

// command #2
class GatherCommand {
    constructor(unit) {
        this.unit = unit;
    }

    execute() {
        if (this.canExecute) {
            this.unit.minerals += 5;
        }
    }

    get canExecute() {
        return this.unit.minerals === 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test specs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;describe(&#39;Command pattern&#39;, () =&amp;gt; {
    it(&#39;MoveCommand should move unit&#39;, () =&amp;gt; {
        const unit = new Probe();
        const moveBehavior = new MoveBehavior(unit, 10, 20);

        moveBehavior.execute();

        expect(unit.position.x).to.equal(10);
        expect(unit.position.y).to.equal(20);
    });

    it(&#39;GatherCommand should gather resources&#39;, () =&amp;gt; {
        const unit = new Probe();
        const moveBehavior = new GatherBehavior(unit);

        moveBehavior.execute();

        expect(unit.materials).to.equal(5);
    });

    it(&#39;GatherCommand should only gather resources if unit does not have resources&#39;, () =&amp;gt; {
        const unit = new Probe();
        const moveBehavior = new GatherBehavior(unit);

        expect(unit.materials).to.equal(5);
        moveBehavior.execute();
        expect(unit.materials).to.equal(5);
        moveBehavior.execute();
        expect(unit.materials).to.equal(5);
    });
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;proxy&#34;&gt;Proxy&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.youtube.com/watch?v=WcAV9rOGjxw&#34;&gt;Proxy Design Pattern&lt;/a&gt; can be used, for example, to create a &lt;code&gt;drone&lt;/code&gt; by using a proxy &lt;code&gt;cocoon&lt;/code&gt; class.&lt;/p&gt;

&lt;p&gt;The pattern is responsible (&amp;ldquo;stands in&amp;rdquo;) for all requests on original object, typical extend or change behavior, than delegates action again to original object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// original
class Drone {
    move(x, y) {
        this.x = x;
        this.y = y;
    }
}

// proxy
class Cocoon {
    constructor() {
        this.lifetime = 3000;
        // proxing
        this.hatchDrone();
    }

    hatchDrone() {
        setTimeout(this.onHatchDroneDone.bind(this), this.lifetime);
    }
    
    onHatchDroneDone() {
      this.drone = new Drone();
      this.drone.move(this.rallyPath.x, this.rallyPath.y);
    }

    move(x, y) {
        if (this.drone) {
            this.drone.move(x, y);
        } else {
          this.rallyPath = { x, y };
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;describe(&#39;Proxy pattern&#39;, () =&amp;gt; {
    it(&#39;Create drone when cocoon is hatched&#39;, done =&amp;gt; {
        const drone = new Cocoon();
        
        drone.move(10, 20);

        expect(drone.drone).to.be.undefined;
        expect(drone.rallyPath).to.be({ x: 10, y: 20 });

        setTimeout(() =&amp;gt; {
            expect(drone.drone).to.be.defined;
            expect(drone.drone.x).to.be.equal(10);
            expect(drone.drone.y).to.be.equal(20);
            done();
        }, drone.lifetime)
    });

    it(&#39;Visit armored&#39;, () =&amp;gt; {
        const marauder = new Marauder();
        const tankBullet = new TankBullet();
        
        tankBullet.visitArmored(marauder);

        expect(mario.health).to.be(148);
    });
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A classical JS example to proxing, for example, HTTP request by adding logging before every action:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// proxy
const proxiedFetch = fetch;

fetch = (url) =&amp;gt; {
    // proxing
    console.log(&#39;logging...&#39;);
    // original
    proxiedFetch(url);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save my day:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PL8B19C3040F6381A2&#34;&gt;Original series of John Lindquist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sourcemaking.com/design_patterns&#34;&gt;Just a great resource of Design Patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>5 principles that will make a more SOLID Javascript Engineer</title>
      <link>https://qetr1ck-op.github.io/blog/post/5-principles-that-will-make-a-more-SOLID-Javascript-Engineer/</link>
      <pubDate>Mon, 11 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/5-principles-that-will-make-a-more-SOLID-Javascript-Engineer/</guid>
      <description>&lt;p&gt;Being a SOLID developer in JS isn&amp;rsquo;t so as straight forward as in other languages. Some developers consider functional approach. Others chose OOP style. Some stand in both line. And other think that having class is wrong and redundant and prefer factories. But still, SOLID principles are the basic pillars of object oriented programming.&lt;/p&gt;

&lt;p&gt;But what are they?&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-solid-principles-are&#34;&gt;The SOLID principles are:&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;S&lt;/strong&gt; - Single responsibility principle&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;O&lt;/strong&gt; - Open-Close principle&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L&lt;/strong&gt; - Liskov Substitution principle&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;I&lt;/strong&gt; - Interface segregation principle&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;D&lt;/strong&gt; - Dependency Inversion principle&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;single-responsibility-principle&#34;&gt;Single responsibility principle&lt;/h1&gt;

&lt;p&gt;Very similar to Unix slogan:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Do one thing and do it well&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This one is easy to comprehend but harder to implement. Every function should do exactly one thing. It should have
one clearly defined goal.&lt;/p&gt;

&lt;p&gt;So were should we draw a line to decouple on big peace of code. I have 2 basic strategies for dealing with complexity:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If you find yourself writing/calling function &lt;code&gt;loginUserAndSaveToken()&lt;/code&gt; you&amp;rsquo;re probably breaking the &lt;strong&gt;SRP&lt;/strong&gt;. Break
this function into two separate ones.&lt;/li&gt;
&lt;li&gt;For every function imagine if there are possibility to extract reusable part to not repeat your self.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But there is a tricky moment.&lt;/p&gt;

&lt;p&gt;Using this logic, &lt;code&gt;runFacebook()&lt;/code&gt; is indeed a single responsible function. But this only applies as long as the body
of function &lt;code&gt;runFacebook()&lt;/code&gt; is implemented correctly in small divided functions.&lt;/p&gt;

&lt;h1 id=&#34;open-close-principle&#34;&gt;Open-Close principle&lt;/h1&gt;

&lt;p&gt;It means that our module should be open to extension, but closed to modification.&lt;/p&gt;

&lt;p&gt;Meaning is simple, if someone wants to extend your module behavior, they won&amp;rsquo;t need to modify existing code if they
don&amp;rsquo;t want to.&lt;/p&gt;

&lt;p&gt;There is a easy rule to follow here:&lt;/p&gt;

&lt;p&gt;If you have to open a JS file and need to make a modification there, in order to extend it - you&amp;rsquo;ve failed &lt;strong&gt;OCP&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class IceCreamMachine {
    constructor() {
        this.flavors = [&#39;chocolate&#39;, &#39;vanilla&#39;];
    }
    create() {
        if (this.flavors.includes(flavor)) { // warning, ES7 Array.prototype.includes
            console.log(&#39;Great success. You now can eat your ice cream&#39;);
        } else {
            console.log(&#39;A bad choice, not ice cream today&#39;);
        }
    }
}

export default IceCreamMachine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As far as you can see there&amp;rsquo;s no way to add new ice cream flavor without literally open the module and edit
&lt;code&gt;IceCreamMachine.flavors&lt;/code&gt; array.&lt;/p&gt;

&lt;p&gt;To follow &lt;strong&gt;OCP&lt;/strong&gt; we can easily change that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class IceCreamMachine {
    constructor() {
        this.flavors = [&#39;chocolate&#39;, &#39;vanilla&#39;];
    }
    create() {
        if (this.flavors.includes(flavor)) {
            console.log(&#39;Great success. You now can eat your ice cream&#39;);
        } else {
            console.log(&#39;A bad choice, not ice cream today&#39;);
        }
    }
    flavorAdd(flavor) {
        this.flavors = [...this.flavors, flavor];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;liskov-substitution-principle&#34;&gt;Liskov Substitution Principle&lt;/h1&gt;

&lt;p&gt;This is one of the most obscure name I&amp;rsquo;ve ever seen in programming world.&lt;/p&gt;

&lt;p&gt;And even more the classical description is:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Child classes should never break the parent class type definition.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What a tough explanation. I&amp;rsquo;ll make it more simple:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;It means that we must make sure that new derived classes are extending the base class without changing their behavior.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To illustrate we will go with classical example with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Rectangle {
    constructor() {
        // init procedure
    }
    setWidth(width) {
        this.width = width;
    }
    setHeigth(height) {
        this.height = height;
    }
    getArea() {
        return this.width * this.height;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We start with basic geometry abstraction &lt;code&gt;Rectangle&lt;/code&gt;. Imagine that is a working and already is deployed to several clients.&lt;/p&gt;

&lt;p&gt;Now we need a new feature. A possibility to manipulate &lt;code&gt;Square&lt;/code&gt;&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;In real life, in geometry, a square is a form of rectangle. So we could try to implement &lt;code&gt;Square&lt;/code&gt; class that extends &lt;code&gt;Rectangle&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cdn.tutsplus.com/net/uploads/2014/01/SquareRect.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;But is a &lt;code&gt;Square&lt;/code&gt; really a &lt;code&gt;Rectangle&lt;/code&gt; in programming?..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Square extends Rectangle {
    constructor() {
        super();
        // init procedure
    }
    setWidth(width) {
        this.width = width;
        this.height = width;
    }
    setHeigth(height) {
        this.height = height;
        this.width = height;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A square is a rectangle with equal width and height, and we do a strange implementation like in example above.
We overwrite both setters.&lt;/p&gt;

&lt;p&gt;So, our &lt;code&gt;Square&lt;/code&gt; class isn&amp;rsquo;t a &lt;code&gt;Rectangle&lt;/code&gt; after all.&lt;/p&gt;

&lt;p&gt;It breaks the law of geometry. It fails the &lt;code&gt;LSP&lt;/code&gt; principle.&lt;/p&gt;

&lt;h1 id=&#34;interface-segregation-principle&#34;&gt;Interface Segregation principle&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;SRP&lt;/code&gt; is about actors and high lever architecture.
The &lt;code&gt;OCP&lt;/code&gt; is about design and feature extension.
The &lt;code&gt;LSP&lt;/code&gt; is about sub-typing and inheritance.
And the &lt;code&gt;ISP&lt;/code&gt; is about business logic to client communication.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Interface Segregation actually means you shouldn&amp;rsquo;t create bloated interfaces&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Since JS doesn&amp;rsquo;t have an interfaces, I&amp;rsquo;m going to use more abstractive description.&lt;/p&gt;

&lt;p&gt;So how should we define our interfaces? We could thing about our model and expose all functionality we want it to offer:&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say your friend created a brand new HTML5 route library. He convinced you to implement it in your project.&lt;/p&gt;

&lt;p&gt;You start to play around and register the first route via &lt;code&gt;registerRouter(routeName)&lt;/code&gt;. And you thing all are set up.&lt;/p&gt;

&lt;p&gt;But your friend lied.&lt;/p&gt;

&lt;p&gt;He forgot to mention that you also need to implement &lt;code&gt;onErrorHandler()&lt;/code&gt; and &lt;code&gt;handleIE8()&lt;/code&gt; for every your registered route.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;The lesson is whenever you expose a module, make sure only essential are required, everything else is optional. Otherwise your friends will hate you.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;dependency-inversion-principle&#34;&gt;Dependency Inversion Principle&lt;/h1&gt;

&lt;p&gt;You&amp;rsquo;ve might heard about dependency inversion as a standalone term. &lt;code&gt;Dependency Injection&lt;/code&gt; and &lt;code&gt;Inversion of Control&lt;/code&gt; also mean the same.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;A. High-level modules shouldn&amp;rsquo;t depend on low-level modules. Both should depend on abstraction.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;B. Abstraction shouldn&amp;rsquo;t depend upon details. Details should depend on details.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;DI&lt;/code&gt; is all about handling over control from the function itself to the caller function. In our case it means defining who controls the type of parameters the function receives. Let&amp;rsquo;s use an example.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve started to use an event emitter implementation. Your old functionality looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function awesomeFoo(dispatcher) {
    dispatcher.trigger(&#39;awesome/foo&#39;);
}

function awesomeFooListener(dispatcher) {
    dispatcher.on(&#39;awesome/foo&#39;, event =&amp;gt; {
        console.log(event)
    };    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is one problem. New dispatcher methods are called with &lt;code&gt;emit()&lt;/code&gt; and &lt;code&gt;listen()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You could refactor your code. But what if implementation isn&amp;rsquo;t all that great.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;You&amp;rsquo;d like to be able easily switch between implementations&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;You realize that you don&amp;rsquo;t need the whole dispatcher object in every function. You change your code to receive only the relevant methods for every function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function awesomeFoo(dispatcher) {
    dispatch(&#39;awesome/foo&#39;);
}

function awesomeFooListener(dispatcher) {
    listen(&#39;awesome/foo&#39;, event =&amp;gt; {
        console.log(event)
    };    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your code now doesn&amp;rsquo;t depend on any concrete implementation of event emitter object.&lt;/p&gt;

&lt;p&gt;It does depend on abstraction. You can now freely switch between new/old implementation or even use a mock implementation for testing.&lt;/p&gt;

&lt;p&gt;Save my day:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://thefullstack.xyz/solid-javascript/&#34;&gt;The Full Stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://aspiringcraftsman.com/2011/12/08/solid-javascript-single-responsibility-principle/&#34;&gt;Aspiring Craftsman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://code.tutsplus.com/series/the-solid-principles--cms-634&#34;&gt;code.tutsplus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>