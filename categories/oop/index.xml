<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Oop on My New Hugo Site</title>
    <link>https://qetr1ck-op.github.io/blog/categories/oop/index.xml</link>
    <description>Recent content in Oop on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <atom:link href="https://qetr1ck-op.github.io/blog/categories/oop/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>5 principles that will make a more SOLID Javascript Engineer</title>
      <link>https://qetr1ck-op.github.io/blog/post/5-principles-that-will-make-a-more-SOLID-Javascript-Engineer/</link>
      <pubDate>Mon, 11 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/5-principles-that-will-make-a-more-SOLID-Javascript-Engineer/</guid>
      <description>&lt;p&gt;Being a SOLID developer in JS isn&amp;rsquo;t so as straight forward as in other languages. Some developers consider functional approach. Others chose OOP style. Some stand in both line. And other think that having class is wrong and redundant and prefer factories. But still, SOLID principles are the basic pillars of object oriented programming.&lt;/p&gt;

&lt;p&gt;But what are they?&lt;/p&gt;

&lt;p&gt;
&lt;!--toc--&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-solid-principles-are&#34;&gt;The SOLID principles are:&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;S&lt;/strong&gt; - Single responsibility principle&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;O&lt;/strong&gt; - Open-Close principle&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L&lt;/strong&gt; - Liskov Substitution principle&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;I&lt;/strong&gt; - Interface segregation principle&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;D&lt;/strong&gt; - Dependency Inversion principle&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;single-responsibility-principle&#34;&gt;Single responsibility principle&lt;/h1&gt;

&lt;p&gt;Very similar to Unix slogan:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Do one thing and do it well&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This one is easy to comprehend but harder to implement. Every function should do exactly one thing. It should have
one clearly defined goal.&lt;/p&gt;

&lt;p&gt;So were should we draw a line to decouple on big peace of code. I have 2 basic strategies for dealing with complexity:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If you find yourself writing/calling function &lt;code&gt;loginUserAndSaveToken()&lt;/code&gt; you&amp;rsquo;re probably breaking the &lt;strong&gt;SRP&lt;/strong&gt;. Break
this function into two separate ones.&lt;/li&gt;
&lt;li&gt;For every function imagine if there are possibility to extract reusable part to not repeat your self.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But there is a tricky moment.&lt;/p&gt;

&lt;p&gt;Using this logic, &lt;code&gt;runFacebook()&lt;/code&gt; is indeed a single responsible function. But this only applies as long as the body
of function &lt;code&gt;runFacebook()&lt;/code&gt; is implemented correctly in small divided functions.&lt;/p&gt;

&lt;h1 id=&#34;open-close-principle&#34;&gt;Open-Close principle&lt;/h1&gt;

&lt;p&gt;It means that our module should be open to extension, but closed to modification.&lt;/p&gt;

&lt;p&gt;Meaning is simple, if someone wants to extend your module behavior, they won&amp;rsquo;t need to modify existing code if they
don&amp;rsquo;t want to.&lt;/p&gt;

&lt;p&gt;There is a easy rule to follow here:&lt;/p&gt;

&lt;p&gt;If you have to open a JS file and need to make a modification there, in order to extend it - you&amp;rsquo;ve failed &lt;strong&gt;OCP&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class IceCreamMachine {
    constructor() {
        this.flavors = [&#39;chocolate&#39;, &#39;vanilla&#39;];
    }
    create() {
        if (this.flavors.includes(flavor)) { // warning, ES7 Array.prototype.includes
            console.log(&#39;Great success. You now can eat your ice cream&#39;);
        } else {
            console.log(&#39;A bad choice, not ice cream today&#39;);
        }
    }
}

export default IceCreamMachine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As far as you can see there&amp;rsquo;s no way to add new ice cream flavor without literally open the module and edit
&lt;code&gt;IceCreamMachine.flavors&lt;/code&gt; array.&lt;/p&gt;

&lt;p&gt;To follow &lt;strong&gt;OCP&lt;/strong&gt; we can easily change that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class IceCreamMachine {
    constructor() {
        this.flavors = [&#39;chocolate&#39;, &#39;vanilla&#39;];
    }
    create() {
        if (this.flavors.includes(flavor)) {
            console.log(&#39;Great success. You now can eat your ice cream&#39;);
        } else {
            console.log(&#39;A bad choice, not ice cream today&#39;);
        }
    }
    flavorAdd(flavor) {
        this.flavors = [...this.flavors, flavor];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;liskov-substitution-principle&#34;&gt;Liskov Substitution Principle&lt;/h1&gt;

&lt;p&gt;This is one of the most obscure name I&amp;rsquo;ve ever seen in programming world.&lt;/p&gt;

&lt;p&gt;And even more the classical description is:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Child classes should never break the parent class type definition.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What a tough explanation. I&amp;rsquo;ll make it more simple:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;It means that we must make sure that new derived classes are extending the base class without changing their behavior.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To illustrate we will go with classical example with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Rectangle {
    constructor() {
        // init procedure
    }
    setWidth(width) {
        this.width = width;
    }
    setHeigth(height) {
        this.height = height;
    }
    getArea() {
        return this.width * this.height;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We start with basic geometry abstraction &lt;code&gt;Rectangle&lt;/code&gt;. Imagine that is a working and already is deployed to several clients.&lt;/p&gt;

&lt;p&gt;Now we need a new feature. A possibility to manipulate &lt;code&gt;Square&lt;/code&gt;&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;In real life, in geometry, a square is a form of rectangle. So we could try to implement &lt;code&gt;Square&lt;/code&gt; class that extends &lt;code&gt;Rectangle&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cdn.tutsplus.com/net/uploads/2014/01/SquareRect.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;But is a &lt;code&gt;Square&lt;/code&gt; really a &lt;code&gt;Rectangle&lt;/code&gt; in programming?..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Square extends Rectangle {
    constructor() {
        super();
        // init procedure
    }
    setWidth(width) {
        this.width = width;
        this.height = width;
    }
    setHeigth(height) {
        this.height = height;
        this.width = height;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A square is a rectangle with equal width and height, and we do a strange implementation like in example above.
We overwrite both setters.&lt;/p&gt;

&lt;p&gt;So, our &lt;code&gt;Square&lt;/code&gt; class isn&amp;rsquo;t a &lt;code&gt;Rectangle&lt;/code&gt; after all.&lt;/p&gt;

&lt;p&gt;It breaks the law of geometry. It fails the &lt;code&gt;LSP&lt;/code&gt; principle.&lt;/p&gt;

&lt;h1 id=&#34;interface-segregation-principle&#34;&gt;Interface Segregation principle&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;SRP&lt;/code&gt; is about actors and high lever architecture.
The &lt;code&gt;OCP&lt;/code&gt; is about design and feature extension.
The &lt;code&gt;LSP&lt;/code&gt; is about sub-typing and inheritance.
And the &lt;code&gt;ISP&lt;/code&gt; is about business logic to client communication.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Interface Segregation actually means you shouldn&amp;rsquo;t create bloated interfaces&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Since JS doesn&amp;rsquo;t have an interfaces, I&amp;rsquo;m going to use more abstractive description.&lt;/p&gt;

&lt;p&gt;So how should we define our interfaces? We could thing about our model and expose all functionality we want it to offer:&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say your friend created a brand new HTML5 route library. He convinced you to implement it in your project.&lt;/p&gt;

&lt;p&gt;You start to play around and register the first route via &lt;code&gt;registerRouter(routeName)&lt;/code&gt;. And you thing all are set up.&lt;/p&gt;

&lt;p&gt;But your friend lied.&lt;/p&gt;

&lt;p&gt;He forgot to mention that you also need to implement &lt;code&gt;onErrorHandler()&lt;/code&gt; and &lt;code&gt;handleIE8()&lt;/code&gt; for every your registered route.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;The lesson is whenever you expose a module, make sure only essential are required, everything else is optional. Otherwise your friends will hate you.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;dependency-inversion-principle&#34;&gt;Dependency Inversion Principle&lt;/h1&gt;

&lt;p&gt;You&amp;rsquo;ve might heard about dependency inversion as a standalone term. &lt;code&gt;Dependency Injection&lt;/code&gt; and &lt;code&gt;Inversion of Control&lt;/code&gt; also mean the same.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;A. High-level modules shouldn&amp;rsquo;t depend on low-level modules. Both should depend on abstraction.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;B. Abstraction shouldn&amp;rsquo;t depend upon details. Details should depend on details.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;DI&lt;/code&gt; is all about handling over control from the function itself to the caller function. In our case it means defining who controls the type of parameters the function receives. Let&amp;rsquo;s use an example.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve started to use an event emitter implementation. Your old functionality looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function awesomeFoo(dispatcher) {
    dispatcher.trigger(&#39;awesome/foo&#39;);
}

function awesomeFooListener(dispatcher) {
    dispatcher.on(&#39;awesome/foo&#39;, event =&amp;gt; {
        console.log(event)
    };    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is one problem. New dispatcher methods are called with &lt;code&gt;emit()&lt;/code&gt; and &lt;code&gt;listen()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You could refactor your code. But what if implementation isn&amp;rsquo;t all that great.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;You&amp;rsquo;d like to be able easily switch between implementations&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;You realize that you don&amp;rsquo;t need the whole dispatcher object in every function. You change your code to receive only the relevant methods for every function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function awesomeFoo(dispatcher) {
    dispatch(&#39;awesome/foo&#39;);
}

function awesomeFooListener(dispatcher) {
    listen(&#39;awesome/foo&#39;, event =&amp;gt; {
        console.log(event)
    };    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your code now doesn&amp;rsquo;t depend on any concrete implementation of event emitter object.&lt;/p&gt;

&lt;p&gt;It does depend on abstraction. You can now freely switch between new/old implementation or even use a mock implementation for testing.&lt;/p&gt;

&lt;p&gt;Save my day:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://thefullstack.xyz/solid-javascript/&#34;&gt;The Full Stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://aspiringcraftsman.com/2011/12/08/solid-javascript-single-responsibility-principle/&#34;&gt;Aspiring Craftsman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://code.tutsplus.com/series/the-solid-principles--cms-634&#34;&gt;code.tutsplus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>