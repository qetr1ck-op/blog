<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>React on OP blog</title>
    <link>https://qetr1ck-op.github.io/blog/categories/react/index.xml</link>
    <description>Recent content in React on OP blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <atom:link href="https://qetr1ck-op.github.io/blog/categories/react/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Understanding components approach and thinking in React</title>
      <link>https://qetr1ck-op.github.io/blog/post/Understanding-Components-approach-and-Thinking-in-React/</link>
      <pubDate>Fri, 05 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/Understanding-Components-approach-and-Thinking-in-React/</guid>
      <description>&lt;p&gt;The parts of a web user interface building blocks for both simple websites and modern front-end applications.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;understanding-components&#34;&gt;Understanding Components&lt;/h1&gt;

&lt;p&gt;These parts are commonly referred to as UI components or UI widgets. The browser offers many native components and, when these are not enough, custom components like &lt;a href=&#34;http://getbootstrap.com&#34;&gt;Bootstrap&lt;/a&gt;, &lt;a href=&#34;http://www.telerik.com/kendo-ui&#34;&gt;Kendo UI&lt;/a&gt;, &lt;a href=&#34;http://semantic-ui.com/&#34;&gt;Semantic UI&lt;/a&gt;, &lt;a href=&#34;http://getuikit.com/&#34;&gt;UI Kit&lt;/a&gt; can be used.&lt;/p&gt;

&lt;p&gt;UI component is a region in a web page that contains an isolated UI feature that is distinct from everything around it. For example, an HTML &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element is considered a native HTML UI component.&lt;/p&gt;

&lt;p&gt;An HTML &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element can be placed into a web page and a developer gets:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;An isolated, reusable, and decoupled instance of a &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; with no side effects;&lt;/li&gt;
&lt;li&gt;A default styled UI element that a user can interact with;&lt;/li&gt;
&lt;li&gt;Configuration that affects the state via properties that are passed declaratively to the component by way of HTML attributes, text, and child components (i.e. &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt;) that can contain attributes and text as well;&lt;/li&gt;
&lt;li&gt;An API to imperatively program the component, affecting state, via the DOM and JavaScript (i.e. DOM events and methods).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The main primitive (speaking about React, Angular &amp;amp; Ember) is this idea of a &lt;strong&gt;component&lt;/strong&gt;. I think everyone has some notion of what a component is. The idea is that it should be an atomic UI piece that is &lt;strong&gt;composable&lt;/strong&gt; and &lt;strong&gt;reusable&lt;/strong&gt;, and should work with other pieces.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;We’re not designing pages, we’re designing systems of components&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;thinking-in-react&#34;&gt;Thinking in React&lt;/h1&gt;

&lt;p&gt;One of the many great parts of React is how it makes you think about apps as you build them. I&amp;rsquo;ll walk through the process of building a searchable product data table using React.&lt;/p&gt;

&lt;h2 id=&#34;start-with-a-mock&#34;&gt;Start with a mock&lt;/h2&gt;

&lt;p&gt;Imagine that we already have a JSON API which returns some data that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;[
  {category: &amp;quot;Sporting Goods&amp;quot;, price: &amp;quot;$49.99&amp;quot;, stocked: true, name: &amp;quot;Football&amp;quot;},
  {category: &amp;quot;Sporting Goods&amp;quot;, price: &amp;quot;$9.99&amp;quot;, stocked: true, name: &amp;quot;Baseball&amp;quot;},
  {category: &amp;quot;Sporting Goods&amp;quot;, price: &amp;quot;$29.99&amp;quot;, stocked: false, name: &amp;quot;Basketball&amp;quot;},
  {category: &amp;quot;Electronics&amp;quot;, price: &amp;quot;$99.99&amp;quot;, stocked: true, name: &amp;quot;iPod Touch&amp;quot;},
  {category: &amp;quot;Electronics&amp;quot;, price: &amp;quot;$399.99&amp;quot;, stocked: false, name: &amp;quot;iPhone 5&amp;quot;},
  {category: &amp;quot;Electronics&amp;quot;, price: &amp;quot;$199.99&amp;quot;, stocked: true, name: &amp;quot;Nexus 7&amp;quot;}
];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;step-1-break-the-ui-into-a-component-hierarchy&#34;&gt;Step 1: break the UI into a component hierarchy&lt;/h2&gt;

&lt;p&gt;The first thing you&amp;rsquo;ll want to do is to draw boxes around every component (and subcomponent) in the mock and give them all names.&lt;/p&gt;

&lt;p&gt;But how do you know what should be its own component?&lt;/p&gt;

&lt;p&gt;Just use the same techniques for deciding if you should create a new function or object. One such technique is the single &lt;strong&gt;responsibility principle&lt;/strong&gt;, that is, a component should ideally only do one thing. If it ends up growing, it should be decomposed into smaller subcomponents.&lt;/p&gt;

&lt;p&gt;Components that appear within another component in the mock should appear as a child in the hierarchy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;- FilterableProductTable
    - SearchBar
    - ProductTable
        - ProductCategoryRow
        - ProductRow
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;step-2-build-a-static-version-in-react&#34;&gt;Step 2: Build a static version in React&lt;/h2&gt;

&lt;script async src=&#34;//jsfiddle.net/qetr1ck/voyqdw3f/embed/js,html,css,result/dark/&#34;&gt;&lt;/script&gt;

&lt;p&gt;To build a static version of your app that renders your data model, you&amp;rsquo;ll want to build components that reuse other components and pass data using &lt;code&gt;props&lt;/code&gt;. &lt;code&gt;props&lt;/code&gt; are a way of passing data from parent to child.&lt;/p&gt;

&lt;p&gt;State is reserved only for &lt;strong&gt;interactivity&lt;/strong&gt;, that is, data that changes over time. Since this is a static version of the app, you don&amp;rsquo;t need it here.&lt;/p&gt;

&lt;h2 id=&#34;step-3-identify-the-minimal-representation-of-ui-state&#34;&gt;Step 3: Identify the minimal representation of UI state&lt;/h2&gt;

&lt;p&gt;To make your UI interactive, you need to be able to trigger changes to your underlying data model. React makes this easy with &lt;code&gt;state&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Think of all of the pieces of data in our example application. We have:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The original list of products&lt;/li&gt;
&lt;li&gt;The search text the user has entered&lt;/li&gt;
&lt;li&gt;The value of the checkbox&lt;/li&gt;
&lt;li&gt;The filtered list of products&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s go through each one and figure out which one is &lt;code&gt;state&lt;/code&gt;. Simply ask three questions about each piece of data:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Is it passed in from a parent via &lt;code&gt;props&lt;/code&gt;? If so, it probably isn&amp;rsquo;t state.&lt;/li&gt;
&lt;li&gt;Does it change over time? If not, it probably isn&amp;rsquo;t &lt;code&gt;state&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Can you compute it based on any other state or props in your component? If so, it&amp;rsquo;s not &lt;code&gt;state&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So finally, our state is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The search text the user has entered&lt;/li&gt;
&lt;li&gt;The value of the checkbox&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;step-4-identify-where-your-state-should-live&#34;&gt;Step 4: Identify where your state should live&lt;/h2&gt;

&lt;p&gt;This is often the most challenging part for newcomers to understand, so follow these steps to figure it out:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Identify every component that renders something based on that &lt;code&gt;state&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Find a common owner component (a single component above all the components that need the &lt;code&gt;state&lt;/code&gt; in the hierarchy).&lt;/li&gt;
&lt;li&gt;If you can&amp;rsquo;t find a component where it makes sense to own the &lt;code&gt;state&lt;/code&gt;, create a new component simply for holding the &lt;code&gt;state&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s run through this strategy for our application:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ProductTable needs to filter the product list based on state and SearchBar needs to display the search text and checked state.&lt;/li&gt;
&lt;li&gt;The common owner component is FilterableProductTable.&lt;/li&gt;
&lt;li&gt;It conceptually makes sense for the filter text and checked value to live in FilterableProductTable&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;rsquo;ve decided that our state lives in &lt;code&gt;FilterableProductTable&lt;/code&gt;. First, add a &lt;code&gt;getInitialState()&lt;/code&gt; method to &lt;code&gt;FilterableProductTable&lt;/code&gt; that returns &lt;code&gt;{filterText: &#39;&#39;, inStockOnly: false}&lt;/code&gt; to reflect the initial &lt;code&gt;state&lt;/code&gt; of your application.&lt;/p&gt;

&lt;p&gt;Then, pass &lt;code&gt;filterText&lt;/code&gt; and &lt;code&gt;inStockOnly&lt;/code&gt; to &lt;code&gt;ProductTable&lt;/code&gt; and &lt;code&gt;SearchBar&lt;/code&gt; as a &lt;code&gt;prop&lt;/code&gt;. Finally, use these &lt;code&gt;props&lt;/code&gt; to filter the rows in &lt;code&gt;ProductTable&lt;/code&gt; and set the values of the form fields in &lt;code&gt;SearchBar&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;step-5-add-inverse-data-flow&#34;&gt;Step 5: Add inverse data flow&lt;/h2&gt;

&lt;p&gt;Now it&amp;rsquo;s time to support data flowing the other way: the form components deep in the hierarchy need to update the &lt;code&gt;state&lt;/code&gt; in &lt;code&gt;FilterableProductTable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you try to type or check the box in the previous version of the example, you&amp;rsquo;ll see that React &lt;strong&gt;ignores&lt;/strong&gt; your input. This is intentional, as we&amp;rsquo;ve set the value &lt;code&gt;prop&lt;/code&gt; of the input to always be equal to the &lt;code&gt;state&lt;/code&gt; passed in from &lt;code&gt;FilterableProductTable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Since components should only update their own state, &lt;code&gt;FilterableProductTable&lt;/code&gt; will pass a callback to &lt;code&gt;SearchBar&lt;/code&gt; that will fire whenever the state should be updated. We can use the &lt;code&gt;onChange&lt;/code&gt; event on the inputs to be notified of it. And the callback passed by &lt;code&gt;FilterableProductTable&lt;/code&gt; will call &lt;code&gt;setState()&lt;/code&gt;, and the app will be updated.&lt;/p&gt;

&lt;script async src=&#34;//jsfiddle.net/qetr1ck/voyqdw3f/3/embed/js,html,result/dark/&#34;&gt;&lt;/script&gt;</description>
    </item>
    
    <item>
      <title>First reaction about React.js</title>
      <link>https://qetr1ck-op.github.io/blog/post/First-look-at-React-js/</link>
      <pubDate>Thu, 04 Feb 2016 17:20:14 +0000</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/First-look-at-React-js/</guid>
      <description>

&lt;p&gt;Building a dead simple application with following component structure:&lt;/p&gt;

&lt;!--toc--&gt;

&lt;pre&gt;&lt;code&gt;- CommentBox
  - CommentList
    - Comment
  - CommentForm
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;getting-started&#34;&gt;Getting started&lt;/h1&gt;

&lt;p&gt;Open up &lt;code&gt;public/index.html&lt;/code&gt; in your favorite editor. It should look something  like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;React Tutorial&amp;lt;/title&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react-dom.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.2/marked.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script type=&amp;quot;text/babel&amp;quot; src=&amp;quot;scripts/example.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/babel&amp;quot;&amp;gt;
      // To get started with this tutorial running your own code, simply remove
      // the script tag loading scripts/example.js and start writing code here.
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We included &lt;code&gt;jQuery&lt;/code&gt; here because we want to simplify the code of our future ajax calls, but it&amp;rsquo;s NOT mandatory for React to work.&lt;/p&gt;

&lt;h1 id=&#34;your-first-component&#34;&gt;Your first component&lt;/h1&gt;

&lt;p&gt;React is all about modular, composable components. For our comment box example, we&amp;rsquo;ll have the following component structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- CommentBox
  - CommentList
    - Comment
  - CommentForm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s build the &lt;code&gt;CommentBox&lt;/code&gt; component, which is just a simple &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// tutorial1.js
var CommentBox = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        Hello, world! I am a CommentBox.
      &amp;lt;/div&amp;gt;
      /* Imperative way
      React.createElement(&#39;div&#39;, {className: &amp;quot;commentBox&amp;quot;},
        &amp;quot;Hello, world! I am a CommentBox.&amp;quot;
      )
      */
    );
  }
});
ReactDOM.render(
  &amp;lt;CommentBox /&amp;gt;,
  document.getElementById(&#39;content&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;React.createClass()&lt;/code&gt; to create a new React component. The most important of these methods is called &lt;code&gt;render&lt;/code&gt; which returns a tree of React components that will eventually render to HTML.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; tags are not actual DOM nodes; they are instantiations of React div components.&lt;/p&gt;

&lt;h1 id=&#34;composing-components&#34;&gt;Composing components&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s build skeletons for &lt;code&gt;CommentList&lt;/code&gt; and &lt;code&gt;CommentForm&lt;/code&gt; which will, again, be simple &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;s. Add these two components to your file, keeping the existing &lt;code&gt;CommentBox&lt;/code&gt; declaration and &lt;code&gt;ReactDOM.render&lt;/code&gt; call:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var CommentList = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentList&amp;quot;&amp;gt;
        Hello, world! I am a CommentList.
      &amp;lt;/div&amp;gt;
    );
  }
});

var CommentForm = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentForm&amp;quot;&amp;gt;
        Hello, world! I am a CommentForm.
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, update the CommentBox component to use these new components:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var CommentBox = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList /&amp;gt;
        &amp;lt;CommentForm /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how we&amp;rsquo;re mixing HTML tags and components we&amp;rsquo;ve built. HTML components are regular React components, just like the ones you define, with one difference. The &lt;code&gt;JSX&lt;/code&gt; compiler will automatically rewrite HTML tags to &lt;code&gt;React.createElement(tagName)&lt;/code&gt; expressions and leave everything else alone.&lt;/p&gt;

&lt;h1 id=&#34;using-props&#34;&gt;Using props&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s create the &lt;code&gt;Comment&lt;/code&gt; component, which will depend on data passed in from its parent. Data passed in from a parent component is available as a &lt;code&gt;property&lt;/code&gt; on the child component. These properties are accessed through &lt;code&gt;this.props&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var Comment = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;comment&amp;quot;&amp;gt;
        &amp;lt;h2 className=&amp;quot;commentAuthor&amp;quot;&amp;gt;
          {this.props.author}
        &amp;lt;/h2&amp;gt;
        {this.props.children}
      &amp;lt;/div&amp;gt;
    );
  }
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We access named attributes passed to the component as keys on &lt;code&gt;this.props&lt;/code&gt; and any nested elements as &lt;code&gt;this.props.children&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;component-properties&#34;&gt;Component Properties&lt;/h1&gt;

&lt;p&gt;Now let&amp;rsquo;s add some comments within our &lt;code&gt;CommentList&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var CommentList = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentList&amp;quot;&amp;gt;
        &amp;lt;Comment author=&amp;quot;Pete Hunt&amp;quot;&amp;gt;This is one comment&amp;lt;/Comment&amp;gt;
        &amp;lt;Comment author=&amp;quot;Jordan Walke&amp;quot;&amp;gt;This is *another* comment&amp;lt;/Comment&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, we passed &lt;em&gt;Pete Hunt&lt;/em&gt; (via an attribute) and &lt;em&gt;This is one comment&lt;/em&gt; (via an XML-like child node) to the first Comment. As noted above, the &lt;code&gt;Comment&lt;/code&gt; component will access these &lt;code&gt;properties&lt;/code&gt; through &lt;code&gt;this.props.author&lt;/code&gt;, and &lt;code&gt;this.props.children&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;adding-markdown&#34;&gt;Adding Markdown&lt;/h1&gt;

&lt;p&gt;In this tutorial we use a third-party library marked which takes Markdown text and converts it to raw HTML:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var Comment = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;comment&amp;quot;&amp;gt;
        &amp;lt;h2 className=&amp;quot;commentAuthor&amp;quot;&amp;gt;
          {this.props.author}
        &amp;lt;/h2&amp;gt;
        {marked(this.props.children.toString())} // .toString() from React&#39;s wrapped text to a raw string
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But there&amp;rsquo;s a problem! Our rendered comments look like this in the browser: &lt;code&gt;&amp;lt;p&amp;gt;This is &amp;lt;em&amp;gt;another&amp;lt;/em&amp;gt; comment&amp;lt;/p&amp;gt;&lt;/code&gt;. We want those tags to actually render as HTML.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s React protecting you from an &lt;code&gt;XSS&lt;/code&gt; attack. There&amp;rsquo;s a way to get around it but the framework warns you not to use it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var Comment = React.createClass({
  rawMarkup: function() {
    var rawMarkup = marked(this.props.children.toString(), {sanitize: true});
    return { __html: rawMarkup };
  },

  render: function() {
    return (
      &amp;lt;div className=&amp;quot;comment&amp;quot;&amp;gt;
        &amp;lt;h2 className=&amp;quot;commentAuthor&amp;quot;&amp;gt;
          {this.props.author}
        &amp;lt;/h2&amp;gt;
        &amp;lt;span dangerouslySetInnerHTML={this.rawMarkup()} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;mock-up-the-data-model&#34;&gt;Mock up the data model&lt;/h1&gt;

&lt;p&gt;So far we&amp;rsquo;ve been inserting the comments directly in the source code. Instead, let&amp;rsquo;s render a blob of JSON data into the comment list. Eventually this will come from the server, but for now, write it in your source:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var data = [
  {id: 1, author: &amp;quot;Pete Hunt&amp;quot;, text: &amp;quot;This is one comment&amp;quot;},
  {id: 2, author: &amp;quot;Jordan Walke&amp;quot;, text: &amp;quot;This is *another* comment&amp;quot;}
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need to get this data into &lt;code&gt;CommentList&lt;/code&gt; in a modular way. Modify &lt;code&gt;CommentBox&lt;/code&gt; and the &lt;code&gt;ReactDOM.render()&lt;/code&gt; call to pass this data into the &lt;code&gt;CommentList&lt;/code&gt; via props:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var CommentBox = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.props.data} /&amp;gt;
        &amp;lt;CommentForm /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});

ReactDOM.render(
  &amp;lt;CommentBox data={data} /&amp;gt;,
  document.getElementById(&#39;content&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that the data is available in the &lt;code&gt;CommentList&lt;/code&gt;, let&amp;rsquo;s render the comments dynamically:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var CommentList = React.createClass({
  render: function() {
    var commentNodes = this.props.data.map(function(comment) {
      return (
        &amp;lt;Comment author={comment.author} key={comment.id}&amp;gt;
          {comment.text}
        &amp;lt;/Comment&amp;gt;
      );
    });
    return (
      &amp;lt;div className=&amp;quot;commentList&amp;quot;&amp;gt;
        {commentNodes}
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;fetching-from-the-server&#34;&gt;Fetching from the server.&lt;/h1&gt;

&lt;p&gt;We will remove the data prop and replace it with a URL to fetch:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ReactDOM.render(
  &amp;lt;CommentBox url=&amp;quot;/api/comments&amp;quot; /&amp;gt;, document.getElementById(&#39;content&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This component is different from the prior components because it will have to re-render itself.&lt;/p&gt;

&lt;h1 id=&#34;reactive-state&#34;&gt;Reactive state&lt;/h1&gt;

&lt;p&gt;So far, based on its props, each component has rendered itself once. &lt;code&gt;props&lt;/code&gt; are &lt;strong&gt;immutable&lt;/strong&gt;: they are passed from the parent and are &lt;strong&gt;owned&lt;/strong&gt; by the parent.&lt;/p&gt;

&lt;p&gt;To implement &lt;strong&gt;interactions&lt;/strong&gt;, we introduce mutable &lt;strong&gt;state&lt;/strong&gt; to the component. &lt;code&gt;this.state&lt;/code&gt; is private to the component and can be changed by calling &lt;code&gt;this.setState()&lt;/code&gt;. When the state updates, the component re-renders itself.&lt;/p&gt;

&lt;p&gt;When the server fetches data, we will be changing the comment data we have. Let&amp;rsquo;s add an array of comment data to the &lt;code&gt;CommentBox&lt;/code&gt; component as its state:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var CommentBox = React.createClass({
  getInitialState: function() {
    return { data: [] };
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        &amp;lt;CommentForm /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getInitialState()&lt;/code&gt; executes exactly once during the lifecycle of the component and sets up the initial state of the component.&lt;/p&gt;

&lt;h1 id=&#34;updating-state&#34;&gt;Updating state&lt;/h1&gt;

&lt;p&gt;When the component is first created, we want to &lt;code&gt;GET&lt;/code&gt; some &lt;code&gt;JSON&lt;/code&gt; from the server and update the state to reflect the latest data, so once it&amp;rsquo;s fetched, this.state.data will look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;[
  {&amp;quot;author&amp;quot;: &amp;quot;Pete Hunt&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;This is one comment&amp;quot;},
  {&amp;quot;author&amp;quot;: &amp;quot;Jordan Walke&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;This is *another* comment&amp;quot;}
]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var CommentBox = React.createClass({
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({ data: data });
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        &amp;lt;CommentForm /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, &lt;code&gt;componentDidMount&lt;/code&gt; is a method called automatically by React after a component is rendered &lt;em&gt;for the first time&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The key to dynamic updates is the call to &lt;code&gt;this.setState()&lt;/code&gt;. We replace the old array of comments with the new one from the server and the UI automatically updates itself.&lt;/p&gt;

&lt;p&gt;Because of this reactivity, it is only a minor change to add live updates. We will use simple polling here but you could easily use &lt;code&gt;WebSockets&lt;/code&gt; or other technologies.&lt;/p&gt;

&lt;p&gt;After refactoring:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// tutorial14.js
var CommentBox = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        &amp;lt;CommentForm /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});

ReactDOM.render(
  &amp;lt;CommentBox url=&amp;quot;/api/comments&amp;quot; pollInterval={2000} /&amp;gt;,
  document.getElementById(&#39;content&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;adding-new-comments&#34;&gt;Adding new comments&lt;/h1&gt;

&lt;p&gt;Our &lt;code&gt;CommentForm&lt;/code&gt; component should ask the user for their name and comment text and send a request to the server to save the comment:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var CommentForm = React.createClass({
  render: function() {
    return (
      &amp;lt;form className=&amp;quot;commentForm&amp;quot;&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; placeholder=&amp;quot;Your name&amp;quot; /&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; placeholder=&amp;quot;Say something...&amp;quot; /&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Post&amp;quot; /&amp;gt;
      &amp;lt;/form&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will be using &lt;code&gt;this.state&lt;/code&gt; to save the user&amp;rsquo;s input as it is entered. We define an initial state with two properties &lt;em&gt;author&lt;/em&gt; and &lt;em&gt;text&lt;/em&gt; and set them to be empty strings. In our &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; elements, we set the value prop to reflect the state of the component and attach &lt;code&gt;onChange&lt;/code&gt; handlers to them. These &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; elements with a value set are called &lt;em&gt;controlled components&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var CommentForm = React.createClass({
  getInitialState: function() {
    return {author: &#39;&#39;, text: &#39;&#39;};
  },
  handleAuthorChange: function(e) {
    this.setState({author: e.target.value});
  },
  handleTextChange: function(e) {
    this.setState({text: e.target.value});
  },
  render: function() {
    return (
      &amp;lt;form className=&amp;quot;commentForm&amp;quot;&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Your name&amp;quot;
          value={this.state.author}
          onChange={this.handleAuthorChange}
        /&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Say something...&amp;quot;
          value={this.state.text}
          onChange={this.handleTextChange}
        /&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Post&amp;quot; /&amp;gt;
      &amp;lt;/form&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;events-submitting-the-form&#34;&gt;Events, submitting the form&lt;/h1&gt;

&lt;p&gt;React attaches event handlers to components using a &lt;em&gt;camelCase&lt;/em&gt; naming convention. We attach &lt;code&gt;onChange&lt;/code&gt; handlers to the two &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; elements.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s make the form &lt;em&gt;interactive&lt;/em&gt;. When the user &lt;em&gt;submits&lt;/em&gt; the form, we should clear it, submit a request to the server, and refresh the list of comments:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var CommentForm = React.createClass({
  getInitialState: function() {
    return {author: &#39;&#39;, text: &#39;&#39;};
  },
  handleAuthorChange: function(e) {
    this.setState({author: e.target.value});
  },
  handleTextChange: function(e) {
    this.setState({text: e.target.value});
  },
  handleSubmit: function(e) {
    e.preventDefault();
    var author = this.state.author.trim();
    var text = this.state.text.trim();
    if (!text || !author) {
      return;
    }
    // TODO: send request to the server
    this.setState({author: &#39;&#39;, text: &#39;&#39;});
  },
  render: function() {
    return (
      &amp;lt;form className=&amp;quot;commentForm&amp;quot; onSubmit={this.handleSubmit}&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Your name&amp;quot;
          value={this.state.author}
          onChange={this.handleAuthorChange}
        /&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Say something...&amp;quot;
          value={this.state.text}
          onChange={this.handleTextChange}
        /&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Post&amp;quot; /&amp;gt;
      &amp;lt;/form&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;callbacks-as-props-pass-data-from-the-child-component-back-up-to-its-parent&#34;&gt;Callbacks as props, pass data from the child component back up to its parent&lt;/h1&gt;

&lt;p&gt;When a user submits a comment, we will need to refresh the list of comments to include the new one. It makes sense to do all of this logic in &lt;code&gt;CommentBox&lt;/code&gt; since &lt;code&gt;CommentBox&lt;/code&gt; owns the state that represents the list of comments.&lt;/p&gt;

&lt;p&gt;We need to &lt;em&gt;pass data from the child component back up to its parent&lt;/em&gt;. We do this in our parent&amp;rsquo;s render method by passing a new callback &lt;code&gt;handleCommentSubmit&lt;/code&gt; into the child, binding it to the child&amp;rsquo;s &lt;code&gt;onCommentSubmit&lt;/code&gt; event. Whenever the event is triggered, the callback will be invoked:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var CommentBox = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  //--------------------------------------------------
  handleCommentSubmit: function(comment) {
    // TODO: submit to the server and refresh the list
  },
  //--------------------------------------------------
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        //-------------------------------------------------------- 
        &amp;lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&amp;gt;
        //--------------------------------------------------------
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Call the callback from the &lt;code&gt;CommentForm&lt;/code&gt; when the user submits the form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var CommentForm = React.createClass({
  getInitialState: function() {
    return {author: &#39;&#39;, text: &#39;&#39;};
  },
  handleAuthorChange: function(e) {
    this.setState({author: e.target.value});
  },
  handleTextChange: function(e) {
    this.setState({text: e.target.value});
  },
  handleSubmit: function(e) {
    e.preventDefault();
    var author = this.state.author.trim();
    var text = this.state.text.trim();
    if (!text || !author) {
      return;
    }
    //--------------------------------------------------------
    this.props.onCommentSubmit({author: author, text: text});
    //--------------------------------------------------------
    this.setState({author: &#39;&#39;, text: &#39;&#39;});
  },
  render: function() {
    return (
      &amp;lt;form className=&amp;quot;commentForm&amp;quot; onSubmit={this.handleSubmit}&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Your name&amp;quot;
          value={this.state.author}
          onChange={this.handleAuthorChange}
        /&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Say something...&amp;quot;
          value={this.state.text}
          onChange={this.handleTextChange}
        /&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Post&amp;quot; /&amp;gt;
      &amp;lt;/form&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that the callbacks are in place, all we have to do is &lt;em&gt;submit&lt;/em&gt; to the server and refresh the list:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var CommentBox = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  //-----------------------------------------------------------
  handleCommentSubmit: function(comment) {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      type: &#39;POST&#39;,
      data: comment,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  //-----------------------------------------------------------
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        &amp;lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;optimization-optimistic-updates&#34;&gt;Optimization: optimistic updates&lt;/h1&gt;

&lt;p&gt;It feels slow to have to wait for the request to complete before your comment appears in the list. We can optimistically add this comment to the list to make the app feel faster:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var CommentBox = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  handleCommentSubmit: function(comment) {
    //-------------------------------------------------------------------------
    var comments = this.state.data;
    // Optimistically set an id on the new comment. It will be replaced by an
    // id generated by the server. In a production application you would likely
    // not use Date.now() for this and would have a more robust system in place.
    comment.id = Date.now();
    var newComments = comments.concat([comment]);
    this.setState({data: newComments});
    //-------------------------------------------------------------------------
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      type: &#39;POST&#39;,
      data: comment,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        //---------------------------------------------------------------------
        this.setState({data: comments});
        //---------------------------------------------------------------------
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        &amp;lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;demo-app&#34;&gt;Demo app&lt;/h1&gt;

&lt;p&gt;The total result as a demo you can find &lt;a href=&#34;https://plnkr.co/edit/rHTK0XDgpyp3mkSlflcc?p=preview&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Save my day:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://facebook.github.io/react/docs/tutorial.html&#34;&gt;Off site&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>