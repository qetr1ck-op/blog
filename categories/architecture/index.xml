<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Architecture on OP blog</title>
    <link>https://qetr1ck-op.github.io/blog/categories/architecture/index.xml</link>
    <description>Recent content in Architecture on OP blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <atom:link href="https://qetr1ck-op.github.io/blog/categories/architecture/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>advanced nodejs</title>
      <link>https://qetr1ck-op.github.io/blog/post/advanced-nodejs/</link>
      <pubDate>Tue, 02 May 2017 20:16:35 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/advanced-nodejs/</guid>
      <description>&lt;p&gt;This course will teach you the core Node.js concepts and API modules from simple utility modules all the way to streams and clusters.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;!--toc--&gt;

&lt;h1 id=&#34;node-javascript&#34;&gt;Node != Javascript&lt;/h1&gt;

&lt;h2 id=&#34;node-s-architecture&#34;&gt;Node&amp;rsquo;s architecture&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Node VMs: &lt;code&gt;V8&lt;/code&gt;, &lt;code&gt;Chakra&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;V8 Feature Groups: &lt;code&gt;shipping&lt;/code&gt;, &lt;code&gt;staged (--harmony)&lt;/code&gt;, &lt;code&gt;inprogress (--harmony_for_in)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;All V8 options &lt;code&gt;node --v8-options | less&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Node&amp;rsquo;s architecture diagram: &lt;code&gt;V8&lt;/code&gt; and &lt;code&gt;libuv&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;node-s-cli-and-repl&#34;&gt;Node&amp;rsquo;s CLI and REPL&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Autocomplete feature&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_&lt;/code&gt; as last evaluated value&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; repl commands&lt;/li&gt;
&lt;li&gt;&lt;code&gt;repl&lt;/code&gt; module&lt;/li&gt;
&lt;li&gt;Node&amp;rsquo;s available list commands &lt;code&gt;node --help | less&lt;/code&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;global-object-process-buffer&#34;&gt;&amp;ldquo;global&amp;rdquo; Object, &amp;ldquo;Process&amp;rdquo;, &amp;ldquo;Buffer&amp;rdquo;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;local vs &lt;code&gt;global&lt;/code&gt; scope&lt;/li&gt;
&lt;li&gt;&lt;code&gt;process&lt;/code&gt; as a bridge between Node app and its running env

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;process.versions&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;process.release.lts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;process.env&lt;/code&gt; as &lt;code&gt;PATH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;using as &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/1.5/index.js&#34;&gt;configuration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;process&lt;/code&gt; is an &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/1.5/process.js&#34;&gt;event emitter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Buffer&lt;/code&gt; is essentially a used to work with binary streams of data.

&lt;ul&gt;
&lt;li&gt;read length &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/1.5/buffer.js&#34;&gt;Buffer.from&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;can use similar method as on array, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/1.5/buff.slice.js&#34;&gt;slice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string_decoder&lt;/code&gt; module provides an API for decoding Buffer objects into strings in a manner that preserves encoded multi-byte UTF-8 and UTF-16 characters, [example]()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;how-require-actually-works&#34;&gt;How &amp;ldquo;require&amp;rdquo; actually works&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Steps: resolving -&amp;gt; loading -&amp;gt; wrapping -&amp;gt; evaluating -&amp;gt; caching&lt;/li&gt;
&lt;li&gt;&lt;code&gt;module&lt;/code&gt; module, &lt;code&gt;module.path&lt;/code&gt;, &lt;code&gt;module.parent&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;require.resolve&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;algorithm of &lt;code&gt;require&lt;/code&gt; search&lt;/li&gt;
&lt;li&gt;&lt;code&gt;module.exports&lt;/code&gt; = &lt;code&gt;exports&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;module.loaded&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/1.6/index.js&#34;&gt;examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;json-and-c-addons&#34;&gt;JSON and C++ addons&lt;/h2&gt;

&lt;h2 id=&#34;wrapping-and-caching-modules&#34;&gt;Wrapping and Caching modules&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;require(&#39;module&#39;).wrapper&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;require.main === module&lt;/code&gt; with CLI and requiring module &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/1.8/printStars.js&#34;&gt;printStars.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;delete &lt;code&gt;require.cache&lt;/code&gt; or &lt;code&gt;module.exports&lt;/code&gt; as a function&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;know-your-npm&#34;&gt;Know your npm&lt;/h2&gt;

&lt;h1 id=&#34;concurrency-model-and-event-loop&#34;&gt;Concurrency model and Event Loop&lt;/h1&gt;

&lt;h2 id=&#34;what-is-i-o-anyway&#34;&gt;What is I/O anyway?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;the definition&lt;/li&gt;
&lt;li&gt;node architecture in I/O&lt;/li&gt;
&lt;li&gt;handling slow I/O operation: synchronous, &lt;code&gt;fork()&lt;/code&gt; for new process, threads (problem with sharing resources), event loop&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-event-loop&#34;&gt;The Event Loop&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;the definition&lt;/li&gt;
&lt;li&gt;the visualization&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-call-stack&#34;&gt;The Call Stack&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;the definition&lt;/li&gt;
&lt;li&gt;the visualization&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;handling-slow-operation&#34;&gt;Handling slow operation&lt;/h2&gt;

&lt;h2 id=&#34;how-callbacks-actually-work&#34;&gt;How callbacks actually work&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;the visualization&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;settimeout-setimmediate-process-nexttick&#34;&gt;&amp;ldquo;setTimeout&amp;rdquo;, &amp;ldquo;setImmediate&amp;rdquo;, &amp;ldquo;process.nextTick&amp;rdquo;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/2.7/nextTick.js&#34;&gt;example&lt;/a&gt; how to handle async error&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setTimeout&lt;/code&gt; vs &lt;code&gt;setImmediate&lt;/code&gt; vs &lt;code&gt;process.nextTick&lt;/code&gt;, visual explanation [&lt;a href=&#34;http://stackoverflow.com/questions/17502948/nexttick-vs-setimmediate-visual-explanation#38742776&#34;&gt;http://stackoverflow.com/questions/17502948/nexttick-vs-setimmediate-visual-explanation#38742776&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setImmediate&lt;/code&gt; executes after &lt;code&gt;setTimeout&lt;/code&gt;, &lt;a href=&#34;https://github.com/nodejs/node-v0.x-archive/issues/25788&#34;&gt;explanation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;node-s-event-driven-architecture&#34;&gt;Node&amp;rsquo;s Event-driven architecture&lt;/h1&gt;

&lt;h2 id=&#34;callback-promises-async-await&#34;&gt;&amp;ldquo;Callback&amp;rdquo;, &amp;ldquo;Promises&amp;rdquo;, &amp;ldquo;async/await&amp;rdquo;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Async != Callback&lt;/li&gt;
&lt;li&gt;async &lt;code&gt;callback&lt;/code&gt; &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/3.1/async-callback.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;async &lt;code&gt;promise&lt;/code&gt; and &lt;code&gt;async/await&lt;/code&gt; &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/3.1/async-promise.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;event-emitter&#34;&gt;Event Emitter&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;sync events &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/3.2/sync-events.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;async events &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/3.2/async-events.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;arguments-errors-order-of-listeners&#34;&gt;Arguments, Errors, Order of Listeners&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; event&lt;/li&gt;
&lt;li&gt;handling error with &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;uncaughtException&lt;/code&gt;, register listener with &lt;code&gt;once&lt;/code&gt; method, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/3.3/errors.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;order of invoke listeners, &lt;code&gt;prependListener&lt;/code&gt;, &lt;code&gt;removeListener&lt;/code&gt;, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/3.3/order.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Task List Management &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/tree/master/3.4&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;node-for-networking&#34;&gt;Node for Networking&lt;/h1&gt;

&lt;h2 id=&#34;tcp-networking-with&#34;&gt;TCP networking with&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;net&lt;/code&gt; module, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/4.1/net.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;working-with-multiple-sockets&#34;&gt;Working with multiple sockets&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/4.2/net.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;improving-the-chat-server&#34;&gt;Improving the chat server&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;remove logging message to ourself, adding names, timestamp, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/4.3/chat.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-dns-module&#34;&gt;The DNS module&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lookup&lt;/code&gt;, &lt;code&gt;resolve&lt;/code&gt;, &lt;code&gt;reverse&lt;/code&gt; methods &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/4.4/dns.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;udp-sockets&#34;&gt;UDP sockets&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dgram&lt;/code&gt; module and creating event emitter by &lt;code&gt;dgram.createSocket(&#39;udp4&#39;)&lt;/code&gt;, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/4.5/udp.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;node-for-web&#34;&gt;Node for Web&lt;/h1&gt;

&lt;h2 id=&#34;the-basic-streaming-http-server&#34;&gt;The basic streaming HTTP server&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http.createServer&lt;/code&gt; as an event emitter, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/5.1/http.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;working-with-https&#34;&gt;Working with HTTPS&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;create key and certificate with &lt;code&gt;openssl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;working with &lt;code&gt;https&lt;/code&gt;, &lt;a href=&#34;https://github.com/qetr1ck-op/advanced-nodejs/blob/master/5.2/https.js&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;Node&amp;rsquo;s Common built-in modules&lt;/li&gt;
&lt;li&gt;Working with streams&lt;/li&gt;
&lt;li&gt;Cluster adn Child Process&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Mastering Flux and Redux</title>
      <link>https://qetr1ck-op.github.io/blog/post/mastering-flux-and-redux/</link>
      <pubDate>Tue, 02 May 2017 19:38:57 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/mastering-flux-and-redux/</guid>
      <description>

&lt;p&gt;At the core of any solid web application is an effective and well-managed data model. In this course, Mastering Flux and Redux, you&amp;rsquo;ll learn the skills and technologies necessary to manage your application&amp;rsquo;s data model in extremely efficient and standards-compliant ways.&lt;/p&gt;

&lt;h1 id=&#34;topics&#34;&gt;Topics&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;First, you&amp;rsquo;ll learn all about the popular data-modeling libraries Flux and Redux; their differences and similarities, how they relate to one another, and which is appropriate for what kind of projects.&lt;/li&gt;
&lt;li&gt;Next, you&amp;rsquo;ll apply what you&amp;rsquo;ve learned in four modules packed with hands-on demos where you will build a 3-part Flux and Redux application featuring a message board, a TodoMVC page, and a control panel.&lt;/li&gt;
&lt;li&gt;Then, you&amp;rsquo;ll explore the skills needed to create any Flux or Redux application, modeling changes with actions, and developing idempotent functions for reducers.&lt;/li&gt;
&lt;li&gt;Finally, you&amp;rsquo;ll create Redux stores with reducers and middleware, combining reducers, using and implementing a dispatcher, and much more.&lt;/li&gt;
&lt;li&gt;When you&amp;rsquo;re finished, you&amp;rsquo;ll have a deep understanding of both Flux and Redux, allowing you to implement them for any project you choose, integrate seamlessly into any workplace project employing either of these technologies, and get started towards developing your own implementations and middleware.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;link&#34;&gt;Link&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://app.pluralsight.com/library/courses/flux-redux-mastering/table-of-contents&#34;&gt;Pluralsight - Course&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/danielstern/flux-redux&#34;&gt;Github - repo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>npm scrips as your build tool</title>
      <link>https://qetr1ck-op.github.io/blog/post/npm-scrips-as-your-build-tool/</link>
      <pubDate>Sat, 29 Apr 2017 12:14:14 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/npm-scrips-as-your-build-tool/</guid>
      <description>&lt;p&gt;The course introduces the topic of using npm scripts as a build tool. It starts simple and then continue to build a small website as we introduce new topics.&lt;/p&gt;

&lt;p&gt;By the end of the course, you&amp;rsquo;ll know how to get started and what tools and techniques are needed for you to create your own set of build scripts.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;topics&#34;&gt;Topics:&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Create a basic &lt;code&gt;package.json&lt;/code&gt; file&lt;/li&gt;
&lt;li&gt;Run the basic npm scripts&lt;/li&gt;
&lt;li&gt;Create a custom npm script&lt;/li&gt;
&lt;li&gt;Run npm scripts in &lt;code&gt;series&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run npm scripts in &lt;code&gt;parallel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use a shorthand syntax for running multiple npm scripts with &lt;code&gt;npm-run-all&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run a set of similar npm scripts with a &lt;code&gt;wildcard&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;pre&lt;/code&gt; and &lt;code&gt;post&lt;/code&gt; npm script lifecycle hooks with test coverage&lt;/li&gt;
&lt;li&gt;Pass arguments to npm scripts via &lt;code&gt;--&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Pipe data from one npm script to another with build-site scripts&lt;/li&gt;
&lt;li&gt;Run npm scripts when files change with &lt;code&gt;onchange&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use package.json &lt;code&gt;variables&lt;/code&gt; in npm scripts&lt;/li&gt;
&lt;li&gt;Use custom config settings in your npm scripts&lt;/li&gt;
&lt;li&gt;Run npm scripts with git hooks using &lt;code&gt;husky&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Change the level of console output when running npm scripts&lt;/li&gt;
&lt;li&gt;Make npm scripts cross-environment friendly with &lt;code&gt;cross-env&lt;/code&gt;, &lt;code&gt;rimraf&lt;/code&gt;, &lt;code&gt;opn-cli&lt;/code&gt;, &lt;code&gt;cross-var&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;List available npm scripts and support tab completion with &lt;code&gt;ntl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add comments to your npm scripts&lt;/li&gt;
&lt;li&gt;Pull out npm scripts into another file with &lt;code&gt;p-s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Create a &lt;code&gt;bash script&lt;/code&gt; to replace a complex npm script&lt;/li&gt;
&lt;li&gt;Create a &lt;code&gt;node script&lt;/code&gt; to replace a complex npm script&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;links&#34;&gt;Links&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://egghead.io/courses/how-to-use-npm-scripts-as-your-build-tool&#34;&gt;egghead course - How to Use npm Scripts as Your Build Tool&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Essential Programming Books</title>
      <link>https://qetr1ck-op.github.io/blog/post/essential-programming-books/</link>
      <pubDate>Sun, 23 Apr 2017 22:35:48 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/essential-programming-books/</guid>
      <description>&lt;p&gt;The list of 129 books deemed fundamental to the art of programming and includes books for various languages.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;link&#34;&gt;Link&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.goodreads.com/list/show/542.Essential_Programming_Books?page=1&#34;&gt;good reads&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Front End Handbook 2017</title>
      <link>https://qetr1ck-op.github.io/blog/post/front-end-handbook-2017/</link>
      <pubDate>Sun, 23 Apr 2017 19:11:25 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/front-end-handbook-2017/</guid>
      <description>&lt;p&gt;This is a guide that anyone could use to learn about the practice of front-end development. It broadly outlines and discusses the practice of front-end engineering: how to learn it and what tools are used when practicing it in 2017&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The handbook is divided into three parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Part I. The Front-End Practice

&lt;ul&gt;
&lt;li&gt;Part one broadly describes the practice of front-end engineering.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Part II: Learning Front-End Development

&lt;ul&gt;
&lt;li&gt;Part two identifies self-directed and direct resources for learning to become a front-end developer.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Part III: Front-End Development Tools

&lt;ul&gt;
&lt;li&gt;Part three briefly explains and identifies tools of the trade.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;link&#34;&gt;Link&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://frontendmasters.com/books/front-end-handbook/2017/&#34;&gt;read online&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Favicon generator</title>
      <link>https://qetr1ck-op.github.io/blog/post/simple-favicon-generator/</link>
      <pubDate>Sun, 09 Apr 2017 20:23:14 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/simple-favicon-generator/</guid>
      <description>&lt;p&gt;With so many platforms and icons, it&amp;rsquo;s hard to know exactly what you should do. What are the dimensions of favicon.ico? How many Touch icons do I need? RealFaviconGenerator did the research and testing for you.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;link&#34;&gt;Link&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://realfavicongenerator.net/&#34;&gt;realfavicongenerator.net&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>A static site with a dynamic search function</title>
      <link>https://qetr1ck-op.github.io/blog/post/static-site-with-a-dynamic-search/</link>
      <pubDate>Sun, 09 Apr 2017 12:09:08 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/static-site-with-a-dynamic-search/</guid>
      <description>&lt;p&gt;A static site with a dynamic search function? Yes. Alternatively to embeddable scripts from Google or other search engines you can provide your visitors a custom search by indexing your content files directly.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;hugo-lunr&#34;&gt;hugo-lunr&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/hugo-lunr&#34;&gt;hugo-lunr&lt;/a&gt; - A simple way to add site search to your static Hugo site using &lt;a href=&#34;https://github.com/olivernn/lunr.js&#34;&gt;lunr.js&lt;/a&gt;. Hugo-lunr will create an index file of any html and markdown documents in your Hugo project&lt;/p&gt;

&lt;h1 id=&#34;implementation&#34;&gt;implementation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/qetr1ck-op/blog-hugo-source/blob/master/themes/hugo-code-theme/layouts/partials/search.html&#34;&gt;source code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://rayhightower.com/blog/2016/01/04/how-to-make-lunrjs-jekyll-work-together/&#34;&gt;How to Make lunr.js and Jekyll Work Together (with Gotchas)&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JS 30</title>
      <link>https://qetr1ck-op.github.io/blog/post/Js-30/</link>
      <pubDate>Tue, 04 Apr 2017 14:51:54 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/Js-30/</guid>
      <description>&lt;p&gt;To fresh memory with &lt;a href=&#34;https://javascript30.com/&#34;&gt;30 day vanilla js coding challenge&lt;/a&gt;. Build 30 things in 30 days with 30 tutorials. No Frameworks, No Compilers, No Libraries, No Boilerplate!&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;description&#34;&gt;Description&lt;/h1&gt;

&lt;p&gt;How do you get better?&lt;/p&gt;

&lt;p&gt;Build things. Lots of things. Build 1,000 things. Keep it up and don&amp;rsquo;t stop. Seriously.&lt;/p&gt;

&lt;p&gt;This has always been my advice. Just put in the work and you will get better.&lt;/p&gt;

&lt;p&gt;But Wes, what should I build? I have no ideas! Please don&amp;rsquo;t make me do another todo app.&lt;/p&gt;

&lt;p&gt;Ideas, Eh? I&amp;rsquo;ve got lots! This is JavaScript30 — let&amp;rsquo;s build 30 things together.&lt;/p&gt;

&lt;h1 id=&#34;done-challenges&#34;&gt;Done challenges&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../html/js-30/01-drum-kit/index.html&#34;&gt;01 - Drum kit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../html/js-30/02-js-and-css-clock/index.html&#34;&gt;02 - CSS + JS clock&lt;/a&gt;, &lt;a href=&#34;http://thenewcode.com/943/An-SVG-Analog-Clock-In-6-Lines-of-JavaScript&#34;&gt;SVG + JS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../html/js-30/03-css-variables/index.html&#34;&gt;03 - CSS variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../html/js-30/04-array-cardio-day1/index.html&#34;&gt;04 - Array Cardio Day 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../html/js-30/05-flex-panel-gallery/index.html&#34;&gt;05 - Flex panel gallery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../html/js-30/06-type-ahead/index.html&#34;&gt;06 - AJAX Type Ahead&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../html/js-30/07-array-cardio-day2/index.html&#34;&gt;07 - Array Cardio Day 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../html/js-30/08-fun-with-html5-canvas/index.html&#34;&gt;08 - Fun with HTML5 Canvas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../html/js-30/09-dev-tools-domination/index.html&#34;&gt;09 - Dev Tools Domination&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../html/js-30/10-hold-shift-and-check-checkboxes/index.html&#34;&gt;10 - Hold Shift and Check Checkboxes&lt;/a&gt;, &lt;a href=&#34;http://plnkr.co/edit/NthETyzybeilD13jen4y?p=preview&#34;&gt;With Ctrl example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../html/js-30/11-custom-video-player/index.html&#34;&gt;11 - Custom Video Player&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../html/js-30/12-key-sequence-detection/index.html&#34;&gt;12 - Key Sequence Detection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../html/js-30/13-slide-in-on-scroll/index.html&#34;&gt;13 - Slide in on Scroll&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../html/js-30/14-js-references-vs-copying/index.html&#34;&gt;14 - JavaScript References VS Copying&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../html/js-30/15-local-storage/index.html&#34;&gt;15 - LocalStorage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../html/js-30/16-mouse-move-shadow/index.html&#34;&gt;16 - Mouse Move Shadow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/wesbos/JavaScript30&#34;&gt;Github original source&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Building a JavaScript development environment</title>
      <link>https://qetr1ck-op.github.io/blog/post/building-a-javaScript-development-environment/</link>
      <pubDate>Sun, 02 Apr 2017 14:31:50 +0300</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/building-a-javaScript-development-environment/</guid>
      <description>&lt;p&gt;Starting a new JavaScript project from scratch is overwhelming. This course provides a playbook outlining the key decisions you need to make. Build a robust development environment that handles bundling, linting, transpiling, testing, and much more.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;description&#34;&gt;Description&lt;/h1&gt;

&lt;p&gt;Building a JavaScript application from scratch today is overwhelming. You have to make decisions about package management, bundling, linting, transpiling, automated testing, and much more. There are literally over 40 important decisions to consider. This course is a playbook of potential options that provides a clear path through the key decisions. Along the way, we&amp;rsquo;ll build a robust automated development environment from the ground up using ES6. You’ll learn how to set up a reusable development environment that provides a powerful foundation for future projects, that’s tailored just for your team’s needs.&lt;/p&gt;

&lt;h1 id=&#34;link&#34;&gt;Link&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.pluralsight.com/courses/javascript-development-environment&#34;&gt;course on pluralsight&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PatternCraft</title>
      <link>https://qetr1ck-op.github.io/blog/post/pattern-craft/</link>
      <pubDate>Sun, 05 Mar 2017 01:35:33 +0200</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/pattern-craft/</guid>
      <description>&lt;p&gt;An awesome explanation of GOF design patterns. The only way to learn pattern is to know what problem it solves.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;state&#34;&gt;State&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.youtube.com/watch?v=yZt7mUVDijU&#34;&gt;State Design Pattern&lt;/a&gt; can be used, for example, to manage the state of tank in StarCraft game.&lt;/p&gt;

&lt;p&gt;The pattern consists in isolating the state logic in different &lt;code&gt;class&lt;/code&gt;es than having multiple &lt;code&gt;if&lt;/code&gt;s to determinate the flow.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class TankState {
    constructor(damage = 5, canMove = true) {
        Object.assign(this, { damage, canMove });
    }

    static get defaultState() { return new SiegeState(); }
}

// state #1
class SiegeState extends TankState {
    constructor() {
        super(20, false);
    }
}

// state #2
class SpeedState extends TankState {
    constructor() {
        super(5, true);
    }
}

class Tank {
    constructor() {
        this.state = TankState.defaultState;
    }

    // implementation bellow relies only on current state, without using multiple if/switch
    get canMove() { return this.state.canMove; } 

    get damage() { return this.state.damage; }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test specs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;describe(&#39;State pattern&#39;, () =&amp;gt; {
    it(&#39;Default tank state is SiegeState&#39;, () =&amp;gt; {
        const tank = new Tank();
        
        expect(tank.state instanceof SiegeTank).to.be.true;
    });

    it(&#39;SiegeState&#39;, () =&amp;gt; {
        const tank = new SiegeState();

        expect(tank.damage).to.equal(20);
        expect(tank.canMove).to.be.false;
    });

    it(&#39;SpeedState&#39;, () =&amp;gt; {
        const tank = new SpeedState();

        expect(tank.damage).to.equal(5);
        expect(tank.canMove).to.be.true;
    });
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;strategy&#34;&gt;Strategy&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.youtube.com/watch?v=MOEsKHqLiBM&#34;&gt;Strategy Design Pattern&lt;/a&gt; can be used, for example, to determinate how a unit moves in StarCraft game.&lt;/p&gt;

&lt;p&gt;The pattern consists in having different strategy for one functionality. A unit, for example, can move by walking or flying or swimming.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// strategy #1
class Walk() {
    move(unit) {
        unit.position += 5;
    }
}
// strategy #2
class Fly() {
    move(unit) {
        unit.position += 20;
    }
}

class Viking {
    constructor() {
        this.moveBehavior = new Walk();
        this.position = 0;
    }

    move() { this.moveBehavior.move(this); } // delegate behavior to strategy
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test specs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;describe(&#39;Strategy pattern&#39;, () =&amp;gt; {
    it(&#39;Default viking move behavior is Walk&#39;, () =&amp;gt; {
        const viking = new Viking();
        
        expect(viking.moveBehavior instanceof Walk).to.be.true;
    });

    it(&#39;Walk behavior&#39;, () =&amp;gt; {
        const viking = new Viking();

        viking.move();
        expect(viking.position).to.equal(5);
        viking.move();
        expect(viking.position).to.equal(10);
    });

    it(&#39;Fly behavior&#39;, () =&amp;gt; {
        const viking = new Viking();
        
        viking.moveBehavior = new Fly();
        viking.move();
        expect(viking.position).to.equal(20);
        viking.move();
        expect(viking.position).to.equal(40);
    });
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;adapter&#34;&gt;Adapter&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.youtube.com/watch?v=hvpXKZhNINc&#34;&gt;Adapter Design Pattern&lt;/a&gt; can be used, to insert an external character in the game.&lt;/p&gt;

&lt;p&gt;The pattern consists in having a wrapper class to adapt the external source.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// in app characters
class Marine {
  attack(target) {
    target.health -= 6;
  }
}

class Zealot {
  attack(target) {
    target.health -= 8;
  }
}

class Zergling {
  attack(target) {
    target.health -= 5;
  }
}

// external
class Mario {
  jumpAttack() {
    console.log(&#39;Mamamia!&#39;);
    return 3;
  }
}

// mario adapter
class MarioAdapter {
    constructor(mario) {
        this.mario = mario;
    }
    
    attack(target) {
        target.health -= this.mario.jumpAttack();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test specs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;describe(&#39;Adapter pattern&#39;, () =&amp;gt; {
    it(&#39;Mario can not attack&#39;, () =&amp;gt; {
        const mario = new Mario();
        
        expect(mario.attack).to.be.undefined;
    });

    it(&#39;MarioAdapter can attack&#39;, () =&amp;gt; {
        const mario = new MarioAdapter();
        const target = { health: 50 };

        mario.attack(target);

        expect(target.health).to.equal(47);
    });
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;visitor&#34;&gt;Visitor&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.youtube.com/watch?v=KSEyIXnknoY&#34;&gt;Strategy Design Pattern&lt;/a&gt; can be used, for example, to determinate how an attack deals a different amount of damage to unit in StarCraft game.&lt;/p&gt;

&lt;p&gt;The pattern delegates the responsibilities to different &lt;code&gt;class&lt;/code&gt;. When a unit takes a damage it can say to the &lt;code&gt;visitor&lt;/code&gt; what do with itself.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Soldier {
    constructor(health = 100) {
        Object.assign(this, { health });
    }
}

class Marine extends Soldier {
    constructor() {
        super();
    }
    
    // an idiomatic name
    accept(visitor) {
        visitor.visitLight(this);
    }
}

class Marauder extends Soldier {
    constructor() {
        super(180);
    }
    
    accept(visitor) {
        visitor.visitArmored(this);
    }
}

// visitor
class TankBullet {
    visitLight(unit) {
        unit.health -= 11;
    }
    visitArmored(unit) {
        unit.health -= 32;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test specs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;describe(&#39;Visitor pattern&#39;, () =&amp;gt; {
    it(&#39;Visit light&#39;, () =&amp;gt; {
        const marine = new Marine();
        const tankBullet = new TankBullet();
        
        tankBullet.visitLight(marine);

        expect(mario.health).to.be(89);
    });

    it(&#39;Visit armored&#39;, () =&amp;gt; {
        const marauder = new Marauder();
        const tankBullet = new TankBullet();
        
        tankBullet.visitArmored(marauder);

        expect(mario.health).to.be(148);
    });
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;decorator&#34;&gt;Decorator&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.youtube.com/watch?v=17XTOODeWQE&#34;&gt;Decorator Design Pattern&lt;/a&gt; can be used, for example, to manage upgrades.&lt;/p&gt;

&lt;p&gt;The pattern is consists in upgrade your base class with extra functionality.&lt;/p&gt;

&lt;p&gt;A decorator will receive an instance of base class and use it to call a new thing you want.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Marine {
    constructor(_damage, _armor) {
        Object.assign(this, { _damage, _armor });
    }

    get damage { return this._damage; }
    get armor { return this._armor; }
}

// decorator #1
class WeaponUpgrade {
    constructor(unit) {
        this.unit = unit;
    }

    get damage { return this.unit.damage + 1; }
    get armor { return this.unit.armor; }
}

// decorator #2
class ArmorUpgrade {
    constructor(unit) {
        this.unit = unit;
    }

    get damage { return this.unit.damage; }
    get armor { return this.unit.armor + 1; }
}

let marine = new Marine();
marine = new WeaponUpgrade(marine);
marine = new WeaponUpgrade(marine);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test specs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;describe(&#39;Decorator pattern&#39;, () =&amp;gt; {
    it(&#39;Weapon upgrade&#39;, () =&amp;gt; {
        let marine = new Marine(10, 2);
        
        marine = new WeaponUpgrade(marine);
        marine = new WeaponUpgrade(marine);

        expect(marine.damage).to.be(12);
        expect(marine.armor).to.be(2);
    });

    it(&#39;Armor upgrade&#39;, () =&amp;gt; {
        let marine = new Marine(10, 2);
        
        marine = new ArmorUpgrade(marine);
        marine = new ArmorUpgrade(marine);

        expect(marine.armor).to.be(4);
        expect(marine.damage).to.be(10);
    });
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;strategy-1&#34;&gt;Strategy&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.youtube.com/watch?v=MOEsKHqLiBM&#34;&gt;Strategy Design Pattern&lt;/a&gt; can be used, for example, to queue actions.&lt;/p&gt;

&lt;p&gt;The pattern consists in isolating command logic in a class so it can:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;queue: you can queue actions to move a probe to a different locations&lt;/li&gt;
&lt;li&gt;undone: you can tell a probe to build something and then call a stop command to undo the action&lt;/li&gt;
&lt;li&gt;validate: you can check if the action can be executed or not, you can not move if building action is in progress&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Probe {
    constructor(commands = [], minerals = 0, x = 0, y = 0) {
        Object.assign(this, {
            position: { x, y },
            commands,
            minerals
        });
    }

    move(x, y) {
        this.commands = [...this.commands, new MoveCommand(this, x, y)];
    }

    gather() {
        this.commands = [...this.commands, new GatherCommand(this)];
    }
}

// command #1
class MoveCommand {
    constructor(unit, x, y) {
        Object.assign(this, { unit, x, y});
    }

    // idiomatic 
    execute() {
        this.unit.position.x = this.x;
        this.unit.position.y = this.y;
    }
}

// command #2
class GatherCommand {
    constructor(unit) {
        this.unit = unit;
    }

    execute() {
        if (this.canExecute) {
            this.unit.minerals += 5;
        }
    }

    get canExecute() {
        return this.unit.minerals === 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test specs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;describe(&#39;Command pattern&#39;, () =&amp;gt; {
    it(&#39;MoveCommand should move unit&#39;, () =&amp;gt; {
        const unit = new Probe();
        const moveBehavior = new MoveBehavior(unit, 10, 20);

        moveBehavior.execute();

        expect(unit.position.x).to.equal(10);
        expect(unit.position.y).to.equal(20);
    });

    it(&#39;GatherCommand should gather resources&#39;, () =&amp;gt; {
        const unit = new Probe();
        const moveBehavior = new GatherBehavior(unit);

        moveBehavior.execute();

        expect(unit.materials).to.equal(5);
    });

    it(&#39;GatherCommand should only gather resources if unit does not have resources&#39;, () =&amp;gt; {
        const unit = new Probe();
        const moveBehavior = new GatherBehavior(unit);

        expect(unit.materials).to.equal(5);
        moveBehavior.execute();
        expect(unit.materials).to.equal(5);
        moveBehavior.execute();
        expect(unit.materials).to.equal(5);
    });
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;proxy&#34;&gt;Proxy&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.youtube.com/watch?v=WcAV9rOGjxw&#34;&gt;Proxy Design Pattern&lt;/a&gt; can be used, for example, to create a &lt;code&gt;drone&lt;/code&gt; by using a proxy &lt;code&gt;cocoon&lt;/code&gt; class.&lt;/p&gt;

&lt;p&gt;The pattern is responsible (&amp;ldquo;stands in&amp;rdquo;) for all requests on original object, typical extend or change behavior, than delegates action again to original object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// original
class Drone {
    move(x, y) {
        this.x = x;
        this.y = y;
    }
}

// proxy
class Cocoon {
    constructor() {
        this.lifetime = 3000;
        // proxing
        this.hatchDrone();
    }

    hatchDrone() {
        setTimeout(this.onHatchDroneDone.bind(this), this.lifetime);
    }
    
    onHatchDroneDone() {
      this.drone = new Drone();
      this.drone.move(this.rallyPath.x, this.rallyPath.y);
    }

    move(x, y) {
        if (this.drone) {
            this.drone.move(x, y);
        } else {
          this.rallyPath = { x, y };
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;describe(&#39;Proxy pattern&#39;, () =&amp;gt; {
    it(&#39;Create drone when cocoon is hatched&#39;, done =&amp;gt; {
        const drone = new Cocoon();
        
        drone.move(10, 20);

        expect(drone.drone).to.be.undefined;
        expect(drone.rallyPath).to.be({ x: 10, y: 20 });

        setTimeout(() =&amp;gt; {
            expect(drone.drone).to.be.defined;
            expect(drone.drone.x).to.be.equal(10);
            expect(drone.drone.y).to.be.equal(20);
            done();
        }, drone.lifetime)
    });

    it(&#39;Visit armored&#39;, () =&amp;gt; {
        const marauder = new Marauder();
        const tankBullet = new TankBullet();
        
        tankBullet.visitArmored(marauder);

        expect(mario.health).to.be(148);
    });
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A classical JS example to proxing, for example, HTTP request by adding logging before every action:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// proxy
const proxiedFetch = fetch;

fetch = (url) =&amp;gt; {
    // proxing
    console.log(&#39;logging...&#39;);
    // original
    proxiedFetch(url);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save my day:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PL8B19C3040F6381A2&#34;&gt;Original series of John Lindquist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sourcemaking.com/design_patterns&#34;&gt;Just a great resource of Design Patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>RESTful Web Services with Node.js and Express</title>
      <link>https://qetr1ck-op.github.io/blog/post/RESTful-Web-Services-with-Node-js-and-Express/</link>
      <pubDate>Sun, 18 Dec 2016 12:01:04 +0000</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/RESTful-Web-Services-with-Node-js-and-Express/</guid>
      <description>&lt;p&gt;Node.js is a simple and powerful tool for backend development. When combined with express, you can create lightweight, fast, scalable APIs quickly and simply.
&lt;/p&gt;

&lt;h1 id=&#34;what-is-rest-anyway&#34;&gt;What is REST anyway?&lt;/h1&gt;

&lt;p&gt;The term &lt;strong&gt;RE&lt;/strong&gt;presentational &lt;strong&gt;S&lt;/strong&gt;tate &lt;strong&gt;T&lt;/strong&gt;ransfer came from a dissertation written by Roy Fielding back in 2000.
He described a series of constraints that should be in place whenever two systems talk to each other.&lt;/p&gt;

&lt;p&gt;So ultimately REST is just a series of rules in place for your server, so everyone who uses your service understand
what it does and how it works.&lt;/p&gt;

&lt;h1 id=&#34;the-uniform-interface&#34;&gt;The Uniform interface&lt;/h1&gt;

&lt;p&gt;Whenever you&amp;rsquo;re dealing with RESTful service you&amp;rsquo;ll be dealing with a resource or resources and all that really means
is you&amp;rsquo;re dealing with with &lt;strong&gt;nouns&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Uniform resource are built around things, not actions.&lt;/p&gt;

&lt;p&gt;For example dealing with books as a resource, the url be &lt;code&gt;http://domain/books&lt;/code&gt;. With authors it would be &lt;code&gt;/authors&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The another part of uniform interface are HTTP &lt;strong&gt;verbs&lt;/strong&gt; that we use in our request will dictate the type of activity
we&amp;rsquo;re trying to do on the resource:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GET&lt;/code&gt; will simply request data (&lt;code&gt;/books&lt;/code&gt; get all or &lt;code&gt;/books/:id&lt;/code&gt; a unique book)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST&lt;/code&gt; uses to add data (&lt;code&gt;/books&lt;/code&gt; add new book)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DELETE&lt;/code&gt; will remove an entity (&lt;code&gt;books/:id&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PUT&lt;/code&gt; is used for update or replace a resource&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PATCH&lt;/code&gt; updates piece of that resource&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The last part of interface is HATEOS (Hypermedia as the Engine of Application State). Basically all that means is
that in each request will be a set of hyperlinks that you can use to navigate the API. In example, what type of
actions you can do on a particular resource.&lt;/p&gt;

&lt;h1 id=&#34;the-project&#34;&gt;The project&lt;/h1&gt;

&lt;p&gt;The project walk through how to stand up a lightweight Express server serving truly RESTful services using &lt;code&gt;Node.js&lt;/code&gt;, &lt;code&gt;Mongoose&lt;/code&gt;, and &lt;code&gt;MongoDB&lt;/code&gt;.
There are implemented all of the RESTful verbs to get, add, and update data with working through unit and e2e-integration tests for our services.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/qetr1ck-op/RESTful-Web-Services-with-Node.js-and-Express&#34;&gt;Link on GitHub&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Save my day:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://app.pluralsight.com/library/courses/node-js-express-rest-web-services/description&#34;&gt;RESTful Web Services with Node.js and Express&lt;/a&gt; by Jonathan Mills on pluralsight&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Book: &#39;Node.js design pattern&#39;</title>
      <link>https://qetr1ck-op.github.io/blog/post/Node-js-design-pattern-book-review/</link>
      <pubDate>Thu, 06 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/Node-js-design-pattern-book-review/</guid>
      <description>&lt;p&gt;&amp;ldquo;How could I organize my code?&amp;rdquo;, &amp;ldquo;What is the best way to design this?&amp;rdquo;, &amp;ldquo;How can I make my application more modular?&amp;rdquo;, &amp;ldquo;How do I handle a set of asynchronous call effectively?&amp;rdquo;, &amp;ldquo;How can I make sure that my application will not collapse while it grows?&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;If you have such questions without answers, that book is definitely for you!&lt;/p&gt;

&lt;p&gt;The aim of this book is to guide you through this emerging world of patterns, techniques and practices, showing proven solution to the common problem.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/Node-js-Design-Patterns-Mario-Casciaro/dp/1783287314&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;chapter-1-welcome-to-the-node-js-platform&#34;&gt;Chapter 1: Welcome to the Node.js platform&lt;/h1&gt;

&lt;h2 id=&#34;the-node-js-philosophy&#34;&gt;The Node.js philosophy&lt;/h2&gt;

&lt;p&gt;Some of these principles arise from the technology itself, some of them are enabled by its ecosystem, some are just trends in community, some directly comes from its creator, another are influenced by the Unix culture.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Small core&lt;/li&gt;
&lt;li&gt;Small modules&lt;/li&gt;
&lt;li&gt;Small surface area&lt;/li&gt;
&lt;li&gt;Simplicity and pragmatism&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;i-o-is-slow&#34;&gt;I/O is slow&lt;/h2&gt;

&lt;p&gt;I/O is definitely the slowest among the fundamental operations of a computer. Accessing to RAM is in the order of nanoseconds, while accessing data on disk the network is in order of milliseconds. For the bandwidth is the same story. RAM has a transfer rate consistently in the order of GB/s, while disk and network varies from MB/s to, optimistically, GB/s.&lt;/p&gt;

&lt;p&gt;On the top of that, we also have to consider the human factor. Often input of an application comes from a real person, so the speed or frequency of I/O doesn&amp;rsquo;t only depend on technical aspects.&lt;/p&gt;

&lt;h3 id=&#34;blocking-i-o&#34;&gt;Blocking I/O&lt;/h3&gt;

&lt;p&gt;In traditional blocking I/O programming the function call corresponding to an I/O request will block the execution of the thread until the operation completes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// block the thread until the data is available
data = socket.read()
// data is available
print(data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s trivial to notice how web-server which is busing blocking I/O will not be able to handle multiple connection in the same thread. Each operation will block the processing of any other connection:&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/blocking-input-output.png %}&lt;/p&gt;

&lt;p&gt;The preceding image emphasis on the amount of time each thread is idle, waiting for new data to be received from associated connection. Also we need to consider how much time of I/O can possibly block a request, for example, while interacting with database or with filesystem.&lt;/p&gt;

&lt;h3 id=&#34;non-blocking-i-o-with-busy-waiting&#34;&gt;Non-blocking I/O with &amp;ldquo;busy-waiting&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;In this operation mode, the system call always returns immediately without waiting for data to be read or written. If no result are available at the moment of call, the function will simply return a predefined constant, indicating that there is no data available to return at the moment.&lt;/p&gt;

&lt;p&gt;The most basic pattern for accessing this kind of non-blocking I/O is &lt;code&gt;busy-waiting&lt;/code&gt; - it actively poll the resource within a loop until some actual data is returned.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;resource = [socketA, socketB, pipeA]

while(!resources.isEmpty()) {
  foreach resource in resources {
    // try to read
    let data = resource.read()

    if (data === NO_DATA_AVAILABLE) {
      // there is no data to read at the moment
      continue
    }
    if (data === RESOUCE_CLOSED) {
      // there was closed, remove it from list
      resources.remove(resource)
    } else {
      // data was received, proceed it
      consumeData(data)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this technique it&amp;rsquo;s already possible to achieve handling different resources in the same thread, but still it isn&amp;rsquo;t efficient.&lt;/p&gt;

&lt;h3 id=&#34;event-demultiplexing&#34;&gt;Event demultiplexing&lt;/h3&gt;

&lt;p&gt;Luckily, most modern operation systems provide a mechanism to handle concurrent, non-blocking resources in efficient way. It&amp;rsquo;s a &lt;code&gt;synchronous event demultiplexing&lt;/code&gt; or &lt;code&gt;event notification interface&lt;/code&gt; - it&amp;rsquo;s collect and queues I/O events that come from set of watched resources, and block until new events are available for process.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;watchedList.add(socketA, FOR_READ)
watchedList.add(socketB, FOR_READ)
watchedList.add(pipeA, FOR_READ) // [1]

while(events = demultiplexer.watch(watchedList)) { // [2]
  // event loop
  foreach (event in events) { // [3]
    // this read operation won&#39;t never block
    // and we will always return data
    data = event.resource.read()
    if (data === RESOUCE_CLOSED) {
      // remove from watched list
      demultiplexer.unwatch(event.resource)
    } else {
      // data was received, proceed it
      consumeData(data)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;The resources was added to a data structure, associated with specific operation&lt;/li&gt;
&lt;li&gt;The event notifier is set up with the group of resources to be watched. This call is synchronous and blocks until any of watched resource is ready for &lt;code&gt;read&lt;/code&gt; operation. When the resource is ready for an operation the &lt;code&gt;event demultiplexer&lt;/code&gt; returns from the call new set of events.&lt;/li&gt;
&lt;li&gt;Each event is proceed. At this point, the resource associated with each event is guaranteed to be ready to processing and not to block during the operation. When all events are processed, the flow will be blocked again on the &lt;code&gt;event demultiplexer&lt;/code&gt; until new events are again available to be proceed.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;This is called the &lt;code&gt;event loop&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It&amp;rsquo;s interesting that with this pattern, we can now handle several I/O operation inside a single thread. How web-server will handle multiple requests using synchronous &lt;code&gt;event demultiplexer&lt;/code&gt; with single thread:&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/webserver-event-demultiplexer.png %}&lt;/p&gt;

&lt;h2 id=&#34;the-reactor-pattern&#34;&gt;The reactor pattern&lt;/h2&gt;

&lt;p&gt;The main idea behind it is to have a handler (which in Node.js is represented by &lt;code&gt;callback&lt;/code&gt; function) associated with each I/O operation, which will be invoked as soon as an event is produces and processed by &lt;code&gt;event loop&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/reactor-pattern.png %}&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s happen when application use the &lt;code&gt;reactor patter&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The application generates a new I/O operation by submitting a request to &lt;code&gt;event demultiplexer&lt;/code&gt;. Also application specified a handler, which will be invoked when the operation is completes. Submitting a new request is non-blocking call and it immediately returns control to the application&lt;/li&gt;
&lt;li&gt;When set of I/O operation completes, the &lt;code&gt;event demultiplexer&lt;/code&gt; pushes the new events into the &lt;code&gt;event loop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;At this point, &lt;code&gt;event loop&lt;/code&gt; iterates over the items of the &lt;code&gt;event queue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;For each event, the associated handler is invoked&lt;/li&gt;
&lt;li&gt;

&lt;ul&gt;
&lt;li&gt;(a) The handler which is a part of application code, will give control to &lt;code&gt;event loop&lt;/code&gt; when it&amp;rsquo;s execution completes.&lt;/li&gt;
&lt;li&gt;(b) However, new asynchronous operation might be requested during the execution of handler, causing new operation to registered in the &lt;code&gt;event demultiplexer&lt;/code&gt;, before control is given back to &lt;code&gt;event loop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;When all items are processed in &lt;code&gt;event queue&lt;/code&gt;, the loop will blocked again on &lt;code&gt;event demultiplexer&lt;/code&gt; which will trigger another cycle of when a new events are available&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A Node.js application will exit automatically when there are no more pending operation in &lt;code&gt;event demultiplexer&lt;/code&gt; and no more events to be processed in &lt;code&gt;event queue&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Pattern Reactor&lt;/code&gt; handles I/O by blocking until new events are available from a set of observable resources and then reacts by dispatching each event with associated handler.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-non-blocking-i-o-engine-of-node-js-libuv&#34;&gt;The non-blocking I/O engine of Node.js-libuv&lt;/h2&gt;

&lt;p&gt;Each operation system has its own interface for the &lt;code&gt;event demultiplexer&lt;/code&gt;. Besides that, each I/O operation can behave quite differently depending on type of resource, even within the same OS. All this inconsistencies required a higher abstraction for &lt;code&gt;event demultiplexer&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is exactly why Node.js core created a C library called &lt;code&gt;libuv&lt;/code&gt; with objective to make Node.js compatible with all the major platform and normalize the non-blocking behavior of the different types of resource.&lt;/p&gt;

&lt;h2 id=&#34;the-building-blocks-of-node-js-platform&#34;&gt;The building blocks of Node.js platform&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;reactor pattern&lt;/code&gt; and &lt;code&gt;libuv&lt;/code&gt; are the basic building blocks but we need the following three other components to build the full platform:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a set of bindings responsible for wrapping and expose &lt;code&gt;libuv&lt;/code&gt; and other low-level functionality to Javascript&lt;/li&gt;
&lt;li&gt;&lt;code&gt;V8&lt;/code&gt; the Javascript engine, this one of the reason why Node.js is so fast and efficient&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;node-core&lt;/code&gt; that implements the high-level Node.js API&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;{% image fancybox center images/building-nodejs-blocks.png %}&lt;/p&gt;

&lt;h1 id=&#34;chapter-2-node-js-essential-patterns&#34;&gt;Chapter 2: Node.js essential patterns&lt;/h1&gt;

&lt;p&gt;In this chapter, we&amp;rsquo;ll use two of the most important asynchronous patterns: &lt;code&gt;callback&lt;/code&gt; and &lt;code&gt;event-emitter&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-callback-pattern&#34;&gt;The callback pattern&lt;/h2&gt;

&lt;p&gt;Callbacks are materialization of the handlers of the &lt;code&gt;reactor pattern&lt;/code&gt;. Callback is a function that is invoked to propagate the result of an operation and this is exactly what we need when we dealing with asynchronous operation. Another ideal construct for implementing callbacks is &lt;code&gt;closure&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-continue-passing-style&#34;&gt;The continue-passing style&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;In Javascript, a callback is a function that is passed as an argument to another function and is invoked with the result when operation is complete.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Meanwhile,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;in function programming, this way of propagating the result is called &lt;code&gt;continuation-passing style&lt;/code&gt; (CPS)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To clarify the concept lets see a &lt;code&gt;direct style&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function add(a, b) {
  return a + b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The equivalent &lt;code&gt;continue-passing style&lt;/code&gt; would be as follow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function add(a, b, callback) {
  callback(a + b);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;code&gt;add()&lt;/code&gt; is a synchronous &lt;code&gt;CPS&lt;/code&gt; function the result will be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(&#39;before&#39;);
add(1, 2, result =&amp;gt; console.log(`Result ${result}`));
console.log(&#39;after&#39;);

// before
// Result 3
// after
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;asynchronous-continue-passing-style&#34;&gt;Asynchronous continue-passing style&lt;/h3&gt;

&lt;p&gt;Lets consider a case where the &lt;code&gt;add()&lt;/code&gt; function is asynchronous:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function addAsync(a, b, callback) {
  setTimeout(callback(a + b));
}

console.log(&#39;before&#39;);
addAsync(1, 2, result =&amp;gt; console.log(`Result ${result}`));
console.log(&#39;after&#39;);

// before
// after
// Result 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;code&gt;setTimeout()&lt;/code&gt; triggers an asynchronous operation, it won&amp;rsquo;t wait for the callback to be executed, but instead, it returns immediately, giving control back to &lt;code&gt;addAsync()&lt;/code&gt; and then back to its caller. This is crucial and following image shows how it works:&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/async-cps-in-action.png %}&lt;/p&gt;

&lt;p&gt;The execution will start from the &lt;code&gt;event loop&lt;/code&gt; so it will have a fresh stack. Thanks to &lt;code&gt;closure&lt;/code&gt; it&amp;rsquo;s trivial to maintain the context of the caller in asynchronous function.&lt;/p&gt;

&lt;h3 id=&#34;synchronous-or-asynchronous&#34;&gt;Synchronous or asynchronous?&lt;/h3&gt;

&lt;p&gt;The following is an analysis of these two paradigms and their pitfalls.&lt;/p&gt;

&lt;h4 id=&#34;an-unpredictable-function&#34;&gt;An unpredictable function&lt;/h4&gt;

&lt;p&gt;One of the most dangerous situation is to have API that behaves synchronously under certain conditions and asynchronous under others:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fs = require(&#39;fs&#39;);
const cache = {};

function inconsistentRead(filename, callback) {
  if (cache[filename]) {
    // invoked synchronously
    callback(cache[filename]);
  } else {
    // async call
    fs.readFile(filename, &#39;utf8&#39;, (err, data) =&amp;gt; {
      cache[filename] = data;
      callback(data);
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;unleashing-zalgo&#34;&gt;Unleashing Zalgo&lt;/h4&gt;

&lt;p&gt;Now lets see how to use an unpredictable function, such as to easily break an application:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function createFileReader(filename) {
  const listeners = [];

  incosistentRead(filename, value =&amp;gt; {
    listeners.forEach(listener =&amp;gt; listener(value));
  })

  return {
    onDateReady: listener =&amp;gt; listeners.push(listener)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the preceding function is invoked, it creates a new object that acts as notifier, allowing us to set multiple listeners for a file read operation. All listeners will be invoked at once when the read operation completes and the data is available:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const reader1 = createFileReader(&#39;data.txt&#39;);

reader1.onDateReady(data =&amp;gt; {
  console.log(`First data call ready: ${data}`);

  // same time letter we try to read the same file again
  const reader2 = createFileReader(&#39;data.txt&#39;);

  reader2.onDateReady(data =&amp;gt; {
    console.log(`Second data call ready: ${data}`);
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result output is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;First data call ready: foo bar here!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see the callback of the second operation is never invoked. Lets see why:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;During the creation of &lt;code&gt;reader1&lt;/code&gt;, our &lt;code&gt;inconsistentRead()&lt;/code&gt; function behaves asynchronously, because there isn&amp;rsquo;t cached result. Therefore, we have all time in the world to register our listener, as it will invoked later in another cycle of &lt;code&gt;event loop&lt;/code&gt;, when the read operation is complete.&lt;/li&gt;
&lt;li&gt;Then the &lt;code&gt;reader2&lt;/code&gt; is created when requested file is in the cache. In this case the inner call of &lt;code&gt;inconsistentRead()&lt;/code&gt; will be synchronous. So its call back will be invoked immediately, which mean that listener of &lt;code&gt;reader2&lt;/code&gt; will be invoked synchronously as well. However, we registering the listeners after creation of &lt;code&gt;reader2&lt;/code&gt;, so they will never be invoked!&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;using-synchronous-apis&#34;&gt;Using synchronous APIs&lt;/h3&gt;

&lt;p&gt;One suitable fix for our &lt;code&gt;inconsistentRead()&lt;/code&gt; function is to make it totally synchronous:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fs = require(&#39;fs&#39;);
const cache = {};

function consistentRead(filename) {
  if (cache[filename]) {
    return cache[filename];
  }
  cache[filename] = fs.readFileSync(filename, &#39;utf8&#39;);
  return cache[filename];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is no reason for a function to have a continue-passing style it&amp;rsquo;s synchronous. In fact, it&amp;rsquo;s always a best practice to implement synchronous API using a &lt;code&gt;direct style&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pattern:
Prefer &lt;code&gt;direct style&lt;/code&gt; for purely synchronous function&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Bear in mind, that changing an API from &lt;code&gt;CPS&lt;/code&gt; to a &lt;code&gt;direct style&lt;/code&gt; (from asynchronous to synchronous or vice versa) require a change of style of all code using:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function createFileReader(filename) {
  const listeners = [];
  const fileData = consistentRead(filename)

  return {
    onDateReady: listener =&amp;gt; {
      listeners.push(listener);
      listeners.forEach(listener =&amp;gt; listener(fileData));
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;using-asynchronous-operation-with-deferred-execution&#34;&gt;Using asynchronous operation with deferred execution&lt;/h3&gt;

&lt;p&gt;The trick here is to schedule the synchronous callback invocation to be executed &amp;ldquo;in the future&amp;rdquo;, instead of being run immediately in the same event loop cycle. In Node.js this is possible using &lt;code&gt;process.nextTick()&lt;/code&gt;, which defers the execution of a function until next the event loop cycle. This function is a very simple, it takes a callback and pushes it to the top of event queue, in front of any pending I/O event, and returns control immediately. So callback will run be invoked as soon as the event loop runs again.&lt;/p&gt;

&lt;p&gt;Apply this technique to fix &lt;code&gt;inconsistentRead()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fs = require(&#39;fs&#39;);
const cache = {};

function inconsistentRead(filename, callback) {
  if (cache[filename]) {
    // now invoked asynchronously
    process.nextTick(() =&amp;gt; callback(cache[filename]));
  } else {
    // async call
    fs.readFile(filename, &#39;utf8&#39;, (err, data) =&amp;gt; {
      cache[filename] = data;
      callback(data);
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, our function is guaranteed to invoke its callback asynchronous, under any circumstances.&lt;/p&gt;

&lt;p&gt;Another API for deferring the execution is &lt;code&gt;setImmediate()&lt;/code&gt;. While their purposes are very similar, their semantics are quite different. Callback deferred with &lt;code&gt;process.nextTick()&lt;/code&gt; run before any other I/O event fired, while with &lt;code&gt;setImmediate()&lt;/code&gt;, the execution is queued behind any I/O event that is already in the queue. Since &lt;code&gt;process.nextTick()&lt;/code&gt; runs before any already scheduled I/O, it might cause I/O starvation under certain circumstances, for example, a recursive invocation, this can never happen with &lt;code&gt;setImmediate()&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pattern:
We guarantee that a callback is invoked asynchronously be deferring it execution using &lt;code&gt;process.nextTick()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;node-js-callback-convention&#34;&gt;Node.js callback convention&lt;/h3&gt;

&lt;p&gt;CPS APIs and callbacks follows a set of specific convention.&lt;/p&gt;

&lt;h4 id=&#34;callback-come-last&#34;&gt;Callback come last&lt;/h4&gt;

&lt;p&gt;In all core Node.js methods, the standard convention is that when a function accept callback as input, this has to be passed as last parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;fs.readFile(filename[, options], callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;error-comes-first&#34;&gt;Error comes first&lt;/h4&gt;

&lt;p&gt;In Node.js, any errors produced by a CPS function is always passed as first argument of the callback, and any actual result is passed starting from the second argument. It the operation is succeeds without errors, the first error will be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;fs.readFile(&#39;foo.txt&#39;, &#39;utf8&#39;, (err, data) =&amp;gt; {
  if (err) {
    handleError(err);
  } else {
    handleData(data);
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;propagation-errors&#34;&gt;Propagation errors&lt;/h4&gt;

&lt;p&gt;Propagation errors in synchronous, direct function is done with well-known &lt;code&gt;throw&lt;/code&gt; statement.&lt;/p&gt;

&lt;p&gt;In CPS style however, proper propagation is done by passing the error to the next callback in the chain:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function readJson(filename, callback) {
  fs.readFile(filename, &#39;utf8&#39;, (err, data) =&amp;gt; {
    let parsed;
    if (err) {
      // propagate the error and exit
      return callback(err);
    }

    try {
      parsed = JSON.parse(data);
    } catch(err) {
      // catch parsing error
      return callback(err);
    }

    // no error propagate just data
    callback(null, parsed);
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-module-system-and-its-pattern&#34;&gt;The module system and its pattern&lt;/h2&gt;

&lt;p&gt;Modules are bricks for structuring non-trivial application, but also the main mechanism to enforce hiding information by keeping private all the function and variable that are not explicitly marked to be exported.&lt;/p&gt;

&lt;h3 id=&#34;the-revealing-module-pattern&#34;&gt;The revealing module pattern&lt;/h3&gt;

&lt;p&gt;Once of the major problem in Javascript is an absence of namespacing. A popular technique to solve this issue is called &lt;code&gt;the revealing module pattern&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const module = (() =&amp;gt; {
  const privateFoo = () =&amp;gt; {};
  const privateBar = [];

  const exported = {
    publicFoo: &#39;dataFoo&#39;,
    publicBar: &#39;dataBar&#39;,
  }

  return export
}())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have a private scope and exporting only the parts that are meant to be public. As we&amp;rsquo;ll see at the moment, the idea behind this pattern is used as a base for a Node.js module system.&lt;/p&gt;

&lt;h3 id=&#34;node-js-modules-explained&#34;&gt;Node.js modules explained&lt;/h3&gt;

&lt;p&gt;CommonJS is a group with the aim to standardize the Javascript ecosystem, and one of their most popular proposal is &lt;code&gt;CommonJS module system&lt;/code&gt;. Node.js built its module system on the top of this specification, with the addition of some custom extensions.&lt;/p&gt;

&lt;h4 id=&#34;a-homemade-module-loader&#34;&gt;A homemade module loader&lt;/h4&gt;

&lt;p&gt;To explain how Node.js modules work let&amp;rsquo;s built a similar system from scratch. The code mimics a subset of functionality of original &lt;code&gt;require&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function loadModule(filename, module, require) {
  const wrappedSrc = `function(module, module, require) {
    ${fs.readFileSync(filename, &#39;utf8&#39;)}
  }(module, module.exports, require)`;

  eval(wrappedSrc);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bear in mind, that this code is only for example, feature such as &lt;code&gt;eval()&lt;/code&gt; or &lt;code&gt;vm&lt;/code&gt; &lt;a href=&#34;https://nodejs.org/api/vm.html&#34;&gt;module&lt;/a&gt; can be easily used in a wrong way or with a wrong input to inject attack. They should be used always with extreme care.&lt;/p&gt;

&lt;p&gt;Now implementation of our &lt;code&gt;require()&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function require(moduleName) {
  console.log(`Require invoked for module: ${moduleName}`);
  const id = require.resolve(moduleName); // [1]

  if (require.cache[id]) { // [2]
    return require.cache[id].exports;
  }

  // module metadata
  const module = { // [3]
    exports: {},
    id
  };
  // update the cache
  require.cache[id] = module; // [4]

  // load the module
  loadModule(id, module, require); // [5]

  // return exported variables
  return module.exports; // [6]
}

require.cache = {};
require.resolve = function(moduleName) {
  // resolve a full module id from the moduleName
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What our homemade module system does is explain as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Module name is accepted as input, and the very first thing that we do is resolve the full path of module, and receive module &lt;code&gt;id&lt;/code&gt;. It&amp;rsquo;s implementing by special resolving algorithm of &lt;code&gt;require.resolve()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If the module has already been loaded it should be available in the cache.&lt;/li&gt;
&lt;li&gt;If the module hasn&amp;rsquo;t loaded yet, we set up environment for the first load. The property &lt;code&gt;module.exports&lt;/code&gt; will be used to export public API.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;module&lt;/code&gt; object is cached.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;loadModule()&lt;/code&gt; code reads from its file, and the code is evaluated. We provide the module with &lt;code&gt;module&lt;/code&gt; object that we just created, and a reference to &lt;code&gt;require()&lt;/code&gt; function. The module exports its public API by manipulation or replacing the &lt;code&gt;module.exports&lt;/code&gt; object.&lt;/li&gt;
&lt;li&gt;Finally the content of &lt;code&gt;module.exports&lt;/code&gt; is returned from caller.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;defining-a-modules&#34;&gt;Defining a modules&lt;/h4&gt;

&lt;p&gt;By looking how us &lt;code&gt;require()&lt;/code&gt; works be are able to define a module:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// module.js
// load another module-dependency
const dependency = require(&#39;./anotherModule&#39;);

// private section
function privateFoo() {}

// the exported API
module.exports.run = function publicBar() {
  privateFoo()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The essential concept to remember that everything in the module is private unless it&amp;rsquo;s assigned to &lt;code&gt;module.exports&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;defining-globals&#34;&gt;Defining globals&lt;/h4&gt;

&lt;p&gt;It&amp;rsquo;s still possible to define a global variable, in fact, module system exposes a special variable &lt;code&gt;global&lt;/code&gt;, which can be used for this purpose&lt;/p&gt;

&lt;h4 id=&#34;module-exports-vs-exports&#34;&gt;&amp;ldquo;module.exports&amp;rdquo; VS &amp;ldquo;exports&amp;rdquo;&lt;/h4&gt;

&lt;p&gt;A common source of confusion is the difference between using &lt;code&gt;module.exports&lt;/code&gt; and &lt;code&gt;exports&lt;/code&gt; to expose the public API. The code of our custom &lt;code&gt;require&lt;/code&gt; function should again clear any doubts.&lt;/p&gt;

&lt;p&gt;The variable &lt;code&gt;exports&lt;/code&gt; is just a reference to initial value of &lt;code&gt;module.exports&lt;/code&gt;, essentially it&amp;rsquo;s an empty object before the module is loaded. This means that we can only attach new properties referencing by &lt;code&gt;exports&lt;/code&gt; variable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;exports.hello = () =&amp;gt; { console.log(&#39;Hello&#39;) };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reassigning the &lt;code&gt;exports&lt;/code&gt; variable doesn&amp;rsquo;t have any sense, because it doesn&amp;rsquo;t change content of &lt;code&gt;module.exports&lt;/code&gt;. That&amp;rsquo;s how object in Javascript works. The following code therefore is wrong:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;exports.hello = () =&amp;gt; { console.log(&#39;Hello&#39;) };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to export something other than an object literal, we can reassigning &lt;code&gt;module.exports&lt;/code&gt; as follow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module.exports = () =&amp;gt; { console.log(&#39;Hello&#39;) };
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-require-function-is-synchronous&#34;&gt;The &amp;ldquo;require&amp;rdquo; function is synchronous&lt;/h4&gt;

&lt;p&gt;We should take into account that our homemade &lt;code&gt;require&lt;/code&gt; is synchronous. In fact, it returns the module contents using simple direct style therefore no callback is required. This is true for original Node.js &lt;code&gt;require&lt;/code&gt; function too. As a consequence any assignments to &lt;code&gt;module.exports&lt;/code&gt; must be synchronous. The following code is incorrect:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;setTimeout(() =&amp;gt; {
  module.exports = () =&amp;gt; {}
}, 100);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is one of the important reasons why Node.js libraries offer synchronous APIs as alternative to asynchronous ones.&lt;/p&gt;

&lt;h4 id=&#34;the-resolving-algorithm&#34;&gt;The resolving algorithm&lt;/h4&gt;

&lt;p&gt;Node.js solver the &lt;code&gt;dependency hell&lt;/code&gt; elegantly by loading different version of module depending on where the module is loaded from. As we saw the &lt;code&gt;resolve()&lt;/code&gt; function takes a module name (&lt;code&gt;moduleName&lt;/code&gt; in our loader) as input, and it returns the full path of module. This path is used to load its code and to identify the module uniquely.&lt;/p&gt;

&lt;p&gt;The resolving algorithm can be divided into the following three major branches:
* file modules
* core modules
* package modules&lt;/p&gt;

&lt;p&gt;The resolving algorithm can be be found at &lt;a href=&#34;https://nodejs.org/api/modules.html#modules_all_together&#34;&gt;official spec&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;node_modules&lt;/code&gt; directory is where &lt;code&gt;npm&lt;/code&gt; installs the dependencies of each package. Based on the algorithm, each package can have its own private dependencies. Consider the following structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myApp
├── foo.js
└── node_modules
    ├── depA
    │   └── index.js
    ├── depB
    │   ├── bar.js
    │   └── node_modules
    │       └── depA
    │           └── index.js
    └── depC
        ├── foobar.js
        └── node_modules
            └── depA
            └── index.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Following rules of resolving algorithm, using &lt;code&gt;require(&#39;depA&#39;)&lt;/code&gt; will load a different file depending on the module that requires it:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Calling &lt;code&gt;require(&#39;depA&#39;)&lt;/code&gt; from &lt;code&gt;/myApp/foo.js&lt;/code&gt; will load &lt;code&gt;/myApp/node_modules/depA/index.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Calling &lt;code&gt;require(&#39;depA&#39;)&lt;/code&gt; from &lt;code&gt;/myApp/node_modules/depB/bar.js&lt;/code&gt; will load &lt;code&gt;/myApp/node_modules/depB/node_modules/depA/index.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Calling &lt;code&gt;require(&#39;depA&#39;)&lt;/code&gt; from &lt;code&gt;/myApp/node_modules/depC/foobar.js&lt;/code&gt; will load &lt;code&gt;/myApp/node_modules/depc/node_modules/depA/index.js&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;the-module-cache&#34;&gt;The module cache&lt;/h4&gt;

&lt;p&gt;Each module is only loaded and evaluated the first time it&amp;rsquo;s required, since any subsequent call of &lt;code&gt;require()&lt;/code&gt; will return the cached version. Again, it should be clear by looking at the code of homemade &lt;code&gt;require()&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;The module cache is exposed via the &lt;code&gt;require.cache&lt;/code&gt; reference, so it&amp;rsquo;s possible to directly access it if needed.&lt;/p&gt;

&lt;h3 id=&#34;module-definition-patterns&#34;&gt;Module definition patterns&lt;/h3&gt;

&lt;p&gt;The module system besides being a mechanism for loading dependencies, is also a tool for defining APIs. To aim is to maximize information hading and API usability, with balancing with other software quality such as &lt;code&gt;code reuse&lt;/code&gt; and &lt;code&gt;extensibility&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;named-exports&#34;&gt;Named exports&lt;/h4&gt;

&lt;p&gt;The most basic method for exposing public API is using &lt;code&gt;named exports&lt;/code&gt;, which consist to assignment all the public values to object referenced by &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;module.exports&lt;/code&gt;. Most of the Node.js core modules use this pattern.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// file logger.js
exports.info = (msg) = {
  console.log(`info: ${msg}`)
};

exports.verbose = (msg) = {
  console.log(`verbose: ${msg}`)
};

// file main.js
const logger = require(&#39;./logger&#39;);

logger.info(&#39;Info massage&#39;);
logger.verbose(&#39;Verbose massage&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;exporting-a-function&#34;&gt;Exporting a function&lt;/h4&gt;

&lt;p&gt;One of the most popular module definition pattern consists of reassigning of the whole &lt;code&gt;module.exports&lt;/code&gt; variable to the function. The main goal to provide a clear entry point for the module, making it simpler to understand and use. It also honors the principle of &lt;code&gt;small area surface&lt;/code&gt;. This way of defining modules also is known as the &lt;code&gt;substack pattern&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// file logger.js
module.exports = (msg) = {
  console.log(`info: ${msg}`)
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A possible extension for this pattern is using the exported function as namespace for other public APIs. This is a very powerful technique, because it still gives clarity of a single entry point.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// the same file logger.js
module.exports.verbose = (msg) = {
  console.log(`verbose: ${msg}`)
};

// file main.js
const logger = require(&#39;./logger&#39;);

logger(&#39;Info massage&#39;);
logger.verbose(&#39;Verbose massage&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Pattern:
Substack or Single Responsibility Principle (SRP)
Expose the main functionality of a module by exporting only one function. Use the exported function as a namespace to expose any auxiliary functionality&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;exporting-a-constructor&#34;&gt;Exporting a constructor&lt;/h4&gt;

&lt;p&gt;The difference is with this approach we allow user to create a new instance using the constructor with ability to extend its prototype and forge new classes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// file logger.js
class Logger {
  constructor(name) {
    this.name = name;
  }

  log(msg) {
    console.log(`[${this.name}] ${msg}`)
  }

  info(msg) {
    console.log(`info: ${msg}`)
  }

  verbose(msg) {
    console.log(`info: ${msg}`)
  }
}

module.exports = Logger;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A variation of this pattern consists of applying a security check against invocation that doesn&amp;rsquo;t use &lt;code&gt;new&lt;/code&gt; directive. This a little trick allows us to use our module as &lt;code&gt;factory&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function LoggerFactory(name) {
  if (!this instanceof Logger) {
    return new Logger(name)
  }
  return new Logger(name);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A much cleaner approach is offered by ES6 &lt;code&gt;new.targer&lt;/code&gt; which is available starting from Node.js v6. The syntax expose the &lt;code&gt;new.targer&lt;/code&gt; which is called &lt;code&gt;meta property&lt;/code&gt;, made available inside all the function, end evaluates to true at runtime if the function was called using the &lt;code&gt;new&lt;/code&gt; directive.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function LoggerFactory(name) {
  if (!new.target) {
    return new Logger(name);
  }
  return new Logger(name);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;exporting-an-instance&#34;&gt;Exporting an instance&lt;/h4&gt;

&lt;p&gt;We can leverage the caching mechanism of &lt;code&gt;require()&lt;/code&gt; to define stateful instance with a state created from a constructor or factory, shared across different modules:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// file logger.js
class Logger {
  constructor(name) {
    this.name = name;
    this.count = 0;
  }

  log(msg) {
    this.count++;
    console.log(`[${this.name}] ${msg}`)
  }
}

module.exports = new Logger(&#39;default&#39;);

// file main.js
const logger = require(&#39;./logger.js&#39;);
logger.log(&#39;test the singleton&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is much like a &lt;code&gt;singleton pattern&lt;/code&gt;, however it doesn&amp;rsquo;t guarantee the uniqueness of the instance across the whole application, as it happens with traditional singleton pattern. When analyzing the resolving algorithm, we have seen in fact, that a module might be installed multiple times inside the dependency tree of an application.&lt;/p&gt;

&lt;h4 id=&#34;modifying-other-modules-or-the-global-scope&#34;&gt;Modifying other modules or the global scope&lt;/h4&gt;

&lt;p&gt;A module can even export nothing. We should not forger that module can modify the global scope and the object in it, including other modules in the cache. In general it&amp;rsquo;s considering as a bad practice.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pattern:
Monkey patching is when module can modify other modules or object in global scope. It change the existing objects at runtime to change or extend their behavior or apply temporary fixes&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;How we can add a new function to another module:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// file patcher.js
require(&#39;./logger&#39;).customMessage = () =&amp;gt; console.log(&#39;this is a new functionality&#39;);

// main.js
require(&#39;./patcher&#39;);

const logger = require(&#39;./logger&#39;);
logger.customMessage();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The technique is dangerous, because it affects the state of entire app.&lt;/p&gt;

&lt;h2 id=&#34;the-observer-pattern&#34;&gt;The observer pattern&lt;/h2&gt;

&lt;p&gt;Together with the &lt;code&gt;reactor&lt;/code&gt;, &lt;code&gt;callbacks&lt;/code&gt; and &lt;code&gt;modules&lt;/code&gt;, the &lt;code&gt;observer pattern&lt;/code&gt; is one of the pillars of the platform and is used by mane Node.js core and user-land modules.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pattern Observer:
Defines an object (subject), which can notify a set of observers (listeners) when change is occur.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The main difference from the callback pattern is that the &lt;code&gt;subject&lt;/code&gt; can notify multiple observers, while a traditional &lt;code&gt;CPS&lt;/code&gt; will propagate its result to only one listener, the callback.&lt;/p&gt;

&lt;h3 id=&#34;the-eventemitter-class&#34;&gt;The EventEmitter class&lt;/h3&gt;

&lt;p&gt;The observer pattern built into core and it&amp;rsquo;s available through the &lt;code&gt;EventEmitter&lt;/code&gt; class. It allows to register one or multiple function as &lt;code&gt;listeners&lt;/code&gt;, which will be notified when a particular event type is fired. The following explains the concept:&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/event-emitter.png %}&lt;/p&gt;

&lt;p&gt;How to require &lt;code&gt;EventEmitter&lt;/code&gt; from core &lt;code&gt;events&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const EventEmitter = require(&#39;events&#39;);
const eeInstance = new EventEmitter;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The API is in &lt;a href=&#34;https://nodejs.org/api/events.html#events_class_eventemitter&#34;&gt;official Node.js specification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We can already see that there is a big difference between a listener and a traditional Node.js callback, in particular, the first argument isn&amp;rsquo;t an error, but any data which is passed to &lt;code&gt;emit()&lt;/code&gt; at the moment of invocation.&lt;/p&gt;

&lt;h3 id=&#34;creating-and-using-eventemitter&#34;&gt;Creating and using EventEmitter&lt;/h3&gt;

&lt;p&gt;The following code shows a function that uses &lt;code&gt;EventEmitter&lt;/code&gt; to notify its subscribers in real time when a particular pattern is found in a list of files:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const EventEmitter = require(&#39;events&#39;);
const fs = require(&#39;fs&#39;);

function findPattern(files, regexp) {
  const emitter = new EventEmitter;

  files.forEach(file =&amp;gt; {
    fs.readFile(file, &#39;utf8&#39;, (err, content) =&amp;gt; {
      let match;

      if (err) {
        emitter.emit(&#39;error&#39;, err);
      }

      emitter.emit(&#39;fileread&#39;, file); 

      if (match = content.match(regexp)) {
        match.forEach(elem =&amp;gt; emitter.emit(&#39;found&#39;, file, elem))        
      }
    })
  })

  return emitter;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets see how &lt;code&gt;findPattern&lt;/code&gt; can be used:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;findPattern(
  [&#39;data1.txt&#39;, &#39;data2.txt&#39;],
  /foo \w+/g
)
  .on(&#39;fileread&#39;, file =&amp;gt; console.log(`${file} was read`))
  .on(&#39;found&#39;, (file, match) =&amp;gt; console.log(`matched ${match} in file ${file}`))
  .on(&#39;error&#39;, err =&amp;gt; console.log(`Error: ${err}`))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;extends-from-eventemitter-class&#34;&gt;Extends from EventEmitter class&lt;/h3&gt;

&lt;p&gt;To demonstrate the pattern lets implement the functionality of the &lt;code&gt;findPattern()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const EventEmitter = require(&#39;events&#39;);
const fs = require(&#39;fs&#39;);

class FindPattern extends EventEmitter {
  constructor(regexp) {
    super();
    this.regexp = regexp;
    this.files = [];
  }

  addFile(file) {
    this.files.push(file);

    return this;
  }

  find() {
    this.files.forEach(file =&amp;gt; {
      fs.readFile(file, &#39;utf8&#39;, (err, content) =&amp;gt; {
        let match;

        if (err) {
          this.emit(&#39;error&#39;, err);
        }

        this.emit(&#39;fileread&#39;, content); 

        if (match = content.match(this.regexp)) {
          match.forEach(elem =&amp;gt; this.emit(&#39;found&#39;, file, elem); )        
        }
      })
    })
    return this;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;FindPattern&lt;/code&gt; prototype extends &lt;code&gt;EventEmitter&lt;/code&gt;. In this way it becomes a fully-fledged observable class. The usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const findPatternObj = new FindPattern(/hello \w+/g);

findPatternObj
  .addFile(&#39;data1.txt&#39;)
  .addFile(&#39;data2.txt&#39;)
  .on(&#39;fileread&#39;, file =&amp;gt; console.log(`${file} was read`))
  .on(&#39;found&#39;, (file, match) =&amp;gt; console.log(`matched ${match} in file ${file}`))
  .on(&#39;error&#39;, err =&amp;gt; console.log(`Error: ${err}`))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a pretty common pattern in the Node.js ecosystem, for example, the &lt;code&gt;Server&lt;/code&gt; object of the core HTTP module defines methods such as &lt;code&gt;listen()&lt;/code&gt;, &lt;code&gt;close()&lt;/code&gt;, &lt;code&gt;setTimeout()&lt;/code&gt; and internally it inherits from the &lt;code&gt;EventEmitter&lt;/code&gt; function. It allows to produce events such as &lt;code&gt;request&lt;/code&gt; when a new connection is received, or &lt;code&gt;connection&lt;/code&gt; when a new connection is established, or &lt;code&gt;close&lt;/code&gt; when server is shut down.&lt;/p&gt;

&lt;h3 id=&#34;combining-callbacks-with-eventemitter&#34;&gt;Combining callbacks with EventEmitter&lt;/h3&gt;

&lt;p&gt;There are also circumstances where &lt;code&gt;EventEmitter&lt;/code&gt; can be combining with a &lt;code&gt;callback&lt;/code&gt;. One example of this pattern is offered by the &lt;code&gt;node-glob&lt;/code&gt; module, which performs a glob-style searching. The function &lt;code&gt;glob(pattern, [options], callback)&lt;/code&gt; takes a &lt;code&gt;callback&lt;/code&gt; that is invoked with the list of all files which are matched by the providing pattern. At the same time it returns &lt;code&gt;EventEmitter&lt;/code&gt; that provides an interface to report over the state of the process:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const glob = require(&#39;glob&#39;);

glob(&#39;*.txt&#39;, (err, files) =&amp;gt; console.log(`Founded files: ${JSON.stringify(files)}`))
  .on(&#39;match&#39;, match =&amp;gt; console.log(`Matched files: ${match}`))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;chapter-3-asynchronous-control-flow-patterns-with-callbacks&#34;&gt;Chapter 3: Asynchronous control flow patterns with callbacks&lt;/h1&gt;

&lt;p&gt;One of the common mistake is to fail into the trap of the callback hell and see how the code is growing horizontally rather than vertically, with the nesting which makes even simple routine hard to read and maintain.&lt;/p&gt;

&lt;p&gt;In this chapter we we&amp;rsquo;ll see how it&amp;rsquo;s actually possible to tame callbacks and write clean, manageable asynchronous code with the aid of some patterns.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-simple-web-spider&#34;&gt;Creating a simple web spider&lt;/h2&gt;

&lt;p&gt;To explain the problem we&amp;rsquo;ll create a little CLI application that takes a web URL as input and downloads its contents locally into file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// file spider.js
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const request = require(&#39;request&#39;); // HTTP request client
const mkdirp = require(&#39;mkdirp&#39;); // Recursively mkdir, like mkdir -p
const chalk = require(&#39;chalk&#39;); // Terminal string styling done right.

const utils = require(&#39;./utils&#39;);

function spider(url, cb) {
  const filePath = utils.urlToFilePath(url);
  const fileName = utils.urlToFileName(url);
  let isFileExists = false;

  fs.stat(filePath, (err, stats) =&amp;gt; { // [1]
    if (stats) {
      cb(null, fileName, isFileExists = true);
    } else {
      request(url, (err, response, body) =&amp;gt; { // [2]
        if (err) {
          cb(err);
        } else {
          mkdirp(filePath, err =&amp;gt; { // [3]
            if (err) {
              cb(err);
            } else {
              fs.writeFile(path.join(filePath, fileName), body, err =&amp;gt; { // [3]
                if (err) {
                  cb(err);
                } else {
                  cb(null, fileName, isFileExists);
                }
              })
            }
          })
        }
      })
    }
  })
}

spider(process.argv[2], (err, fileName, fileExists) =&amp;gt; {
  if (err) {
    console.log(chalk.red(`Error: ${err}`));
  } else if (fileExists) {
    console.log(chalk.blue(`File: ${fileName} exists`));
  } else {
    console.log(chalk.green(`File: ${fileName} is downloaded`));

  }
})

// file utils.js
/*
* Converts urls to simplified strings
*/
const slugifyUrl = require(&#39;slugify-url&#39;);

exports.urlToFilePath = urlToFilePath;
exports.urlToFileName = urlToFileName;

function urlToFilePath(url) { // http://example.com/bar
  const slashChar = &#39;/&#39;;

  return slugifyUrl(url, { slashChar }); // example.com/bar
}

function urlToFileName(url) { // http://example.com/bar
  const slashChar = &#39;/&#39;;
  const parsedUrl = slugifyUrl(url, { slashChar }).split(&#39;/&#39;);

  return parsedUrl[parsedUrl.length - 1]; // bar
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The preceding functions execute the following tasks:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Check if the URL was already downloaded by verifying that corresponding file hasn&amp;rsquo;t already created.&lt;/li&gt;
&lt;li&gt;If the file is not found, it would download content of provided URL&lt;/li&gt;
&lt;li&gt;Then it creates recursively directories&lt;/li&gt;
&lt;li&gt;Finally, it writes the body of HTTP response to file system&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;the-callback-hell&#34;&gt;The callback hell&lt;/h2&gt;

&lt;p&gt;We can surely notice that even though the algorithm was straightforward, the resulting code has several level of indentation and it&amp;rsquo;s very hard to read. Implementing a similar function in &lt;code&gt;direct style&lt;/code&gt; would more straightforward, and it would be very few chances to make it look so wrong. However, using &lt;code&gt;CPS&lt;/code&gt; is another story, and making bad use of closure may lead to to incredible bad code.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s known as &lt;code&gt;callback hell&lt;/code&gt; or &lt;code&gt;piramid of domm&lt;/code&gt;. The typical structure of code affected by the problem looks like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;asyncFoo(err =&amp;gt; {
  asyncBar(err2 =&amp;gt; {
    asyncFooBar(err3 =&amp;gt; {
      // ...
    })
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another problem is caused by overlapping of the variable names used in each scope. Some people try to avoid it with variation of variables &lt;code&gt;error, err, err2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Also we should keep in mind that closure can create memory leaks that are not so easy to identify. We shouldn&amp;rsquo;t forget that any context referenced by an active closure is retained from garbage collector.&lt;/p&gt;

&lt;h2 id=&#34;applying-the-callback-discipline&#34;&gt;Applying the callback discipline&lt;/h2&gt;

&lt;p&gt;Basic principles that can help to keep the nesting level low and improve the organization of our code in general:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;you must exit as soon as possible. Use &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt; or &lt;code&gt;break&lt;/code&gt;, depending on context to immediately exit the current statement&lt;/li&gt;
&lt;li&gt;create a named function for callbacks. Will keep our code shallow and better look for stack trace&lt;/li&gt;
&lt;li&gt;modularize the code. Create a small, reusable function whenever it&amp;rsquo;s possible&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After applying the following recommendation our &lt;code&gt;spider()&lt;/code&gt; would look as following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function spider(url, cb) {
  const filePath = utils.urlToFilePath(url);
  const fileName = utils.urlToFileName(url);
  let isFileExists = false;

  fs.stat(filePath, (err, stats) =&amp;gt; {
    if (stats) {
      return cb(null, fileName, isFileExists = true); // [!]
    }
    download(url, filePath, fileName, isFileExists, cb);
  })
}

function download(url, filePath, fileName, isFileExists, cb) {
  request(url, (err, response, body) =&amp;gt; {
    if (err) {
      return cb(err); // [!]
    } else {
      saveFile(filePath, fileName, body, isFileExists, cb); // [!]
    }
  })
}

function saveFile(filePath, fileName, content, isFileExists, cb) {
  mkdirp(filePath, err =&amp;gt; {
    if (err) {
      return cb(err); // [!]
    } else {
      writeContent(filePath, fileName, content, isFileExists, cb);
    }
  })
}

function writeContent(filePath, fileName, content, isFileExists, cb) {
  fs.writeFile(path.join(filePath, fileName), content, err =&amp;gt; {
    if (err) {
      return cb(err); // [!]
    } else {
      return cb(null, fileName, isFileExists); // [!]
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sequential-execution&#34;&gt;Sequential execution&lt;/h2&gt;

&lt;p&gt;Executing a set of task in sequence means running them one at time, one ofter other. The order of execution matters. The concept:&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/sequential-execution.png %}&lt;/p&gt;

&lt;p&gt;There are different variation of this flow:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;execution a set of known task in sequence&lt;/code&gt;, without chaining and propagate the result&lt;/li&gt;
&lt;li&gt;using output of task as the input to the next task, also known as &lt;code&gt;chain&lt;/code&gt;, &lt;code&gt;pipe&lt;/code&gt;, or &lt;code&gt;waterfall&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;iterating over a collection while running an asynchronous task on each element, one ofter other&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;execution-a-set-of-known-task-in-sequence&#34;&gt;Execution a set of known task in sequence&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve already met a sequential execution while implementing the &lt;code&gt;spider()&lt;/code&gt; function. Taking that code as guideline we can generalize the solution into the following pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function task1(cb) {
  asyncOperation(() =&amp;gt; task2(cb))
}

function task2(cb) {
  asyncOperation(() =&amp;gt; task3(cb))
}

function task3(cb) {
  asyncOperation(() =&amp;gt; cb()) // finally executes the callback
}

function asyncOperation(cb) { // emulates asynchronous operation
  setTimeout(() =&amp;gt; cb());
}

task1(() =&amp;gt; console.log(&#39;task 1, 2 and 3 executed&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sequential-iteration-with-crawling-of-links&#34;&gt;Sequential iteration with crawling of links&lt;/h3&gt;

&lt;p&gt;What if we want to invoke an asynchronous operation for each file in a collection?&lt;/p&gt;

&lt;p&gt;With new feature, downloading all the links contained in the web-page recursively. To do that, we are going to extract all links from the page and than trigger our web spider on each of them recursively and in sequence.&lt;/p&gt;

&lt;p&gt;The new version of &lt;code&gt;spider()&lt;/code&gt; is as following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function spider(url, nesting, callback) {
  const filename = utilities.urlToFilename(url);
  fs.readFile(filename, &#39;utf8&#39;, (err, body) =&amp;gt; {
    if(err) {
      if(err.code ! == &#39;ENOENT&#39;) {
        return callback(err);
      } 
      return download(url, filename, (err, body) =&amp;gt; {
        if(err) {
          return callback(err);
        }
        spiderLinks(url, body, nesting, callback);
      });
    }

    spiderLinks(url, body, nesting, callback);
  });
}

function spiderLink(url, body, nesting, cb) {
  if (nesting === 0) {
    return process.nextTick(cb);
  }
  // require(&#39;get-urls&#39;)
  const links = utils.getUrls(body); // [1]

  function iterate(index) { // [2]
    if (index === links.length) {
      return cb();
    }

    spider(links[index], nesting - 1, err =&amp;gt; { // [3]
      if (err) {
        return cb(err);
      }
      iterate(index - 1);
    })
  }
  iterate(0); // [4]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important steps to understand:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Obtain the list of all links on the page using the &lt;code&gt;utils.getUrls()&lt;/code&gt;. This links should return only with the same hostname&lt;/li&gt;
&lt;li&gt;Iterate through links via local function &lt;code&gt;iterate()&lt;/code&gt;. The first thing it checks if the &lt;code&gt;index&lt;/code&gt; is equal to the length of &lt;code&gt;links&lt;/code&gt;, in which case it immediately invokes the &lt;code&gt;cb()&lt;/code&gt; as it means it proceeds all items&lt;/li&gt;
&lt;li&gt;At this point everything is ready to processing the links. It invokes the &lt;code&gt;spider()&lt;/code&gt; function by decreasing the nesting level and invoking the next step of iteration then the operation is complete&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s a bootstrapping the iteration by &lt;code&gt;iterate(0)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;the-pattern-sequential-iteration&#34;&gt;The pattern &amp;ldquo;sequential iteration&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;It can be generalize as follow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function iterate(index) {
  if (index === tasks.length) {
    return finish();
  }

  const task = tasks[index];
  task(function() {
    iterate(index + 1);
  })
}

function finish() {
  // iteration completed
}

iterate(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s important to notice that these type of algorithm become really recursive if &lt;code&gt;task()&lt;/code&gt; is an asynchronous operation. In such a case there might be a risk of hitting the maximum call stack limit.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pattern sequential iterator:
execute a list of tasks in sequence by creating a function &lt;code&gt;iterate()&lt;/code&gt; which invokes the next available task in the collection and makes sure to invoke next step of iteration when the current task is completed&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;parallel-execution&#34;&gt;Parallel execution&lt;/h2&gt;

&lt;p&gt;There is some situation when the order of execution of the set of asynchronous tasks is not important and we want just to be notified when all these running tasks are completed.&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/parallel-execution.png %}&lt;/p&gt;

&lt;p&gt;We realize that even thought we have one thread we can still achieve &lt;code&gt;concurrency&lt;/code&gt;, thanks to not-blocking nature of Node.js. In fact, the word &lt;code&gt;parallel&lt;/code&gt; is used improperly in this case, as it doesn&amp;rsquo;t mean that the task run simultaneously, but rather their execution is carried out by an underlying non-blocking API and invoked by the event loop.&lt;/p&gt;

&lt;p&gt;As we know, a task gives control back to the event loop when it request a new asynchronous operation, allowing the event loop to execute another task. The proper word is to use for this kind of flow is &lt;code&gt;concurrency&lt;/code&gt;, but we still use parallel for simplicity sake.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/1050222/concurrency-vs-parallelism-what-is-the-difference&#34;&gt;Concurrency vs Parallelism&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The following diagram shows how two asynchronous tasks can run in parallel in a Node.js program:&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/parallel-execution-diagram.png %}&lt;/p&gt;

&lt;p&gt;We have &lt;code&gt;Main&lt;/code&gt; function that executes two asynchronous tasks:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;Main&lt;/code&gt; function triggers the execution of &lt;code&gt;Task1&lt;/code&gt; and &lt;code&gt;Task2&lt;/code&gt;. As they are asynchronous operations the immediately return control to &lt;code&gt;Main&lt;/code&gt;, which then returns to &lt;code&gt;event loop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;When the asynchronous operation of &lt;code&gt;Task1&lt;/code&gt; is completed, the &lt;code&gt;event loop&lt;/code&gt; gives control to it. When &lt;code&gt;task1&lt;/code&gt; completes the internal synchronous operation processing as well, it notifies the &lt;code&gt;Main&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The same as described in p2 but now with &lt;code&gt;event loop&lt;/code&gt; triggers the &lt;code&gt;Task2&lt;/code&gt;. At this point &lt;code&gt;Main&lt;/code&gt; function knows that &lt;code&gt;Task1&lt;/code&gt; and &lt;code&gt;Task2&lt;/code&gt; are completed, so it can continue the execution or return the result of the operation to another callback.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;execution-with-spiderlinks&#34;&gt;Execution with &amp;ldquo;spiderLinks&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;So far application is executing the recursive download of the linked pages in a sequential fashion. We can easily improve performance of this process by downloading all the linked pages in parallel:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function spiderLink(url, body, nesting, cb) {
  if (nesting === 0) {
    return process.nextTick(cb);
  }
  const links = utils.getUrls(body);

  if (links.length === 0) {
    return process.nextTick(cb)
  }

  let completed = 0;
  let hasErrors = false;

  function done(err) {
    if (err) {
      hasErrors = true;
      return cb(err);
    }
    if (++completed === links.length &amp;amp;&amp;amp; !hasErrors) {
      return cb()
    }
  }

  links.forEach(link =&amp;gt; {
    spider(link, nesting - 1, done);
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The trick to make our application to wait for all the task to complete is to invoke the &lt;code&gt;spider()&lt;/code&gt; with a special callback &lt;code&gt;done()&lt;/code&gt;. The &lt;code&gt;done()&lt;/code&gt; increases a counter when a &lt;code&gt;spider()&lt;/code&gt; task completes. When the number of completed downloads reaches the size of &lt;code&gt;links[]&lt;/code&gt;, the final callback is invoked.&lt;/p&gt;

&lt;h3 id=&#34;the-pattern-unlimited-parallel-execution&#34;&gt;The pattern &amp;ldquo;unlimited parallel execution&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;We can represent a generic version of the pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const tasks = [ /*...*/ ];
let completed = 0;

tasks.forEach(task =&amp;gt; {
  task(() =&amp;gt; {
    if (++competed === tasks.length) {
      finish();  
    }
  })
})

function finish() {
  // all tasks are completed
}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Pattern unlimited parallel execution
Run a set of asynchronous tasks in parallel by spawning them all at once, and then waiting for all of them to complete by counting the number of the times their callback are invoked&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;limited-parallel-execution&#34;&gt;Limited parallel execution&lt;/h3&gt;

&lt;p&gt;Imagine having thousands of files to read, URLs to access, or DB queries run in parallel. A common problem in such situation is running out of memory. In all such situation its a good idea to limit the number of tasks that can run in the same time. The following diagram show a situation where we have five tasks that run in parallel with an concurrency limit of 2:&lt;/p&gt;

&lt;p&gt;{% image fancybox center images/concurency-limit.png %}&lt;/p&gt;

&lt;p&gt;The algorithm to execute a set of given tasks in parallel with limited concurrency:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const tasks = [ /*...*/ ];
let concurrency = 0;
let running = 0;
let completed = 0;
let index = 0;

function next() {
  while(running &amp;lt; concurrency &amp;amp;&amp;amp; index &amp;lt; tasks.length) {
    const task = tasks[index];

    running++;
    task(() =&amp;gt; {
      if (completed === tasks.length) {
        return finish();
      }
      completed++;
      running--;
      next();
    })
  }
}

next();

function finish() {
  // all tasks are completed
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;taskqueue-to-rescue&#34;&gt;&amp;ldquo;TaskQueue&amp;rdquo; to rescue&lt;/h3&gt;

&lt;p&gt;We are now going to implement a simple class which will combine a queue algorithm we presented before:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class TaskQueue {
  constructor(concurrency) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }

  pushTask(taks) {
    this.queue.push(task);
    this.next();
  }

  next() {
    while(this.running &amp;lt; this.concurrency &amp;amp;&amp;amp; this.queue.length) {
      const task = this.queue.shift();

      this.running++;
      task(() =&amp;gt; {
        this.running--;
        this.next();
      })
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can update our &lt;code&gt;spiderLink()&lt;/code&gt; to execute tasks in a limited parallel flow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const TaskQueue = require(&#39;./task-queue&#39;);
const downloadQueue = new TaskQueue(2);

function spiderLink(url, body, nesting, cb) {
  if (nesting === 0) {
    return process.nextTick(cb);
  }
  const links = utils.getUrls(body);

  if (links.length === 0) {
    return process.nextTick(cb)
  }

  let completed = 0;
  let hasErrors = false;

  links.forEach(link =&amp;gt; {
    downloadQueue.pushTask(done =&amp;gt; {
      spider(link, nesting - 1, done);
    })
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;chapter-4-asynchronous-control-flow-with-es6-and-beyond&#34;&gt;Chapter 4: Asynchronous Control Flow with ES6 and beyond&lt;/h1&gt;

&lt;p&gt;We are going to explore some of the most famous alternatives, &lt;code&gt;promises&lt;/code&gt;, &lt;code&gt;generators&lt;/code&gt; and an innovative syntax of ES7 the &lt;code&gt;async await&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Historically, there have been many different implementation of promise libraries, and most of them aren&amp;rsquo;t compatible between each other. The JS community worked hard to sort out this limitation and these efforts leads to creation of &lt;code&gt;Promise/A+&lt;/code&gt; spec.&lt;/p&gt;

&lt;p&gt;The several poplar libraries which implement the &lt;code&gt;Promise/A+&lt;/code&gt; spec:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bluebird&lt;/li&gt;
&lt;li&gt;Q&lt;/li&gt;
&lt;li&gt;RSVP&lt;/li&gt;
&lt;li&gt;When.js&lt;/li&gt;
&lt;li&gt;ES6 promises&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;es6-promises-techniques&#34;&gt;ES6 Promises techniques&lt;/h2&gt;

&lt;h3 id=&#34;promisifying-a-node-js-style-function&#34;&gt;Promisifying a Node.js style function&lt;/h3&gt;

&lt;p&gt;In JS not all the asynchronous functions and libraries support promises out-of-box. We can convert a typical callback-based function into one that returns a promise, this process is also known as &lt;code&gt;promisification&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module.exports.promisify = function(fn) {
  return function promisified(...callArgs) {
    return new Promise((resolve, reject) =&amp;gt; { //[1]
      callArgs.push((err, result, ...restResults) =&amp;gt; { //[2]
        if (err) {
          return reject(err); //[3]
        }
        console.log(callArgs)
        if (callArgs.length &amp;lt;= 2) { //[4]
          resolve(result);
        } else {
          resolve([result, ...restResults]);
        }
      });

      // the same as fn.apply(null, callArgs)
      fn(...callArgs); //[5]
    });
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how it works:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;promisified()&lt;/code&gt; creates a new promise using &lt;code&gt;Promise&lt;/code&gt; constructor and immediately return it to caller&lt;/li&gt;
&lt;li&gt;We make sure to pass a special callback to &lt;code&gt;fn()&lt;/code&gt;. As we know that the callback always comes last, we append it to the arguments (&lt;code&gt;args&lt;/code&gt;) provided to the &lt;code&gt;promisified()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;In the special callback if we receive an error we immediately reject an error&lt;/li&gt;
&lt;li&gt;If no error, we resolve the promise with a value or an array of values, depending how many results are passing to callback&lt;/li&gt;
&lt;li&gt;Finally, we simply invoke the &lt;code&gt;fs()&lt;/code&gt; with the list of arguments we have built&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Another approach is to use one of the ready-production npm packages, for example &lt;a href=&#34;https://www.npmjs.com/package/tiny-promisify&#34;&gt;tini-promisify&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;sequential-execution-1&#34;&gt;Sequential execution&lt;/h3&gt;

&lt;p&gt;We are now ready to convert our web spider application to use promises:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const utilities = require(&#39;utilities&#39;);
const promisify = utilities.promisify;

// const fs = require(fs);
const request = promisify(require(&#39;request&#39;));
const makedirp = promisify(require(&#39;makedirp&#39;));
const readFile = promisify(require(fs.readFile));
const writeFile = promisify(require(fs.writeFile));

function spider(url, nesting) {
  const filePath = utils.urlToFilePath(url);
  const fileName = utils.urlToFileName(url);

  return readFile(path.join(filePath, fileName), &#39;utf8&#39;)
    .then(body =&amp;gt; spiderLink(url, body, nesting))
    .catch((err) =&amp;gt; {
      if (err) {
        if (err.code === &#39;ENOENT&#39;) { 
          return download(url, fileName);
        }
      }
    })
    .then(body =&amp;gt; {
      spiderLink(url, body, nesting)
    })
}

function download(url, filename) {
  let body = body;

  return request(url)
    .then(resp =&amp;gt; {
      body = resp.body;
      return mkdirp(path.dirname(url));
    })
    .then(() =&amp;gt; writeFile(filename, body))
    .then(() =&amp;gt; {
      console.log(`Download and saved ${fileName} from ${url}`);
      return body;
    })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also we modify its invocation as follow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;spider(url, 5)
  .then(() =&amp;gt; console.log(chalk.green(`Download and saved from ${url}`)))
  .catch((err) =&amp;gt; console.log(chalk.red(`Error: ${err}`)));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we look again at code we have written so far, we would be pleasantly surprised by the fact that we haven&amp;rsquo;t include any error propagation logic, as we would be forced to do with callbacks. This is clearly a huge advantage, as it reduced boilerplate in our code.&lt;/p&gt;

&lt;h3 id=&#34;sequential-iteration&#34;&gt;Sequential iteration&lt;/h3&gt;

&lt;p&gt;So far it was shown how simple and elegant is to implement sequential execution flow using promises. However code involves only the &lt;code&gt;execution of a well known set of asynchronous operation&lt;/code&gt;. So, we missing peace that will complete our exploration of sequential execution flow with implementation of &lt;code&gt;asynchronous iteration&lt;/code&gt; using promises&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function spiderLink(url, body, nesting) {
  const links = utils.getUrls(body);
  let promise = Promise.resolve();
  
  if (nesting === 0) {
    return promise;
  }

  links.forEach(link =&amp;gt; {
    promise = promise.then(() =&amp;gt; spider(link, nesting--;))
  })

  return promise;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To iterate asynchronously over links we had dynamically build a chain of promises:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Starting with an &amp;ldquo;empty&amp;rdquo; promise, resolving to &lt;code&gt;undefined&lt;/code&gt;. This is a starting point to build our chain&lt;/li&gt;
&lt;li&gt;Then, in the loop, we&amp;rsquo;re updating the &lt;code&gt;promise&lt;/code&gt; variable with a new promise which is invoked from &lt;code&gt;then()&lt;/code&gt; on the previous promise in the chain. This is actually our asynchronous iteration pattern using promises.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s extract a pattern for a sequential execution using promises:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const tasks = [/*...*/];
let promise = Promise.resolve();

tasks.forEach(task =&amp;gt; {
  promise = promise.then(() =&amp;gt; task());
})

// an alternative with &amp;quot;reduce()&amp;quot;
/*
tasks.reduce((prev, task) =&amp;gt; {
  return prev.then(() =&amp;gt; task());
}, Promise.resolve())
*/

promise.then(() =&amp;gt; /*all task are completed*/)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The pattern: sequential iteration with promises
Dynamically builds a chain of promises in a loop&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;parallel-execution-1&#34;&gt;Parallel execution&lt;/h3&gt;

&lt;p&gt;Another execution flow is become trivial with promises is the parallel execution flow using &lt;code&gt;Promise.all()&lt;/code&gt;. This static method creates promise which fulfills only when all the promises received as input are fulfilled:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function spiderLink(url, body, nesting) {
  const links = utils.getUrls(body);
  
  if (nesting === 0) {
    Promise.resolve()
  }

  let promises = links.map(link =&amp;gt; spider(link, --nesting));

  return Promise.all(promises);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;limited-parallel-execution-1&#34;&gt;Limited parallel execution&lt;/h4&gt;

&lt;p&gt;In fact, the pattern we&amp;rsquo;ve implemented in &lt;code&gt;TaskQueue&lt;/code&gt; class can be easily adapted to support tasks that return a promise. This can be achieve by modifying &lt;code&gt;next()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;next() {
  while(this.running &amp;lt; this.concurrency &amp;amp;&amp;amp; this.queue.length) {
    const task = this.queue.shift();

    this.running++;
    
    task().then(() =&amp;gt; {
      completed++;
      running--;
      this.next();
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can modify the &lt;code&gt;spideLinks()&lt;/code&gt; to achieve limit of concurrency:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const TaskQueue = require(&#39;./task-queue&#39;);
const downloadQueue = new TaskQueue(2);

function spiderLink(url, body, nesting) {
  if (nesting === 0 || links.length === 0) {
    return Promise.resolve;
  }
  const links = utils.getUrls(body);

  let completed = 0;
  let hasErrors = false;

  return Promise((resolve, reject) =&amp;gt; {
    let completed = 0;
    let error = false;

    links.forEach(link =&amp;gt; {
      let task = () =&amp;gt; {
        return spider(link, --nesting)
          .then(() =&amp;gt; {
            if (++completed === links.length) {
              resolve()
            }
          })
          .catch((err) =&amp;gt; {
            if (!error) {
              error = true;
              reject();
            }
          })
      };
      downloadQueue.pushTask(task)
    })
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;exposing-callbacks-and-promises-in-public-apis&#34;&gt;Exposing callbacks and promises in public APIs&lt;/h4&gt;

&lt;p&gt;Now let&amp;rsquo;s imagine that we want to build a public library that performs asynchronous operations. Do we need to create CPS API or a promise-oriented one?&lt;/p&gt;

&lt;p&gt;The first approach is used by popular libraries such as &lt;code&gt;request&lt;/code&gt;, &lt;code&gt;redis&lt;/code&gt; and &lt;code&gt;mysql&lt;/code&gt;, consists of offering a simply API that is only based on callbacks and leaves the developer the option to promisify the exposed functionality of needed. Some of these libraries provides helpers to achieve a such behavior.&lt;/p&gt;

&lt;p&gt;The second approach is more transparent. It offers the developers a callback-oriented API, but it makes the callback argument optional. When the callback is not passed, the function will immediately return a &lt;code&gt;Promise&lt;/code&gt; object. This approach gives possibility to choose at call time what interface to adopt, without any needs to promisify the functionality in advance. Many libraries, such as &lt;code&gt;mongoose&lt;/code&gt; or &lt;code&gt;sequelize&lt;/code&gt;, support this approach.&lt;/p&gt;

&lt;p&gt;A dummy module that executes division asynchronously:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//divider.js
module.exports = (divident, divisor, cb) {
  return new Promise(resolve, reject) =&amp;gt; {
    process.nextTich(() =&amp;gt; {
      const result = divident / divisor;

      if (!Number.isInteger(result)) {
        const err = new Error(&#39;Invalid operands&#39;);

        if (cb) return cb(err);
        reject(err);
      }
      if (cb) return cb(null, result);
      resolve(result);
    })
  }
}

//main.js
const divider = require(&#39;./divider&#39;)
divider(10, 0, (err, res) =&amp;gt; {
  if (err) return console.error(err);

  console.log(res);
});

divider(10, 2)
  .then(res =&amp;gt; console.log(res))
  .catch(err =&amp;gt; console.error(err));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;generators&#34;&gt;Generators&lt;/h2&gt;

&lt;p&gt;In fact, in a normal function we can only have one entry point which corresponds to the invocation of function itself. A generator is similar to a function, but in addition, it can be suspended (using the &lt;code&gt;yield&lt;/code&gt; statement) and then resumed at a later time.&lt;/p&gt;

&lt;h3 id=&#34;asynchronous-control-flow-with-generators&#34;&gt;Asynchronous control flow with generators&lt;/h3&gt;

&lt;p&gt;To demonstrate how generator will help us with this by creating a special function that accepts a generator as an argument and allows us to use asynchronous code inside the generator. The function take care to resume the execution of the generator when the asynchronous operation is complete:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function asyncFlow(generatorFn) {
  const generator = generatorFn(cb);
  generator.next();

  // special callback to resume/stop the generator
  // resume by passing back the result receiving in the cb function
  function cb(err, ...result) {
    if (err) {
      return generator.throw(err);
    }

    generator.next(result);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To demonstrate the power of this simple function with new module:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// clone.js
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

asyncFlow(function* (cb) {
  const filename = path.basename(__filename);
  const content = yield fs.readFile(filename, &#39;utf8&#39;, cb);

  yield fs.writeFile(`clone_of_${filename}`, content, cb);
  console.log(&#39;clone created&#39;);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remarkable with help of &lt;code&gt;asyncFlow()&lt;/code&gt; we were able to write asynchronous code using the linear approach, as we using blocking function! The callback passed to each asynchronous function will in turn resume the generator as soon as a asynchronous operation is complete.&lt;/p&gt;

&lt;p&gt;There are two other variation of these technique, one involves to use &lt;code&gt;promises&lt;/code&gt; and other use &lt;code&gt;thunks&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;thunk&lt;/code&gt; used in the generator based control flow it&amp;rsquo;s just a function which partially applies all the arguments of original function except its callback. An example of thunkified version of &lt;code&gt;fs.readFile()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function readFileThunk(filename, options) {
  return function(cb) {
    fs.readFile(filename, options, cb);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both promises and thunks allow us to create generators that do not need a callback argument. Thunkfied version of &lt;code&gt;asynkFlow()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

asyncFlowWithThunks(function* () {
  const filename = path.basename(__filename);
  const content = yield readFileThunk(filename, &#39;utf8&#39;);

  yield writeFileThunk(`clone_of_${filename}`, content);
  console.log(&#39;clone created&#39;);
})

function readFileThunk(filename, options) {
  return function(cb) {
    fs.readFile(filename, options, cb);
  }
}

function writeFileThunk(filename, constent) {
  return function(cb) {
    fs.writeFile(filename, constent, cb);
  }
}


function asyncFlow(generatorFn) {
  const generator = generatorFn();
  const thunk = generator.next().value;
  thunk &amp;amp;&amp;amp; thunk(cb);
  
  function cb(err, ...result) {
    let thunk;

    if (err) {
      return generator.throw(err);
    }

    thunk = generator.next(result).value;
    thunk &amp;amp;&amp;amp; thunk(cb);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the same way we could implement a version with promises:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

asyncFlowWithPromises(function* () {
  const filename = path.basename(__filename);
  const content = yield readFilePromise(filename, &#39;utf8&#39;);

  yield writeFilePromise(`clone_of_${filename}`, content);
  console.log(&#39;clone created&#39;);
})

function readFilePromise(filename, options) {
  const readFile = promisify(fs.readFile);
  return (cb) =&amp;gt; {
    fs.readFile(filename, options, cb);
  };
}

function writeFilePromise(filename, content) {
  const readFile = promisify(fs.writeFile);
  return (cb) =&amp;gt; {
    fs.writeFile(filename, content, cb);
  };
}

function promisify(fn) {
  return function promisified(...callArgs) {
    return new Promise((resolve, reject) =&amp;gt; { 
      callArgs.push((err, result, ...restResults) =&amp;gt; { 
        if (err) {
          return reject(err); 
        }
        console.log(callArgs)
        if (callArgs.length &amp;lt;= 2) { 
          resolve(result);
        } else {
          resolve([result, ...restResults]);
        }
      });
      
      fn(...callArgs); 
    });
  }
}

function asyncFlow(generatorFn) {
  const generator = generatorFn();
  const thunk = generator.next().value;
  thunk &amp;amp;&amp;amp; thunk(cb);
  
  function cb(err, ...result) {
    let thunk;

    if (err) {
      return generator.throw(err);
    }

    thunk = generator.next(result).value;
    thunk &amp;amp;&amp;amp; thunk(cb);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generator based control flow using &amp;ldquo;co&amp;rdquo;&lt;/p&gt;

&lt;p&gt;In this section we chose to use &lt;a href=&#34;https://www.npmjs.com/package/co&#34;&gt;co&lt;/a&gt;. It supports several types of yieldables:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;thunks&lt;/li&gt;
&lt;li&gt;promises&lt;/li&gt;
&lt;li&gt;array (parallel execution)&lt;/li&gt;
&lt;li&gt;object (parallel execution)&lt;/li&gt;
&lt;li&gt;generators (delegation)&lt;/li&gt;
&lt;li&gt;generator function (delegation)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To convert Node.js style function to thunks, we are going to library &lt;a href=&#34;https://www.npmjs.com/package/thunkify&#34;&gt;thunkify&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;sequential-execution-2&#34;&gt;Sequential execution&lt;/h3&gt;

&lt;p&gt;Load and convert all dependencies:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// spider.js
const thunkify = require(&#39;thunkify&#39;);
const co = require(&#39;co&#39;);
const path = require(&#39;path&#39;);

const request = thunkify(require(&#39;request&#39;));
const fs = require(&#39;fs&#39;);
const mkdirp = thunkify(require(&#39;mkdirp&#39;));
const readFile = thunkify(fs.readFile);
const writeFile = thunkify(fs.writeFile);
const nextTick = thunkify(process.nextTick);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Is interesting to point out if we decided to use the promisified version of our function instead of their thunkified alternatives, so code would be remain exactly the same, thanks to the fact that &lt;code&gt;co&lt;/code&gt; supports both promises and thunks yiedlable objects.&lt;/p&gt;

&lt;p&gt;Now implementation of &lt;code&gt;download()&lt;/code&gt; and &lt;code&gt;spider()&lt;/code&gt; becomes trivial:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function* download(url, filename) {
  console.log(`download ${url}`);
  const response = yield request(url);
  const body = response[1];

  yield mkdirp(path.dirname(filename));
  yield writeFile(filename, body);
  console.log(`downloaded and saved file ${filename}`);

  return body;
}

function* spider(url, nesting) {
  const filename = utilities.urlToFilename(url);
  let body;

  try {
    body = yield readFile(url, &#39;utf8&#39;);
  } catch(e) {
    if (e.code !== &#39;ENOENT&#39;) {
      throw e;
    }
    body = yield download(url, filename);
  }
  yield spiderLink(url, body, nesting);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The interesting detail to notice that we&amp;rsquo;re able to use a &lt;code&gt;try...catch&lt;/code&gt; and propagate error with &lt;code&gt;throw&lt;/code&gt;! Another remarkable line is where we use &lt;code&gt;yield download()&lt;/code&gt; which is not a promise nor a thunk, but just another generator. This is possible thanks to &lt;code&gt;co&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Converting &lt;code&gt;spiderLinks()&lt;/code&gt; becomes trivial as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function spiderLinks(url, body, nesting) {
  if (nesting === 0) {
    return nextTick();
  }

  const links = utilities.getPageLinks(body);
  links.forEach(link =&amp;gt; {
    yield spider(link, nesting - 1);
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The is no pattern to show for sequential iteration, generators and &lt;code&gt;co&lt;/code&gt; are doing the all dirty work for us, so we&amp;rsquo;re able to write asynchronous iteration as we were using blocking, direct APIs.&lt;/p&gt;

&lt;p&gt;Now an important entry point:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;co(function* () {
  const nesting = 1;
  try {
    yield spider(process.argv[2], nesting);
  } catch(e) {
    console.log(e);
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The whole implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const thunkify = require(&#39;thunkify&#39;);
const co = require(&#39;co&#39;);
const path = require(&#39;path&#39;);

const request = thunkify(require(&#39;request&#39;));
const fs = require(&#39;fs&#39;);
const mkdirp = thunkify(require(&#39;mkdirp&#39;));
const readFile = thunkify(fs.readFile);
const writeFile = thunkify(fs.writeFile);
const nextTick = thunkify(process.nextTick);

const utilities = require(&#39;./utils&#39;);

co(function* () {
  const nesting = 1;
  try {
    yield spider(process.argv[2], nesting);
  } catch(e) {
    console.log(e);
  }
})

function* download(url, filename) {
  console.log(`download ${url}`);
  const response = yield request(url);
  const body = response[1];

  yield mkdirp(path.dirname(filename));
  yield writeFile(filename, body);
  console.log(`downloaded and saved file ${filename}`);

  return body;
}

function* spider(url, nesting) {
  const filename = utilities.urlToFileName(url);
  let body;

  try {
    body = yield readFile(filename, &#39;utf8&#39;);
  } catch(e) {
    if (e.code !== &#39;ENOENT&#39;) {
      throw e;
    }
    body = yield download(url, filename);
  }
  yield spiderLinks(filename, body, nesting);
}

function* spiderLinks(url, body, nesting) {
  if (nesting === 0) {
    return nextTick();
  }

  const links = utilities.getUrls(body);

  for (var i = 0; i &amp;lt; links.length; i++) {
    yield spider(links[i], nesting - 1);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;parallel-execution-2&#34;&gt;Parallel execution&lt;/h3&gt;

&lt;p&gt;The bad news about generators is that they are good to write sequential algorithm, they can&amp;rsquo;t be used to parallelize the execution of set of tasks.&lt;/p&gt;

&lt;p&gt;Luckily, for the specific case of the unlimited parallel execution, &lt;code&gt;co&lt;/code&gt; already allows us to obtain it natively by simpling yielding an array of promises, thunks, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function* spiderLinks(url, body, nesting) {
  if (nesting === 0) {
    return nextTick();
  }

  const links = utilities.getUrls(body);
  const tasks = links.map(link =&amp;gt; spider(link, nesting - 1));
  yield tasks;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we just did was just to collect all the download tasks, which are essentially generators, and then yield on the resulting array. All these task will be executed by &lt;code&gt;co&lt;/code&gt; in parallel and then execution will be resumed when all tasks finish running.&lt;/p&gt;

&lt;h3 id=&#34;limited-parallel-execution-2&#34;&gt;Limited parallel execution&lt;/h3&gt;

&lt;p&gt;The main straightforward approach for me is to use &lt;a href=&#34;https://www.npmjs.com/package/co-limiter&#34;&gt;co-limiter&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const co = require(&#39;co&#39;);
const wait = require(&#39;co-wait&#39;);
const limiter = require(&#39;co-limiter&#39;);

const limit = limiter(2);

const job = function *() {
  console.log(&#39;Doing something...&#39;);
  yield wait(1000);
}

for (let i = 0; i &amp;lt; 10; i++) {
  co(function *() {
    yield limit(job());
  })();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;async-await-with-babel&#34;&gt;&amp;ldquo;async&amp;hellip;await&amp;rdquo; with Babel&lt;/h2&gt;

&lt;p&gt;Preparation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# install babel cli
$ npm install -D babel-cli
# extension to support &amp;quot;async...await&amp;quot; parsing
$ npm install -D babel-plugin-syntax-async-functions
babel-plugin-transform-async-to-generator
# run the example
$ node_modules\.bin\babel-node --plugins
&amp;quot;syntax-async-functions,transform-async-to-generator&amp;quot; index.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is that generator function are designed to deal mostly as iterators and their usage with asynchronous operations feel a bit cumbersome. It might be hard to understand, leading to code that hard to read and maintain.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;async&lt;/code&gt; function specification aims to dramatically improve the language model for waiting asynchronous code by introducing &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; directives:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const promisify = require(&#39;tiny-promisify&#39;);
const request = promisify(require(&#39;request&#39;));

function getPage(url) {
  return request(url).then(res =&amp;gt; {
    return res.body;
  });
}

async function main() {
  const html = await getPage(&#39;http://example.com&#39;);
  console.log(html);
}
main();

console.log(&#39;loading...&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;comparison-table&#34;&gt;Comparison Table&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Plain JS

&lt;ul&gt;
&lt;li&gt;Pros:&lt;/li&gt;
&lt;li&gt;Does not require any additional libraries or technology&lt;/li&gt;
&lt;li&gt;Offer the best performance&lt;/li&gt;
&lt;li&gt;Provides the best compatibility with 3-th party libraries&lt;/li&gt;
&lt;li&gt;Allows creation of ad hoc and more advanced algorithms&lt;/li&gt;
&lt;li&gt;Cons:&lt;/li&gt;
&lt;li&gt;Require extra code and relatively complex algorithms&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Promises

&lt;ul&gt;
&lt;li&gt;Pros:&lt;/li&gt;
&lt;li&gt;Simplify the most common control flow patters&lt;/li&gt;
&lt;li&gt;Robust error handling&lt;/li&gt;
&lt;li&gt;Part of ES6 spec&lt;/li&gt;
&lt;li&gt;Cons:&lt;/li&gt;
&lt;li&gt;Require promisify callback-based APIs&lt;/li&gt;
&lt;li&gt;A small performance hit&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Generators:

&lt;ul&gt;
&lt;li&gt;Pros:&lt;/li&gt;
&lt;li&gt;Makes non-blocking code looks like a blocking one&lt;/li&gt;
&lt;li&gt;Simplify error handling&lt;/li&gt;
&lt;li&gt;Part of ES6 spec&lt;/li&gt;
&lt;li&gt;Cons:&lt;/li&gt;
&lt;li&gt;Require a complementary control flow library&lt;/li&gt;
&lt;li&gt;Require callback or promises to implement non-sequential flows&lt;/li&gt;
&lt;li&gt;Require thunkify or promisify nongenerator-based APIs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Async await

&lt;ul&gt;
&lt;li&gt;Pros:&lt;/li&gt;
&lt;li&gt;Makes a non-blocking code looks like blocking&lt;/li&gt;
&lt;li&gt;Clean and intuitive syntax&lt;/li&gt;
&lt;li&gt;Future part of spec&lt;/li&gt;
&lt;li&gt;Cons:&lt;/li&gt;
&lt;li&gt;Not yet a standard&lt;/li&gt;
&lt;li&gt;Require transpilers such as Babel&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Gulp screencast overview</title>
      <link>https://qetr1ck-op.github.io/blog/post/Gulp-screencast-overview/</link>
      <pubDate>Wed, 28 Sep 2016 20:43:36 +0000</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/Gulp-screencast-overview/</guid>
      <description>&lt;p&gt;Depth table of contents of one of the most popular screencast about utility for managing tasks.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;what-is-gulp-compare-with-webpack&#34;&gt;What is Gulp? Compare with Webpack.&lt;/h1&gt;

&lt;p&gt;What is Gulp?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Gulp as a &amp;ldquo;streaming build system&amp;rdquo;, and moreover, it&amp;rsquo;s a utility for declaring tasks &lt;a href=&#34;https://youtu.be/uPk6lQoTThE?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=10&#34;&gt;0:10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Example &lt;code&gt;gruntfile.js&lt;/code&gt;&lt;a href=&#34;https://youtu.be/uPk6lQoTThE?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=53&#34;&gt;0:53&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Comparing with Grunt. &lt;a href=&#34;https://youtu.be/uPk6lQoTThE?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=170&#34;&gt;2:50&lt;/a&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;gruntfile.js&lt;/code&gt; vs &lt;code&gt;gruntfile.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;More compact config&lt;/li&gt;
&lt;li&gt;Virtual File System - Vinyl FS. No temp folders&lt;/li&gt;
&lt;li&gt;Power of streams, streams parallelism&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Comparing with Webpack &lt;a href=&#34;https://youtu.be/uPk6lQoTThE?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=600&#34;&gt;10:10&lt;/a&gt;

&lt;ol&gt;
&lt;li&gt;Deps: CommonJS, AMD, ES2015&lt;/li&gt;
&lt;li&gt;Dynamic loading&lt;/li&gt;
&lt;li&gt;CommonsChungPlugin&lt;/li&gt;
&lt;li&gt;APIs&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Webpack + Gulp = 💕 &lt;a href=&#34;https://youtu.be/uPk6lQoTThE?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=825&#34;&gt;16:45&lt;/a&gt;

&lt;ol&gt;
&lt;li&gt;Tasks: Gulp&lt;/li&gt;
&lt;li&gt;JS Build: Webpack&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;install-and-task-running&#34;&gt;Install and task running&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Installing strategies: local vs global &lt;a href=&#34;https://youtu.be/xptUdO3GuG8?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=22&#34;&gt;0:22&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Installing v4 &lt;code&gt;npm i -D gulpjs/gulp.git#4.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;First task &lt;a href=&#34;https://youtu.be/xptUdO3GuG8?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=229&#34;&gt;3:49&lt;/a&gt;

&lt;ol&gt;
&lt;li&gt;Callback for finish async operation&lt;/li&gt;
&lt;li&gt;Task name as function name&lt;/li&gt;
&lt;li&gt;Separate tasks with namespace &lt;code&gt;deploy:production&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Strategies for finish async operations&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gulp.series&lt;/code&gt; and &lt;code&gt;gulp.parallel&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://demisx.github.io/gulp4/2015/01/15/install-gulp4.html&#34;&gt;Have to install v4 before it&amp;rsquo;s officially released&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iliakan/gulp-screencast/tree/master/02-basics&#34;&gt;Code examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;streams-vinyl-fs&#34;&gt;Streams Vinyl-FS&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Example streams with coping files &lt;a href=&#34;https://youtu.be/NBdKplKl_3Q?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=45&#34;&gt;0:45&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gulp.src&lt;/code&gt; and &lt;code&gt;gulp.dest&lt;/code&gt; output as readable/writable streams of instance Vinyl-FS &lt;a href=&#34;https://youtu.be/NBdKplKl_3Q?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=65&#34;&gt;1:05&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Log working files &lt;code&gt;.on(&#39;data&#39;, (file) =&amp;gt; file)&lt;/code&gt; &lt;a href=&#34;https://youtu.be/NBdKplKl_3Q?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=118&#34;&gt;1:48&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;File getter properties &lt;a href=&#34;https://youtu.be/NBdKplKl_3Q?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=190&#34;&gt;3:10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Control &lt;code&gt;gulp.dest&lt;/code&gt; output &lt;a href=&#34;https://youtu.be/NBdKplKl_3Q?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=285&#34;&gt;4:45&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Module &lt;code&gt;minimatch&lt;/code&gt; and popular pattens &lt;a href=&#34;https://youtu.be/NBdKplKl_3Q?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=418&#34;&gt;6:48&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Performance issue with globs &lt;a href=&#34;https://youtu.be/NBdKplKl_3Q?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=553&#34;&gt;9:13&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Summary &lt;a href=&#34;https://youtu.be/NBdKplKl_3Q?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=710&#34;&gt;11:50&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iliakan/gulp-screencast/tree/master/03-vinyl&#34;&gt;Code examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;basic-build-for-styles&#34;&gt;Basic build for styles&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;App structure &lt;a href=&#34;https://youtu.be/_BFWG82mMkw?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=26&#34;&gt;0:25&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Declaring task for stylus &lt;a href=&#34;https://youtu.be/_BFWG82mMkw?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=73&#34;&gt;1:13&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Change destination directory &lt;a href=&#34;https://youtu.be/_BFWG82mMkw?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=344&#34;&gt;5.40&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Concat files &lt;a href=&#34;https://youtu.be/_BFWG82mMkw?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=430&#34;&gt;7:10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Log info with &lt;code&gt;gulp-debug&lt;/code&gt; &lt;a href=&#34;https://youtu.be/_BFWG82mMkw?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=470&#34;&gt;7:50&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Create &lt;code&gt;main.styl&lt;/code&gt; &lt;a href=&#34;https://youtu.be/_BFWG82mMkw?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=631&#34;&gt;10:31&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Add source maps &lt;a href=&#34;https://youtu.be/_BFWG82mMkw?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=690&#34;&gt;11:30&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Generate source maps only in dev mode &lt;a href=&#34;https://youtu.be/_BFWG82mMkw?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=904&#34;&gt;15:05&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Using &lt;code&gt;gulp-if&lt;/code&gt; &lt;a href=&#34;https://youtu.be/_BFWG82mMkw?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=1025&#34;&gt;17:05&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Create &lt;code&gt;clean&lt;/code&gt; task with &lt;code&gt;del&lt;/code&gt; &lt;a href=&#34;https://youtu.be/_BFWG82mMkw?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=1145&#34;&gt;19:05&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Create &lt;code&gt;copy&lt;/code&gt; task with &lt;code&gt;gulp.parallel&lt;/code&gt; &lt;a href=&#34;https://youtu.be/_BFWG82mMkw?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=1229&#34;&gt;20:24&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Result in browser with &lt;code&gt;node-static&lt;/code&gt; &lt;a href=&#34;https://youtu.be/_BFWG82mMkw?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=1315&#34;&gt;21:55&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Summary &lt;a href=&#34;https://youtu.be/_BFWG82mMkw?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=1397&#34;&gt;23:18&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iliakan/gulp-screencast/tree/master/04-styles-3&#34;&gt;Code examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;incremental-build-watch&#34;&gt;Incremental build, watch&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Create &lt;code&gt;gulp.watch&lt;/code&gt; for styles &lt;a href=&#34;https://youtu.be/jocvHauHcA4?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=30&#34;&gt;0:30&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;What does &amp;ldquo;incremental build&amp;rdquo; actually mean? Caching &lt;a href=&#34;https://youtu.be/jocvHauHcA4?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=115&#34;&gt;1:55&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Create &lt;code&gt;gulp.watch&lt;/code&gt; for assets with caching with &lt;code&gt;{ since: gulp.lastRun(&#39;taskName&#39;) }&lt;/code&gt; &lt;a href=&#34;https://youtu.be/jocvHauHcA4?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=235&#34;&gt;3:55&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Module &lt;code&gt;chokidar&lt;/code&gt; and deleting files with watch &lt;a href=&#34;https://youtu.be/jocvHauHcA4?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=410&#34;&gt;6:49&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Decoupling watch-es into separate task &lt;a href=&#34;https://youtu.be/jocvHauHcA4?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=512&#34;&gt;8:32&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Summary &lt;a href=&#34;https://youtu.be/jocvHauHcA4?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=573&#34;&gt;9:32&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iliakan/gulp-screencast/tree/master/05-watch&#34;&gt;Code examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;incremental-and-performance&#34;&gt;Incremental and performance&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Filter new files for first task run with &lt;code&gt;gulp-newer&lt;/code&gt; &lt;a href=&#34;https://youtu.be/uYZPNrT-e-8?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=35&#34;&gt;0:36&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Problem with &lt;code&gt;gulp-remember&lt;/code&gt; on example with &lt;code&gt;gulp-autoprefixer&lt;/code&gt; &lt;a href=&#34;https://youtu.be/uYZPNrT-e-8?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=237&#34;&gt;3:57&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Problem with returning deleted files from IDE, using &lt;code&gt;gulp-cached&lt;/code&gt; as alternative of &lt;code&gt;since&lt;/code&gt; &lt;a href=&#34;https://youtu.be/uYZPNrT-e-8?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=609&#34;&gt;10:10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Summary &lt;a href=&#34;https://youtu.be/uYZPNrT-e-8?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=920&#34;&gt;15:20&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iliakan/gulp-screencast/tree/master/06-watch-perf-remember-cached&#34;&gt;Code examples 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iliakan/gulp-screencast/tree/master/06-watch-perf-newer&#34;&gt;Code examples 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;browser-auto-reloading-browser-sync&#34;&gt;Browser auto-reloading, browser-sync&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;We don&amp;rsquo;t want to every time hit &lt;code&gt;F5&lt;/code&gt;! Flow overview &lt;a href=&#34;https://youtu.be/oiMJNIG-yvg?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=14&#34;&gt;0:14&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Create &lt;code&gt;sync&lt;/code&gt; task with &lt;code&gt;browser-sync&lt;/code&gt; &lt;a href=&#34;https://youtu.be/oiMJNIG-yvg?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=104&#34;&gt;1:34&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iliakan/gulp-screencast/tree/master/07-browsersync&#34;&gt;Code examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;error-handling&#34;&gt;Error handling&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Make an error &lt;a href=&#34;https://youtu.be/otkXzef2wQY?t=20&#34;&gt;0:20&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Was error couched? &lt;a href=&#34;https://youtu.be/otkXzef2wQY?t=85&#34;&gt;1:25&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Notification for an error with &lt;code&gt;gulp-notify&lt;/code&gt; &lt;a href=&#34;https://youtu.be/otkXzef2wQY?t=171&#34;&gt;2:51&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Catch all errors on task with &lt;code&gt;gulp-plumber&lt;/code&gt; &lt;a href=&#34;https://youtu.be/otkXzef2wQY?t=390&#34;&gt;6:30&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Solution with &lt;code&gt;multipipe&lt;/code&gt; &lt;a href=&#34;https://youtu.be/otkXzef2wQY?t=590&#34;&gt;9:50&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iliakan/gulp-screencast/tree/master/08-errors-combiner&#34;&gt;Code examples 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iliakan/gulp-screencast/tree/master/08-errors-plumber&#34;&gt;Code examples 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;creating-plugins-with-through2&#34;&gt;Creating plugins with &amp;ldquo;through2&amp;rdquo;&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;What we need to start &lt;a href=&#34;https://youtu.be/Ijg9I1CY7Ok?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=29&#34;&gt;0:29&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A real example &lt;a href=&#34;https://youtu.be/Ijg9I1CY7Ok?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=221&#34;&gt;3:41&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iliakan/gulp-screencast/tree/master/09-plugins-through2&#34;&gt;Code examples 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iliakan/gulp-screencast/tree/master/09-plugins-through2-2&#34;&gt;Code examples 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;more-complex-stream-with-eslint-gulp-if-stream-combiner2&#34;&gt;More complex stream with &amp;ldquo;eslint&amp;rdquo;, &amp;ldquo;gulp-if&amp;rdquo;, &amp;ldquo;stream-combiner2&amp;rdquo;&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Example with &lt;code&gt;pre-commit&lt;/code&gt; &lt;a href=&#34;https://youtu.be/pjdrg6n5puU?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=115&#34;&gt;1:55&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Optimize repeatable checks &lt;a href=&#34;https://youtu.be/pjdrg6n5puU?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=248&#34;&gt;4:08&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Performance summary &lt;a href=&#34;https://youtu.be/pjdrg6n5puU?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=890&#34;&gt;14:50&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iliakan/gulp-screencast/blob/master/10-plugins-lint/gulpfile.js&#34;&gt;Code examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;how-we-know-node-js-streams&#34;&gt;How we know Node.JS streams?&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;A small test &lt;a href=&#34;https://youtu.be/5aJB4vJlHBs?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=20&#34;&gt;0:20&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Why it isn&amp;rsquo;t work? &lt;a href=&#34;https://youtu.be/5aJB4vJlHBs?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=65&#34;&gt;1:05&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Fix the &amp;ldquo;pause&amp;rdquo; problem &lt;a href=&#34;https://youtu.be/5aJB4vJlHBs?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=280&#34;&gt;4:00&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iliakan/gulp-screencast/tree/master/11-plugins-streams&#34;&gt;Code examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;structure-of-gulpfile-js&#34;&gt;Structure of &amp;ldquo;gulpfile.js&amp;rdquo;&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;We have problems, don&amp;rsquo;t we? &lt;a href=&#34;https://youtu.be/Qc6go3cNuRk?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=20&#34;&gt;0:20&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A solution is task decomposition &lt;a href=&#34;https://youtu.be/Qc6go3cNuRk?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=110&#34;&gt;1:50&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Adding &lt;code&gt;gulp-load-plugins&lt;/code&gt; &lt;a href=&#34;https://youtu.be/Qc6go3cNuRk?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=305&#34;&gt;5:05&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Result after refactoring &lt;a href=&#34;https://youtu.be/Qc6go3cNuRk?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=410&#34;&gt;6:50&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iliakan/gulp-screencast/tree/master/12-organize-final&#34;&gt;Code examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;a-real-example-styles-assets-sprites-production&#34;&gt;A real example: styles, assets, sprites, production&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Goal and app structure &lt;a href=&#34;https://youtu.be/VqYAitDKbpo?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=15&#34;&gt;0:15&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Improving build of styles and assets &lt;a href=&#34;https://youtu.be/VqYAitDKbpo?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=115&#34;&gt;1:55&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A typical problem with preprocessors with &lt;code&gt;src&lt;/code&gt; and fixing with &lt;code&gt;resolver&lt;/code&gt; &lt;a href=&#34;https://youtu.be/VqYAitDKbpo?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=242&#34;&gt;4:03&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Working with sprites using &lt;code&gt;gulp-svg-sprites&lt;/code&gt; &lt;a href=&#34;https://youtu.be/VqYAitDKbpo?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=380&#34;&gt;6:20&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Add production mode: minify with &lt;code&gt;gulp-cssnano&lt;/code&gt;, resource hash with &lt;code&gt;gulp-rev&lt;/code&gt; and &lt;code&gt;gulp-rev-replace&lt;/code&gt;  &lt;a href=&#34;https://youtu.be/VqYAitDKbpo?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=914&#34;&gt;15:13&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Do we need to use long-term hashing for images?  &lt;a href=&#34;https://youtu.be/VqYAitDKbpo?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=1337&#34;&gt;22:17&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Summary &lt;a href=&#34;https://youtu.be/VqYAitDKbpo?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=1536&#34;&gt;25:35&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iliakan/gulp-screencast/tree/master/12-organize-final&#34;&gt;Code examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;integration-with-webpack&#34;&gt;Integration with Webpack&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Summary &lt;a href=&#34;https://youtu.be/ohWOWqskHWU?list=PLDyvV36pndZFLTE13V4qNWTZbeipNhCgQ&amp;amp;t=1636&#34;&gt;27:16&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iliakan/gulp-screencast/tree/master/14-webpack-stream&#34;&gt;Code examples 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iliakan/gulp-screencast/tree/master/14-webpack-final-direct&#34;&gt;Code examples 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>NG6 starter for new Angular projects</title>
      <link>https://qetr1ck-op.github.io/blog/post/NG6-starter-for-new-Angular-projects/</link>
      <pubDate>Sun, 18 Sep 2016 19:03:17 +0000</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/NG6-starter-for-new-Angular-projects/</guid>
      <description>&lt;p&gt;The de-facto starter repo for building scalable apps with AngularJS ^1.5, ES6, Gulp and Webpack&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/gebidesign/NG6-starter-sass#ng6&#34;&gt;Github repo&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Start new project on Angular ^1.5</title>
      <link>https://qetr1ck-op.github.io/blog/post/Start-new-project-on-Angular-1-5/</link>
      <pubDate>Sun, 18 Sep 2016 18:42:49 +0000</pubDate>
      
      <guid>https://qetr1ck-op.github.io/blog/post/Start-new-project-on-Angular-1-5/</guid>
      <description>&lt;p&gt;Great series of recommendation how/why to start new &amp;ldquo;NG2 ready&amp;rdquo; Angular 1.5 app with architecture of component-oriented approach.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;how-to-do-it-right&#34;&gt;How to do it right&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://velesin.io/2016/04/14/starting-a-new-app-in-angular-1-5/&#34;&gt;Starting a new app in Angular 1.5, does it make sense?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://velesin.io/2016/04/26/angular-1-5-app-as-a-tree-of-components/&#34;&gt;Angular 1.5 app as tree of components&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://velesin.io/2016/05/18/communication-between-angular-1-5-components/&#34;&gt;Communication between Angular 1.5 components and with API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://velesin.io/2016/05/31/angular-1-5-fractal-project-structure/&#34;&gt;A flexible Angular 1.5 project structure (the &amp;ldquo;fractal&amp;rdquo; approach)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://velesin.io/2016/07/12/angular-1-5-project-in-es6-es2015/&#34;&gt;Writing Angular 1.5 in ES6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://velesin.io/2016/08/23/unit-testing-angular-1-5-components/&#34;&gt;Unit testing Angular 1.5 components&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;style-guides-for-app&#34;&gt;Style guides for app&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/toddmotto/angular-styleguide&#34;&gt;AngularJS styleguide from Todd Motto&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;generators&#34;&gt;Generators&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Swiip/generator-gulp-angular/blob/master/docs/usage.md#features-included-in-the-gulpfile&#34;&gt;Yo gulp-angular generator&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>